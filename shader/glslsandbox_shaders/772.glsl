{"code": "// By @paulofalcao\n//\n// Merry Christmas! :)\n//\n//\n// Some GLSL compilers/drivers can't optimize the exit from the loop on break\n// and always run all iterations.\n//\n// Works very nice on my MacBook Pro with NVIDIA 320M on MacOSX 10.7 / Chrome\n// But runs very very slow on a Macbook Pro NVIDIA 320M on Win7 / Chrome\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n//Util Start\n\nfloat PI=3.14159265;\n\nvec2 ObjUnion(vec2 obj0,vec2 obj1){\n  if (obj0.x<obj1.x)\n    return obj0;\n  else\n    return obj1;\n}\n\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\nvec2 rot(vec2 p,float r){\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\nvec2 rotsim(vec2 p,float s){\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\nfloat rnd(vec2 v){\n  return sin((sin(((v.y-1453.0)/(v.x+1229.0))*23232.124))*16283.223)*0.5+0.5; \n}\n\nfloat noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=rnd(v1);\n  float n01=rnd(v1+vec2(0,1));\n  float n10=rnd(v1+vec2(1,0));\n  float n11=rnd(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\n//Util End\n\n \n//Scene Start\n \n//Floor\nvec2 obj0(in vec3 p){\n  if (p.y<0.4)\n  p.y+=sin(p.x)*0.4*cos(p.z)*0.4;\n  return vec2(p.y,0);\n}\n\nvec3 obj0_c(vec3 p){\n  float f=\n    noise(p.xz)*0.5+\n    noise(p.xz*2.0+13.45)*0.25+\n    noise(p.xz*4.0+23.45)*0.15;\n  float pc=min(max(1.0/length(p.xz),0.0),1.0)*0.5;\n  return vec3(f)*0.3+pc+0.5;\n}\n\n//Snow\nfloat makeshowflake(vec3 p){\n  return length(p)-0.03;\n}\n\nfloat makeShow(vec3 p,float tx,float ty,float tz){\n  p.y=p.y+time*tx;\n  p.x=p.x+time*ty;\n  p.z=p.z+time*tz;\n  p=sim(p,4.0);\n  return makeshowflake(p);\n}\n\nvec2 obj1(vec3 p){\n  float f=makeShow(p,1.11, 1.03, 1.38);\n  f=min(f,makeShow(p,1.72, 0.74, 1.06));\n  f=min(f,makeShow(p,1.93, 0.75, 1.35));\n  f=min(f,makeShow(p,1.54, 0.94, 1.72));\n  f=min(f,makeShow(p,1.35, 1.33, 1.13));\n  f=min(f,makeShow(p,1.55, 0.23, 1.16));\n  f=min(f,makeShow(p,1.25, 0.41, 1.04));\n  f=min(f,makeShow(p,1.49, 0.29, 1.31));\n  f=min(f,makeShow(p,1.31, 1.31, 1.13));  \n  return vec2(f,1.0);\n}\n \nvec3 obj1_c(vec3 p){\n    return vec3(1,1,1);\n}\n\n\n//Star\nvec2 obj2(vec3 p){\n  p.y=p.y-4.3;\n  p=p*4.0;\n  float l=length(p);\n  if (l<2.0){\n  p.xy=rotsim(p.xy,2.5);\n  p.y=p.y-2.0; \n  p.z=abs(p.z);\n  p.x=abs(p.x);\n  return vec2(dot(p,normalize(vec3(2.0,1,3.0)))/4.0,2);\n  } else return vec2((l-1.9)/4.0,2.0);\n}\n\nvec3 obj2_c(vec3 p){\n  return vec3(1.0,0.5,0.2);\n}\n \n//Objects union\nvec2 inObj(vec3 p){\n  return ObjUnion(ObjUnion(obj0(p),obj1(p)),obj2(p));\n}\n \n//Scene End\n \nvoid main(void){\n  vec2 vPos=-1.0+2.0*gl_FragCoord.xy/resolution.xy;\n \n  //Camera animation\n  vec3 vuv=normalize(vec3(sin(time)*0.3,1,0));\n  vec3 vrp=vec3(0,cos(time*0.5)+2.5,0);\n  vec3 prp=vec3(sin(time*0.5)*(sin(time*0.39)*2.0+3.5),sin(time*0.5)+3.5,cos(time*0.5)*(cos(time*0.45)*2.0+3.5));\n  float vpd=1.5;  \n \n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*resolution.x/resolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n \n  //lights are 2d, no raymarching\n  mat4 cm=mat4(\n    u.x,   u.y,   u.z,   -dot(u,prp),\n    v.x,   v.y,   v.z,   -dot(v,prp),\n    vpn.x, vpn.y, vpn.z, -dot(vpn,prp),\n    0.0,   0.0,   0.0,   1.0);\n \n  vec4 pc=vec4(0,0,0,0);\n  const float maxl=40.0;\n  for(float i=0.0;i<maxl;i++){\n  vec4 pt=vec4(\n    sin(i*PI*2.0*7.0/maxl)*2.0*(1.0-i/maxl),\n    i/maxl*4.0,\n    cos(i*PI*2.0*7.0/maxl)*2.0*(1.0-i/maxl),\n    1.0);\n  pt=pt*cm;\n  vec2 xy=(pt/(-pt.z/vpd)).xy+vPos*vec2(resolution.x/resolution.y,1.0);\n  float c;\n  c=0.4/length(xy);\n  pc+=vec4(\n          (sin(i*5.0+time*10.0)*0.5+0.5)*c,\n          (cos(i*3.0+time*8.0)*0.5+0.5)*c,\n          (sin(i*6.0+time*9.0)*0.5+0.5)*c,0.0);\n  }\n  pc=pc/maxl;\n\n  pc=smoothstep(0.0,1.0,pc);\n  \n  //Raymarching\n  const vec3 e=vec3(0.1,0,0);\n  const float maxd=15.0; //Max depth\n \n  vec2 s=vec2(0.1,0.0);\n  vec3 c,p,n;\n \n  float f=1.0;\n  for(int i=0;i<64;i++){\n    if (abs(s.x)<.001||f>maxd) break;\n    f+=s.x;\n    p=prp+scp*f;\n    s=inObj(p);\n  }\n  \n  if (f<maxd){\n    if (s.y==0.0)\n      c=obj0_c(p);\n    else if (s.y==1.0)\n      c=obj1_c(p);\n    else\n      c=obj2_c(p);\n      if (s.y<=1.0){\n        gl_FragColor=vec4(c*max(1.0-f*.08,0.0),1.0)+pc;\n      } else{\n         //tetrahedron normal   \n         const float n_er=0.01;\n         float v1=inObj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;\n         float v2=inObj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;\n         float v3=inObj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;\n         float v4=inObj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;\n         n=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n  \n        float b=max(dot(n,normalize(prp-p)),0.0);\n        gl_FragColor=vec4((b*c+pow(b,8.0))*(1.0-f*.01),1.0)+pc;\n      }\n  }\n  else gl_FragColor=vec4(0,0,0,0)+pc; //background color\n}", "user": "ff6db8b", "parent": "/e#729.0", "id": "772.0"}