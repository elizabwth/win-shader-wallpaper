{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4sdGR8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvec3 chequer(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 != uv.y > 0.5 ? vec3(0.6, 0.6, 1.0) : vec3(1.0, 1.0, 0.6);\n}\n\n#define PI 3.14159265359\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n/* \n   These functions take a \"camera\" variable specifying:\n     X/Y: Where on the screen we are rendering.\n     Z: How far forwards we are.\n   And return:\n     X/Y: UVs you can use for texture mapping.\n     Z: How far the pixel is.\n*/\n\n/* A wall directly in front of you. */\nvec3 planeZ(float z, vec3 camera) {\n    z -= camera.z;\n    return vec3(camera.xy * z, z);\n}\n\n/* Parallel walls to the left/right of you. */\nvec3 planeX(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor, abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* Parallel floor and ceiling. */\nvec3 planeY(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor, abs(divisor) + camera.z, abs(divisor));\n}\n\n/* \n\tParallel walls to the left/right of you. \n\tLines up with tunnels.\n*/\nvec3 planeXForTunnel(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(camera.y * divisor + (camera.x > 0.0 ? 0.0 : (camera.y > 0.0 ? 2.0 : -2.0)), abs(divisor) + camera.z, abs(divisor));\n}\n        \n/* \n\tParallel floor and ceiling. \n\tLines up with tunnels.\n*/\nvec3 planeYForTunnel(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * divisor + (camera.y > 0.0 ? 1.0 : -1.0), abs(divisor) + camera.z, abs(divisor));\n}\n\n/* A round tunnel. */\nvec3 tunnel(float radius, vec3 camera) {\n    float dist = radius / length(camera.xy);\n    return vec3(atan(camera.y, camera.x) * radius / HalfPI, dist + camera.z, dist);\n}\n\n/* Similar to planeZ, but matches up with tunnel. */\nvec3 tunnelEnd(float z, float radius, vec3 camera) {\n    float angle = atan(camera.x, camera.y);\n    float dist = length(camera.xy);\n    return vec3(angle * radius / HalfPI, dist * (z - camera.z), z - camera.z);\n}\n\n/* -------------------------------------------------------- */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n\n    vec4 mouse = vec4(0.0);\n    mouse *= 2.0;\n    aspectNdc -= mouse.xy;\n    aspectNdc /= 1.0 + dot(mouse.xy, aspectNdc);\n\n    \n    vec3 camera = vec3(aspectNdc, iTime);\n    \n\tvec3 ringInside = tunnel(1.0, camera);\n    \n    vec3 ringFront = tunnelEnd(floor(ringInside.y) + 1.0, 1.0, camera);\n    \n    vec3 wall = planeX(2.0, camera);\n    \n    vec3 pillarSide = planeX(3.0, camera);\n    vec3 pillarFront = planeZ(floor(pillarSide.y) + 0.75, camera);\n    \n    vec3 sea = planeY(1.0, camera);\n\n    vec3 compute;\n    \n    if(fract(ringInside.y) < 0.25) {\n        compute = ringInside;\n    } else {\n        if(ringFront.y < 1.2) {\n            compute = ringFront;\n        } else {\n            if(abs(sea.x) > 2.0) {\n                if(fract(pillarSide.y) > 0.75) {\n                    if(abs(pillarSide.x) < 1.0) {\n                        compute = pillarSide;\n                    } else {\n                        compute = sea;\n                    }\n                } else {\n                    if(abs(pillarFront.y) < 1.0) {\n                        if(abs(pillarFront.x) < 3.5) {\n                            compute = pillarFront;\n                        } else {\n                            compute = sea;\n                        }\n                    } else {\n                        compute = sea;\n                    }\n                }\n            } else {\n                compute = wall;\n            }\n        }\n    }\n   \n    \n\tfragColor = vec4(mix(vec3(0.8, 0.9, 1.0), mix(vec3(0.6, 0.7, 1.0), chequer(compute.xy) / (1.0 + compute.z * 0.5), 1.0 / (1.0 + compute.z * 0.2)), 1.0 / (1.0 + compute.z * 0.05)), 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n\nvoid main(void)\n{\n  iTime = time;\n  iResolution = vec3(resolution, 0.0);\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "c2da9a7", "parent": null, "id": "45650.0"}