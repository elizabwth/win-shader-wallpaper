{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/MdccWr\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nvec3  iResolution;\nfloat iTime;\n\n// --------[ Original ShaderToy begins here ]---------- //\n\n// mostly inspired/taken from hglib, but fairly standard now in shadertoy\n// http://mercury.sexy/hg_sdf/\nfloat rep(float p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvec3 rep(vec3 p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x)p = p.yx;\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = rep(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n// </hglib>\n\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\n// signed cross (iq, from the menger cube article)\n// http://www.iquilezles.org/www/articles/menger/menger.htm\nfloat sc(vec3 p) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - .02;\n}\n\n#define sph(p, r) (length(p) - r)\n#define cyl sph\n\nvec3 g;\n\nfloat de(vec3 p) {\n\tp.xy -= path(p.z);\n    \n    p.xy *= r2d(1.57);// pi/2\n\tmo(p.xy, vec2(.9, 3.));\n\tmo(p.xy, vec2(.9, .3));\n    vec3 q = p;\n\t\n    float d = cyl(p.xy, .13); // cylinder\n    p.z = rep(p.z, 4.);\n\td = min(d, sph(p, .2));// sphere\n    \n\tamod(p.xy, .785);// pi/4\n\tmo(p.zy, vec2(1., 1.2));\n\tp.z = rep(p.z, 1.);\n\td = min(d, sc(p));// cross 1\n    \n    amod(q.xy, 2.09);// pi/1.5\n    mo(q.zy, vec2(.2, 3.1));\n    mo(q.xy, vec2(.0, .4));\n\tq.z = rep(q.z, 1.);\n    d = min(d, sc(q));// cross 2\n\n    // glow trick from balkhan\n    // i.e. https://www.shadertoy.com/view/4t2yW1\n\tg += vec3(.5, .6, .5) * .025 / (.01 + d*d);\n\treturn d;\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -4. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n    vec3 rd;\n    \n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n    \n\trd = camera(ro, uv, ta);\n\n\tfloat ri = 0., t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i; vec3 p = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d<.001 || t>100.) break;\n\t\tt += d*.2;\n\n\t}\n\n\tvec3 c = mix(vec3(.9, .2, .4), vec3(.3, cos(iTime)*.1, .2), uv.x + ri);\n\tc.r *= sin(iTime);\n\tc += g * .015;\n\tfragColor = vec4(c, 1);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n  g = vec3(.0);\n  iResolution = vec3(resolution, 0.0);\n  iTime = time;\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "b8c9b77", "parent": null, "id": "45231.1"}