{"code": "// Escher's prentententoonstelling. Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/Mdf3zM\n//\n// Study of the transformation of Escher in 'the prentententoonstelling'\n//\n// http://www.ams.org/notices/200304/fea-escher.pdf\n// h(w) = w\u03b1 = w^((2\u03c0i+log scale)/(2\u03c0i))\n//\n// distancefield functions by inigo quilez.\n//\n// this glslsandbox port by phase\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#define SHADOW\n#define WOBBLE\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat t = 0.;\n\nfloat st = 0., zt = 0.;\n\nfloat deformationScale, zoom;\n\nvec2 escherDeformation( in vec2 uv ) {\n\t\n    // http://www.ams.org/notices/200304/fea-escher.pdf\n    // h(w) = w\u03b1 = w^((2\u03c0i+log scale)/(2\u03c0i))\n\t\n\tfloat lnr = log(length(uv));\n\tfloat th = atan( uv.y, uv.x )+(0.4/256.)*deformationScale;\n\tfloat sn = -log(deformationScale)*(1./(2.*3.1415926));\n\tfloat l = exp( lnr - th*sn );\n\t\n\tvec2 ret = vec2( l );\n\t\n\tret.x *= cos( sn*lnr+th );\n\tret.y *= sin( sn*lnr+th );\n    \n\treturn ret;\n}\n\n#define drostescale 256.\n\nvec2 drosteTransformation( in vec2 uv ) {\n\tfor( int i=0; i<2; i++ ) {\n\t\tif(any(greaterThan(abs(uv),vec2(1.)))) {\n\t\t\tuv *= (1./drostescale);\n\t\t}\n\t\tif(all(lessThan(abs(uv),vec2(1./drostescale)))) {\n\t\t\tuv *= drostescale;\n\t\t}\n\t}\n\treturn uv;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y+14.+0.05*cos(p.x+time*2.);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b) {\n    return length(max(abs(p)-b,0.0));\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*0.4+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderYZ( vec3 p, vec2 h ) {\n    return max( length(p.yz)-h.x, abs(p.x)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n//----------------------------------------------------------------------\n\n\nfloat objPrentenTentoonstelling( in vec3 pos ) {\n\tvec3 tpos;// = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(opU(opU(opU(opU(\n                                    opS(opS(opS( // main building\n                                                opS(\n                                                    udBox( tpos, vec3( 5.5, 24.0, 5.5 ) ),\n                                                    sdBox( vec3(tpos.x, tpos.y-24.0, tpos.z), vec3( 5.25, 0.5, 5.25) )\n                                                    ),\n                                                sdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-21.5, tpos.z-5.), vec3( 1.,1.,4.) )\n                                                ),\n                                            sdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-15.5, tpos.z-5.), vec3( 1.,2.,4.) )\n                                            ),\n                                        sdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-17.5, tpos.z-5.), vec2( 1.,4.) )\n                                        ),\n                                    opI( // main building windows\n                                        udBox( tpos, vec3( 5.5, 23., 5.5 ) ),\n                                        opU(\n                                            udBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-5.2), vec3( 0.05, 24., 0.05 ) ),\n                                            udBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-5.2), vec3( 10.0, 0.05, 0.05 ) )\n                                            )\n                                        )\n                                    ),\n                                opS( // gallery\n                                    opU(opU(opU(\n                                                opS(opS(\n                                                        udBox( tpos, vec3( 8.375, 8.75, 8.375 ) ),\n                                                        sdCylinderXY( vec3( mod(tpos.x, 2.75)-1.375, tpos.y-6.5, tpos.z-8.75), vec2( 1.25,2.75) )\n                                                        ),\n                                                    sdBox( vec3(  mod(tpos.x, 2.75)-1.375, tpos.y-4.5, tpos.z-8.75), vec3( 1.25,2.0,2.75) )\n                                                    ),\n                                                udBox(  vec3( mod(tpos.x-8.375/18., 8.375/9.)-8.375/18., tpos.y, tpos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n                                                ),\n                                            udBox(  vec3( tpos.x, tpos.y-4.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) )\n                                            ),\n                                        udBox(  vec3( tpos.x, tpos.y-6.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) )\n                                        ),\n                                    opU(opU(opU(\n                                                sdCylinderYZ( vec3( pos.x-8.75, pos.y-6.5, mod(pos.z, 13.75)-6.875), vec2( 1.25,20.) ),\n                                                sdBox( vec3(  pos.x-8.75, pos.y-2.5, mod(pos.z,  13.75)-6.875), vec3( 20.,4.0,1.25) )\n                                                ),\n                                            sdCylinderXY( vec3( mod(pos.x,13.75)-6.875, pos.y-6.5, pos.z-8.75), vec2( 1.25,20.) )\n                                            ),\n                                        sdBox( vec3(  mod(pos.x, 13.75)-6.875, pos.y-2.5, pos.z-8.75), vec3( 1.25,4.0,20.) )\n                                        )\n                                    ) ),\n                            sdTriPrism( vec3(tpos.x, tpos.y-9.3, tpos.z-5.2), vec2(2.0, 10. ) ) // roof\n                            ),\n                        sdTriPrism( vec3(tpos.x, tpos.y-2.8, tpos.z-5.2), vec2(0.75, 8. ) )\n                        ),\n                    udBox( tpos, vec3( 6.5, 2.5, 6.5 ) )\n                    );\n\t\n\treturn res;\n}\n\nfloat objB1( in vec3 pos ) {\n\tfloat res =\n    opU(opS(\n\t\t\topS(\n\t\t\t\tudBox( pos, vec3( 20., 30.0, 10. ) ),\n\t\t\t\tsdBox( pos+vec3(0., -30., 0.), vec3( 19.75, 1., 9.75 ) )\n                ),\n\t\t\tsdBox( vec3( mod(pos.x+1.75, 3.5)-1.75, mod(pos.y+3.5, 7.)-2., pos.z-10.), vec3( 1.,1.,4.) )\n            ),\n        opI( // main building windows\n            udBox( pos, vec3( 18., 30.0, 10. ) ),\n            opU(\n                udBox(  vec3( mod(pos.x+1.75, 3.5)-1.75, pos.y, pos.z-9.8), vec3( 0.05, 30., 0.05 ) ),\n                udBox(  vec3( pos.x, mod(pos.y+0.425, 1.75)-0.875, pos.z-9.8), vec3( 50.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\treturn res;\n}\n\nfloat objB2( in vec3 pos ) {\n\tvec3 tpos;// = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(\n                    opS(opS( // main building\n                            opS(\n                                udBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n                                sdBox( vec3(tpos.x, tpos.y-31.0, tpos.z), vec3( 8.5, 1.0, 8.5) )\n                                \n                                ),\n                            sdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) )\n                            ),\n                        sdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n                        ),\n                    opI( // main building windows\n                        udBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n                        opU(\n                            udBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, 31., 0.05 ) ),\n                            udBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n                            )\n                        )\n                    );\n\treturn res;\n}\n\nvec2 map( in vec3 pos ) {\n    vec2 res = opU( vec2( sdPlane( pos), 3.0 ),\n                   vec2( udBox( pos+vec3(0.0, 9.0, 85.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n    \n\tres = opU( res, vec2( udBox( pos+vec3(0.0, 20.0, 75.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n \tres = opU( res, vec2( udBox( pos+vec3(0.0, 6.5, -15.0), vec3( 200., 10.0, 0.25 ) ), 1. ) );\n    \n\tres = opU( res, vec2( udBox( pos+vec3( 220.0, 14.0, 0.0), vec3( 100., 10.0, 200. ) ), 1. ) );\n    \n\tres = opU( res, vec2( udBox( (pos+vec3(3.20, -4.95, -5.55)), vec3( 0.55, 0.9, 0.01 ) ), 2. ) );\n\tres = opU( res, vec2( sdCylinderXZ( vec3(mod(pos.x+8., 16.)-8., pos.y+10., pos.z-24.), vec2( 0.4, 1.5)), 1.) );\n    \n\tif( pos.z > 20. ) {\n\t\treturn res;\n\t}\n\t\n\tres = opU( res, vec2( objPrentenTentoonstelling( vec3(mod(pos.x+40.,80.)-40., pos.y, mod(pos.z+40.,80.)-40.) ), 1. ) );\n\t\n\tpos += vec3(3.25, -4.60, -5.55);\n\tres = opU( res, vec2( opI(\n                              udBox( vec3(mod(pos.x+0.8, 1.6)-0.8, pos.y, pos.z), vec3( 0.7, 0.9, 0.1 ) ),\n                              udBox( pos-vec3(3.25, -4.60, -5.55), vec3( 5.5, 5.5, 8.5 ) )\n                              ), 4. ) );\n\tpos -= vec3(3.25, -4.60, -5.55);\n\t\n\tpos += vec3( 15.5, 8., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+27.,54.)-27., pos.y, mod(pos.z+50.,100.)-50.) ), 1. ) );\n\tpos += vec3( 20.5, -8., 5.);\n\tres = opU( res, vec2( objB2( vec3(mod(pos.x+23.,46.)-23., pos.y, mod(pos.z+35.,70.)-35.) ), 1. ) );\n\tpos += vec3( 20., -10., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+77.,144.)-77., pos.y, mod(pos.z+66.,132.)-66.) ), 1. ) );\n    \n\treturn res;\n}\n\n\n// fast castfunctions to detect if droste picture is hit by ray\n\nfloat fastObjPrentenTentoonstelling( in vec3 pos ) {\n\treturn opU(\tudBox(  vec3( pos.x, pos.y-6.3, pos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ),\n               udBox(  vec3( mod(pos.x-8.375/18., 8.375/9.)-8.375/18., pos.y, pos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n               );\n}\nvec2 fastMap( in vec3 pos ) {\n    return opU( vec2( fastObjPrentenTentoonstelling( pos), 1.0 ),\n               vec2( udBox( (pos+vec3(3.30, -4.55, -5.55)), vec3( 0.55, 0.7, 0.01 ) ), 2. ) );\n}\n\nvec2 fastCastRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = fastMap( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n    \n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = map( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n    \n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n    for( int i=0; i<15; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n            float h = map( ro + rd*t ).x;\n            res = min( res, k*h/t );\n            t += 0.005+h;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n                    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n                    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n                    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid getRoAndRd( in vec2 uv, out vec3 ro, out vec3 rd ) {\n#ifdef WOBBLE\n\tro = vec3( 20.2+(1.0+cos((t+42.)/48.*2.*3.1415926))*cos(time), 36.0, 47.0  );\n#else\n\tro = vec3( 20.2, 36.0, 47.0  );\n#endif\t\n\tvec3 ta = vec3( -3.1, 4.8,  5.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\trd = normalize( uv.x*cu + uv.y*cv + cw*zoom);\n}\n\nbool hitDrostePicture( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\t\n\t\n\tvec2 res = fastCastRay(ro,rd,200.0);\n\treturn (res.y == 2. );\n}\n\nvec4 trace( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\n\t\n    vec3 col = vec3(0.);\n    \n    vec2 res = castRay(ro,rd,400.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n\t\tcol = vec3(0.7);\n\t\tif( m == 3. ) col = vec3(0.6,0.71,1.0);\n\t\tif( m == 4. ) col = vec3( 1. );\n\t\t\n\t\tif( m == 1. && all(lessThan(abs(pos), vec3( 5.65, 10., 5.65 ) ) ) ) {\n\t\t\tcol = vec3( 0.6 ); // inside gallery\n\t\t}\n\t\t\n\t\tvec3 lig = normalize( vec3(-0.4, 0.4, 0.8) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \n\t\tfloat sh = 1.0;\n#ifdef SHADOW\t\t\n\t\tif( dif>0.05 ) { sh = softshadow( pos, lig, 0.1, 30.0, 5.0 ); dif *= (0.8+0.2*sh); }\n#endif\t\t\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.80*amb*vec3(0.6,0.71,0.85);\n        brdf += 1.30*dif*vec3(1.00,0.90,0.70);\n        \n\t\tcol = col*brdf;\n\t\t\n\t} else {\n\t\tcol = 1.2*vec3(0.6,0.71,0.85) - rd.y*0.2*vec3(1.0,0.5,1.0);\n\t}\n    \n\treturn vec4( clamp(col,0.0,1.0), m );\n}\n\nvoid init() {\n\tt = mod(time, 48.);\n\tt = mod( t+11., 48. );\n    \n\tif( t < 8. ) st = t;\n\telse if( t < 24. ) st = 8.;\n\telse if( t < 32. ) st = 32.-t;\n    \n\tt = mod( t+12., 48. );\n    \n\tif( t < 8. ) zt = t;\n\telse if( t < 24. ) zt = 8.;\n\telse if( t < 32. ) zt = 32.-t;\n    \n\tdeformationScale = clamp(pow(2.0,st), 1., 256.);\n\tzoom = 2.8*clamp(pow(2.0,zt), 1.0, 256. );\n}\n\nvoid main( void )\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\n\tuv = 2.*uv - vec2(1.);\n    uv.x *= resolution.x/ resolution.y;\n    \n\tinit();\n\t\n\tvec3 col = vec3(0.);\n    \n\tbool band = abs(uv.x)>1.?true:false;\n\t\n\t// the  gallerymodel is a factor 1./0.7 too high to match Eschers painting, so I cheat :(\n\tuv.x *= 0.7;\n\tuv = escherDeformation(uv);\t\n\tuv = drosteTransformation(uv);\n\t\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\t\n\t\n\tvec4 tr = trace( uv );\n\tcol = tr.xyz;\n\t\n\tif( band ) {\n\t\tcol = mix( col, vec3(0.), st/8. );\t\n\t}\t\t\n\t\n\tgl_FragColor = vec4( col,1.0);\n}", "user": "24f0dc", "parent": null, "id": "25355.1"}