{"code": "// Cross-platform workarounds.\n// ------------------------------------------------------------------------------------\n\n//#define SHADERTOY\n#define GLSLSANDBOX\n\n// ShaderToy defines this itself, but not all sandboxes do.\n#ifndef SHADERTOY\n\t#ifdef GL_ES\n\tprecision mediump float;\n\t#endif\n#endif\n\n// Almost all GLSL sandboxes include a resolution uniform, but they're all named differently\n// and have different things in the axes.  This should always return the width/height of the\n// display in pixels as a vec2.\n#ifdef SHADERTOY \n\t#define RESOLUTION iResolution.xy \n#endif\n#ifdef GLSLSANDBOX\n\tuniform vec2 resolution;\n\t#define RESOLUTION resolution\n#endif\n\n// Almost all GLSL sandboxes include a time uniform, but they're all named differently.\n// This should always return the time since the start of the animation, in seconds.\n#ifdef SHADERTOY \n\t#define TIME iGlobalTime\n#endif\n#ifdef GLSLSANDBOX\n\tuniform float time;\n\t#define TIME time\n#endif\n\n// Some GLSL sandboxes don't allow direct access to gl_FragCoord, so it can be aliased here.\n#ifdef SHADERTOY\n\t#define FRAGCOORD fragCoord\n#else\n\t#define FRAGCOORD gl_FragCoord.xy\n#endif\n\n// Some GLSL sandboxes don't allow direct access to gl_FragColor, so it can be aliased here.\n#ifdef SHADERTOY\n\t#define FRAGCOLOR fragColor\n#else\n\t#define FRAGCOLOR gl_FragColor\n#endif\n\n// Misc. tools.\n// ------------------------------------------------------------------------------------\n\n// IE11 has problems with 1.0/0.0.\n#define INFINITY 10000.0\n\n// Returns the location of the current fragment relative to the center of the screen, where 0.5 is the distance to the nearest screen border.\n// This will return values > +-0.5 on the X axis in widescreen, and the Y axis in portrait.\n#define PixelCoord ((FRAGCOORD - (RESOLUTION / 2.0)) / min(RESOLUTION.x, RESOLUTION.y))\n\n// Lenses.\n// ------------------------------------------------------------------------------------\n// Lenses generate a ray for the current pixel, storing where it starts in \"rayStart\",\n// and a normal along which it points in \"rayNormal\".\n\n// A very simplistic, not in any way accurate or \"true\" lens.  FieldOfView can be any positive value.\n#define SimpleLens(fieldOfView) { rayStart = vec3(0.0); vec2 coord = PixelCoord; rayNormal = normalize(vec3(coord.x / fieldOfView, 1.0, coord.y / fieldOfView)); }\n\n// Surfaces.\n// ------------------------------------------------------------------------------------\n// These are raytraceable surfaces, reading from rayStart and rayNormal to find the\n// distance along that ray to the surface.  (calling ApplySurface to store it in \"nearest\") \n//\n// They are not themselves rendered.\n//\n// When rendering lights, this position is used instead of the closest point on the ray\n// to the light origin if it is closer to the start of the ray.\n// Write to \"nearest\" if you are closer than the value already there.\n\n// Given the distance to a surface, first checks it is not behind the camera, then that it is\n// closer than what is already stored in \"nearest\" and overwrites it if so.\n#define ApplySurface(dist, pattern) { float _dist = dist; vec3 intersection = rayStart + rayNormal * _dist; if(_dist > 0.0 && _dist < nearest && pattern) nearest = _dist; }\n\n// Given a lowercase axis (x/y/z) and a (float) location on that axis, draws an infinitely \n// large plane there.\n#define AxisSurface(axis, location, pattern) ApplySurface((location - rayStart.axis) / rayNormal.axis, pattern)\n\n// Given a (vec3) location and a (float) radius, draws a sphere at that location of that size.\n#define SphereSurface(location, radius, pattern) { vec3 _location = location; float along = dot(_location - rayStart, rayNormal); float dist = distance(_location, rayStart + rayNormal * along); float _radius = radius; if(dist < _radius) { ApplySurface(along - (_radius * sin(acos(dist / _radius))), pattern) } }\n\nvec3 ClosestTimeOfApproach(vec3 pos1, vec3 vel1, vec3 pos2, vec3 vel2)\n{\n    // There's probably much better ways to calculate this, but I'm not very good at maths, so here's my approach:\n    // A slice of the target line is a point, so if we project the start/end as though we're looking right down the ray,\n    // we can clearly see where the closest point is.2\n    vec3 projStart = pos2 - (vel1 * dot(pos2 - pos1, vel1));\n    vec3 projEnd = vel2 - (vel1 * dot(vel2 - pos1, vel1));\n    vec3 projNorm = normalize(projEnd - projStart);\n  \n    float along = dot(pos1 - projStart, projNorm);\n    vec3 closest = mix(pos2, vel2, clamp(along / distance(projStart, projEnd), 0.0, 1.0));\n    return closest;\n}\n\n// Given the (vec3) location of the start and end of a capsule and a (float) radius, draws a capsule\n// between those locations of that size.  Essentially a cylinder between those locations capped with\n// a sphere; protrudes beyond start/end by radius.\n#define CapsuleSurface(start, end, radius, pattern) { SphereSurface( ClosestTimeOfApproach(rayStart, rayNormal, start, end), radius, pattern ) }\n\n// Patterns.\n// ------------------------------------------------------------------------------------\n// These are functions which define where on a surface is solid, and where is not.\n// They typically take the intersected point (intersection) and return true to make the surface solid.\n\n// Always solid.\n#define SolidPattern true\n\n// Never solid.\n#define NonSolidPattern false\n\n// Given a lowercase axis (x/y/z), a (float) location on that axis and two patterns, one pattern is shown \n// on one side of a plane on that axis at that location, and on the other side, the other pattern.\n#define AxisPattern(axis, location, negativePattern, positivePattern) (intersection.axis > location ? positivePattern : negativePattern)\n\n// Given a spacing between each circle, a radius for each circle and two patterns, one pattern is shown\n// inside a repeating grid of circles while the other is shown outside the circles.\n#define CirclePattern(spacing, radius, insidePattern, outsidePattern)\n\n// Given a (float) spacing between each stripe, a (float) width for the stripes and two patterns, \n// diagonal stripes are drawn with one pattern used on the stripes and the other used off the stripes.\n#define StripePattern(spacing, width, onPattern, offPattern)\n\n// Lights.\n// ------------------------------------------------------------------------------------\n// False volumetric lights computed by taking the closest point to the origin along the ray\n// and then computing the distance/etc. to the origin.  This gives a nice misty looking light.\n// \n// Each light is built in the following steps:\n// - An Origin function.  This determines the distance along the ray to the nearest point to the \n//   light (stored in \"origin\"), storing it in \"originAlong\".  These call common code to reset \n//   \"intensity\" to 1.0 and compute \"originNearest\", the closest point on the ray to the light origin.\n// - One or more Falloff functions.  These use the origin data to determine a coefficient (rolloff\n//   over distance, etc.) and multiply \"intensity\" by it.\n// - A call to Shade to color the light and store it in an accumulator.\n\n// Applies the current light, multiplying it by a color and saving it to the display.\n#define Shade(color) { accumulator += intensity * color; }\n\n// Resets the intensity of the light so its origin can be reused.\n#define ResetFalloff { intensity = 1.0; }\n\n// Called by every origin to setup common data.\n#define SetupOrigin { intensity = 1.0; if(originAlong < 0.0 || originAlong > nearest) { originAlong = nearest; } originNearest = rayStart + rayNormal * originAlong; }\n\n// Origins.\n// ---------------------------------\n\n// Given a location, creates a radial light from that location.\n#define RadialOrigin(location) { origin = location; originAlong = dot(origin - rayStart, rayNormal); SetupOrigin }\n\n// Given a lowercase axis (x/y/z) and a (float) location on that axis, creates a light emitted from\n// an infinite plane there.\n#define AxisOrigin(axis, location)\n\n// Falloffs.\n// ---------------------------------\n\n// The light gets darker the further we are from the origin.  Larger rates fall off quicker.\n// Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n#define DistanceFalloff(rate, linearity) { intensity /= pow(1.0 + distance(origin, originNearest) * rate, linearity); }\n\n// The light gets darker the further off a (vec3) normal we are from the origin.\n// Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n// Note that because we sample the closest point to the origin of the light, on point lights\n// pointing at or away from the camera the spot is infinitely small so the light disappears.\n#define DirectionalFalloff(normal, linearity) { intensity *= pow(max(0.0, dot(normal, normalize(originNearest - origin))), linearity); }\n\nvec3 rotateX(vec3 transform, float angle) {\n    mat3 mat = mat3(1.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, sin(angle), cos(angle));\n    return transform * mat;\n}\n\nvec3 rotateY(vec3 transform, float angle) {\n    mat3 mat = mat3(cos(angle), 0.0, -sin(angle), 0.0, 1.0, 0.0, sin(angle), 0.0, cos(angle));\n    return transform * mat;\n}\n\nvec3 rotateZ(vec3 transform, float angle) {\n    mat3 mat = mat3(cos(angle), -sin(angle), 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 1.0);\n    return transform * mat;\n}\n\n\n// Post-processes.\n// ------------------------------------------------------------------------------------\n// These modify the color stored in \"accumulator\".\n\n// This where main() should be.\n// However, some GLSL sandboxes don't allow you to define main() yourself.\n#ifdef SHADERTOY\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n#else\n    void main()\n#endif\n{\n    vec3 rayStart, rayNormal;\n    \n    float nearest = INFINITY;\n    \n    vec3 origin, originNearest;\n    float originAlong;\n    \n    vec3 accumulator = vec3(0.0);\n    float intensity;    \n    \n    // Start of generated code.\n    SimpleLens(1.0)\n        \n    \n     rayStart.x += 5.9;\n    rayStart.y -= 14.4;\n        rayStart.z += 1.6;\n    \n    rayNormal = rotateZ(rotateX(rayNormal, sin(TIME * 0.4) * 0.1), 0.5 + sin(TIME * 0.5) * 0.1);\n    \n    // Render surfaces.\n    \n    // Road\n    AxisSurface(z, 0.0, SolidPattern)\n        \n    // Sidewalk top.\n        AxisSurface(z, 0.1, \n                    // Left.\n                    AxisPattern(x, -3.0, SolidPattern, \n                                // Right\n                               AxisPattern(x, 3.0, NonSolidPattern, SolidPattern)\n                   ))\n        \n    // Sidewalk left curb.\n        AxisSurface(x, -3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern))\n        \n    // Sidewalk right curb.\n        AxisSurface(x, 3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern)) \n       \n        //Streelights.\n        \n        CapsuleSurface(vec3(-4.425, 8.0, 0.1), vec3(-4.425, 8.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, 8.0, 1.0), vec3(-4.425, 8.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, 8.0, 5.225), vec3(-4.425, 8.0, 5.225), 0.125, SolidPattern)\n        \n        CapsuleSurface(vec3(4.425, -2.0, 0.1), vec3(4.425, -2.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(4.425, -2.0, 1.0), vec3(4.425, -2.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(2.8, -2.0, 5.225), vec3(4.425, -2.0, 5.225), 0.125, SolidPattern) \n        \n               CapsuleSurface(vec3(4.425, 18.0, 0.1), vec3(4.425, 18.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(4.425, 18.0, 1.0), vec3(4.425, 18.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(2.8, 18.0, 5.225), vec3(4.425, 18.0, 5.225), 0.125, SolidPattern)  \n        \n        CapsuleSurface(vec3(-4.425, -12.0, 0.1), vec3(-4.425, -12.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, -12.0, 1.0), vec3(-4.425, -12.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, -12.0, 5.225), vec3(-4.425, -12.0, 5.225), 0.125, SolidPattern)        \n        \n        CapsuleSurface(vec3(-4.425, 28.0, 0.1), vec3(-4.425, 28.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, 28.0, 1.0), vec3(-4.425, 28.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, 28.0, 5.225), vec3(-4.425, 28.0, 5.225), 0.125, SolidPattern)         \n        \n    // Bridge underside.\n        AxisSurface(z, 5.5, AxisPattern(y, 3.4, NonSolidPattern, AxisPattern(y, 28.2, SolidPattern, NonSolidPattern)));\n        \n    // Bridge front.\n    \tAxisSurface(y, 3.4, AxisPattern(z, 5.5, NonSolidPattern, AxisPattern(z, 8.4, SolidPattern, NonSolidPattern)))\n    \n    // Bridge lights.\n            CapsuleSurface(vec3(22.5, 10.0, 13.175), vec3(22.5, 5.6, 12.175), 0.125, SolidPattern)\n            CapsuleSurface(vec3(22.5, 5.6, 7.3), vec3(22.5, 5.6, 12.0), 0.25, SolidPattern)\n            \n            CapsuleSurface(vec3(-7.5, 10.0, 13.175), vec3(-7.5, 5.6, 12.175), 0.125, SolidPattern)\n            CapsuleSurface(vec3(-7.5, 5.6, 7.3), vec3(-7.5, 5.6, 12.0), 0.25, SolidPattern)            \n            \n     // Bridge supports.\n            CapsuleSurface(vec3(12.5, 9.2, 4.8), vec3(12.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(12.5, 22.40618, 4.8), vec3(12.5, 22.40618, -1.75), 2.0, SolidPattern)\n            \n            CapsuleSurface(vec3(-17.5, 9.2, 4.8), vec3(-17.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-17.5, 22.40618, 4.8), vec3(-17.5, 22.40618, -1.75), 2.0, SolidPattern)            \n            \n            CapsuleSurface(vec3(-47.5, 9.2, 4.8), vec3(-47.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-47.5, 22.40618, 4.8), vec3(-47.5, 22.40618, -1.75), 2.0, SolidPattern)   \n            \n            CapsuleSurface(vec3(-77.5, 9.2, 4.8), vec3(-77.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-77.5, 22.40618, 4.8), vec3(-77.5, 22.40618, -1.75), 2.0, SolidPattern)                        \n            \n            // Distant buildings.\n            /*\n            AxisSurface(y, 115.0, AxisPattern(x, -58.7668, NonSolidPattern, AxisPattern(x, -37.55514, SolidPattern, NonSolidPattern)))\n            AxisSurface(x, -37.55514, AxisPattern(y, 115.0, NonSolidPattern, SolidPattern))\n            \n            AxisSurface(y, 123.14195, AxisPattern(x, -30.41511, NonSolidPattern, AxisPattern(x, -9.20345, SolidPattern, NonSolidPattern)))\n            AxisSurface(x, -30.41511, AxisPattern(y, 123.14195, NonSolidPattern, SolidPattern))\n            */\n    // Render lights.\n        #define Rain(size, speed, strength) { intensity *= dot(mix(vec3(strength), vec3(1.0), sin(sin(size * originNearest + TIME * speed) + TIME)), vec3(1.0)); }\n    #define StreetLight DistanceFalloff(1.2, 2.0) DirectionalFalloff(vec3(0.0, 0.0, -1.0), 2.0) Rain(0.5, vec3(1.0, 5.0, 8.0), 0.7) Shade(vec3(1.0, 1.0, 0.6))   \n    RadialOrigin(vec3(-2.8, -12.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(2.8, -2.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(-2.8, 8.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(2.8, 18.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(-2.8, 28.0, 5.225)) StreetLight   \n            \n    #define OverpassLight DistanceFalloff(1.2, 2.0) Rain(0.5, vec3(1.0, 5.0, 8.0), 0.7) Shade(vec3(0.8, 0.4, 0.1))   \n            // Closest side of overpass.\n    RadialOrigin(vec3(22.5, 10.0, 13.05)) OverpassLight              \n            RadialOrigin(vec3(-7.5, 10.0, 13.05)) OverpassLight              \n            RadialOrigin(vec3(-47.5, 10.0, 13.05)) OverpassLight              \n        \n            // Furthest side of overpass.\n          RadialOrigin(vec3(37.5, 21.6, 13.05)) OverpassLight    \n            RadialOrigin(vec3(7.5, 21.6, 13.05)) OverpassLight    \n\t\t\tRadialOrigin(vec3(-22.5, 21.6, 13.05)) OverpassLight    \n            RadialOrigin(vec3(-52.5, 21.6, 13.05)) OverpassLight    \n            /*\n            // Lights between the distant buildings.\n            #define DistantLight(color) DistanceFalloff(1.0, 2.0) Shade(color)\n            \n            RadialOrigin(vec3(-64.3834, 115.0, 1.0)) DistantLight(vec3(0.4, 0.3, 0.0))\n            RadialOrigin(vec3(-35.0, 135.0, 4.0)) DistantLight(vec3(0.5, 0.3, 0.0))\n            RadialOrigin(vec3(-8.0, 150.0, 3.0)) DistantLight(vec3(0.2, 0.1, 0.05))\n            */\n            // A big dim light to help separate things a little.\n            RadialOrigin(vec3(-38.96571, 58.15232, 20.55807)) DistanceFalloff(2.0, 1.0) Shade(vec3(0.0, 0.0, 1.0))\n            \n    // Sky\n        if(nearest == INFINITY) {\n            //accumulator += vec3(0.02, 0.018, 0.005);\n        }\n        \n    // End of generated code.\n    \n    // Gamma correct and wrap for GLSL.\n\tFRAGCOLOR = vec4(pow(accumulator, vec3(1.0 / 2.2)),1.0);\n}", "user": "e35ab39", "parent": null, "id": "24039.0"}