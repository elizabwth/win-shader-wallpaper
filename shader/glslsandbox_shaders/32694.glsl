{"code": "// original:  https://www.shadertoy.com/view/ldyXRw\n\n#define GLSLSANDBOX\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\nprecision mediump float;\n#endif\n\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define u_res resolution\n#define u_time time\n#define u_mouse mouse\nvoid mainImage(_out(vec4) fragColor, _in(vec2) fragCoord);\nvoid main() { mainImage(gl_FragColor, gl_FragCoord.xy); }\n#endif\n\n#ifdef UE4\n_constant(vec2) u_res = vec2(0, 0);\n_constant(vec2) u_mouse = vec2(0, 0);\n_mutable(float) u_time = 0;\n#endif\n\n#define PI 3.14159265359\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n#define max_dist 1e8\n_constant(hit_t) no_hit = _begin(hit_t)\n\tfloat(max_dist + 1e1), // 'infinite' distance\n\t-1, // material id\n\tvec3(0., 0., 0.), // normal\n\tvec3(0., 0., 0.) // origin\n_end;\n\n// ----------------------------------------------------------------------------\n// Various 3D utilities functions\n// ----------------------------------------------------------------------------\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t_end;\n\treturn r;\n}\n\n_constant(mat3) mat3_ident = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n#ifndef HLSL\nmat3 transpose(\n\t_in(mat3) m\n){\n\treturn mat3(\n\t\tm[0][0], m[1][0], m[2][0],\n\t\tm[0][1], m[1][1], m[2][1],\n\t\tm[0][2], m[1][2], m[2][2]);\n}\n#endif\n\nmat2 rotate_2d(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\t_in(float) angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n// http://http.developer.nvidia.com/GPUGems3/gpugems3_ch24.html\nvec3 linear_to_srgb(\n\t_in(vec3) color\n){\n\tconst float p = 1. / 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\nvec3 srgb_to_linear(\n\t_in(vec3) color\n){\n\tconst float p = 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\n#ifdef __cplusplus\nvec3 faceforward(\n\t_in(vec3) N,\n\t_in(vec3) I,\n\t_in(vec3) Nref\n){\n\treturn dot(Nref, I) < 0 ? N : -N;\n}\n#endif\n\nfloat checkboard_pattern(\n\t_in(vec2) pos,\n\t_in(float) scale\n){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (\n\t_in(float) start,\n\t_in(float) peak,\n\t_in(float) end,\n\t_in(float) t\n){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\n\n// from https://www.shadertoy.com/view/4sSSW3\n// original http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid fast_orthonormal_basis(\n\t_in(vec3) n,\n\t_out(vec3) f,\n\t_out(vec3) r\n){\n\tfloat a = 1. / (1. + n.z);\n\tfloat b = -n.x*n.y*a;\n\tf = vec3(1. - n.x*n.x*a, b, -n.x);\n\tr = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\n\n// ----------------------------------------------------------------------------\n// Analytical surface-ray intersection routines\n// ----------------------------------------------------------------------------\n\n// geometrical solution\n// info: http://www.scratchapixel.com/old/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\nvoid intersect_sphere(\n\t_in(ray_t) ray,\n\t_in(sphere_t) sphere,\n\t_inout(hit_t) hit\n){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tif (tca < 0.) return;\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t) return;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.material_id = sphere.material;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n\n\n// ----------------------------------------------------------------------------\n// Volumetric utilities\n// ----------------------------------------------------------------------------\n\nstruct volume_sampler_t {\n\tvec3 origin; // start of ray\n\tvec3 pos; // current pos of acccumulation ray\n\tfloat height;\n\n\tfloat coeff_absorb;\n\tfloat T; // transmitance\n\n\tvec3 C; // color\n\tfloat alpha;\n};\n\nvolume_sampler_t begin_volume(\n\t_in(vec3) origin,\n\t_in(float) coeff_absorb\n){\n\tvolume_sampler_t v = _begin(volume_sampler_t)\n\t\torigin, origin, 0.,\n\t\tcoeff_absorb, 1.,\n\t\tvec3(0., 0., 0.), 0.\n\t_end;\n\treturn v;\n}\n\nfloat illuminate_volume(\n\t_inout(volume_sampler_t) vol,\n\t_in(vec3) V,\n\t_in(vec3) L\n);\n\nvoid integrate_volume(\n\t_inout(volume_sampler_t) vol,\n\t_in(vec3) V,\n\t_in(vec3) L,\n\t_in(float) density,\n\t_in(float) dt\n){\n\t// change in transmittance (follows Beer-Lambert law)\n\tfloat T_i = exp(-vol.coeff_absorb * density * dt);\n\t// Update accumulated transmittance\n\tvol.T *= T_i;\n\t// integrate output radiance (here essentially color)\n\tvol.C += vol.T * illuminate_volume(vol, V, L) * density * dt;\n\t// accumulate opacity\n\tvol.alpha += (1. - T_i) * (1. - vol.alpha);\n}\n\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\n// ----------------------------------------------------------------------------\n\nfloat hash(\n\t_in(float) n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n#if 1\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n#else\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#endif\n}\n\n#define noise(x) noise_iq(x)\n\n// ----------------------------------------------------------------------------\n// Fractional Brownian Motion\n// depends on custom basis function\n// ----------------------------------------------------------------------------\n\n#define DECL_FBM_FUNC(_name, _octaves, _basis) float _name(_in(vec3) pos, _in(float) lacunarity, _in(float) init_gain, _in(float) gain) { vec3 p = pos; float H = init_gain; float t = 0.; for (int i = 0; i < _octaves; i++) { t += _basis * H; p *= lacunarity; H *= gain; } return t; }\n\nDECL_FBM_FUNC(fbm, 4, noise(p))\n\n// ----------------------------------------------------------------------------\n// Planet\n// ----------------------------------------------------------------------------\n_constant(sphere_t) planet = _begin(sphere_t)\n\tvec3(0, 0, 0), 1., 0\n_end;\n\n#define max_height .4\n#define max_ray_dist (max_height * 4.)\n\nvec3 background(\n\t_in(ray_t) eye\n){\n#if 0\n\treturn vec3(.15, .3, .4);\n#else\n\t_constant(vec3) sun_color = vec3(1., .9, .55);\n\tfloat sun_amount = dot(eye.direction, vec3(0, 0, 1));\n\n\tvec3 sky = mix(\n\t\tvec3(.0, .05, .2),\n\t\tvec3(.15, .3, .4),\n\t\t1.0 - eye.direction.y);\n\tsky += sun_color * min(pow(sun_amount, 30.0) * 5.0, 1.0);\n\tsky += sun_color * min(pow(sun_amount, 10.0) * .6, 1.0);\n\n\treturn sky;\n#endif\n}\n\nvoid setup_scene()\n{\n}\n\nvoid setup_camera(\n\t_inout(vec3) eye,\n\t_inout(vec3) look_at\n){\n#if 0\n\teye = vec3(.0, 0, -1.93);\n\tlook_at = vec3(-.1, .9, 2);\n#else\n\teye = vec3(0, 0, -2.5);\n\tlook_at = vec3(0, 0, 2);\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// Clouds\n// ----------------------------------------------------------------------------\n#define CLOUDS\n\n#define anoise (abs(noise(p) * 2. - 1.))\nDECL_FBM_FUNC(fbm_clouds, 4, anoise)\n\n#define vol_coeff_absorb 30.034\n_mutable(volume_sampler_t) cloud;\n\nfloat illuminate_volume(\n\t_inout(volume_sampler_t) cloud,\n\t_in(vec3) V,\n\t_in(vec3) L\n){\n\treturn exp(cloud.height) / .055;\n}\n\nvoid clouds_map(\n\t_inout(volume_sampler_t) cloud,\n\t_in(float) t_step\n){\n\tfloat dens = fbm_clouds(\n\t\tcloud.pos * 3.2343 + vec3(.35, 13.35, 2.67),\n\t\t2.0276, .5, .5);\n\n\t#define cld_coverage .29475675 // higher=less clouds\n\t#define cld_fuzzy .0335 // higher=fuzzy, lower=blockier\n\tdens *= smoothstep(cld_coverage, cld_coverage + cld_fuzzy, dens);\n\n\tdens *= band(.2, .35, .65, cloud.height);\n\n\tintegrate_volume(cloud,\n\t\tcloud.pos, cloud.pos, // unused dummies \n\t\tdens, t_step);\n}\n\nvoid clouds_march(\n\t_in(ray_t) eye,\n\t_inout(volume_sampler_t) cloud,\n\t_in(float) max_travel,\n\t_in(mat3) rot\n){\n\tconst int steps = 75;\n\tconst float t_step = max_ray_dist / float(steps);\n\tfloat t = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tif (t > max_travel || cloud.alpha >= 1.) return;\n\t\t\t\n\t\tvec3 o = cloud.origin + t * eye.direction;\n\t\tcloud.pos = mul(rot, o - planet.origin);\n\n\t\tcloud.height = (length(cloud.pos) - planet.radius) / max_height;\n\t\tt += t_step;\n\t\tclouds_map(cloud, t_step);\n\t}\n}\n\nvoid clouds_shadow_march(\n\t_in(vec3) dir,\n\t_inout(volume_sampler_t) cloud,\n\t_in(mat3) rot\n){\n\tconst int steps = 5;\n\tconst float t_step = max_height / float(steps);\n\tfloat t = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 o = cloud.origin + t * dir;\n\t\tcloud.pos = mul(rot, o - planet.origin);\n\n\t\tcloud.height = (length(cloud.pos) - planet.radius) / max_height;\n\t\tt += t_step;\n\t\tclouds_map(cloud, t_step);\n\t}\n}\n\n// ----------------------------------------------------------------------------\n// Terrain\n// ----------------------------------------------------------------------------\n#define TERR_STEPS 120\n#define TERR_EPS .005\n#define rnoise (1. - abs(noise(p) * 2. - 1.))\n\nDECL_FBM_FUNC(fbm_terr, 3, noise(p))\nDECL_FBM_FUNC(fbm_terr_r, 3, rnoise)\n\nDECL_FBM_FUNC(fbm_terr_normals, 7, noise(p))\nDECL_FBM_FUNC(fbm_terr_r_normals, 7, rnoise)\n\nvec2 sdf_terrain_map(_in(vec3) pos)\n{\n\tfloat h0 = fbm_terr(pos * 2.0987, 2.0244, .454, .454);\n\tfloat n0 = smoothstep(.35, 1., h0);\n\n\tfloat h1 = fbm_terr_r(pos * 1.50987 + vec3(1.9489, 2.435, .5483), 2.0244, .454, .454);\n\tfloat n1 = smoothstep(.6, 1., h1);\n\t\n\tfloat n = n0 + n1;\n\t\n\treturn vec2(length(pos) - planet.radius - n * max_height, n / max_height);\n}\n\nvec2 sdf_terrain_map_detail(_in(vec3) pos)\n{\n\tfloat h0 = fbm_terr_normals(pos * 2.0987, 2.0244, .454, .454);\n\tfloat n0 = smoothstep(.35, 1., h0);\n\n\tfloat h1 = fbm_terr_r_normals(pos * 1.50987 + vec3(1.9489, 2.435, .5483), 2.0244, .454, .454);\n\tfloat n1 = smoothstep(.6, 1., h1);\n\n\tfloat n = n0 + n1;\n\n\treturn vec2(length(pos) - planet.radius - n * max_height, n / max_height);\n}\n\nvec3 sdf_terrain_normal(_in(vec3) p)\n{\n#define F(t) sdf_terrain_map_detail(t).x\n\tvec3 dt = vec3(0.001, 0, 0);\n\n\treturn normalize(vec3(\n\t\tF(p + dt.xzz) - F(p - dt.xzz),\n\t\tF(p + dt.zxz) - F(p - dt.zxz),\n\t\tF(p + dt.zzx) - F(p - dt.zzx)\n\t));\n#undef F\n}\n\n// ----------------------------------------------------------------------------\n// Lighting\n// ----------------------------------------------------------------------------\nvec3 setup_lights(\n\t_in(vec3) L,\n\t_in(vec3) normal\n){\n\tvec3 diffuse = vec3(0, 0, 0);\n\n\t// key light\n\tvec3 c_L = vec3(7, 5, 3);\n\tdiffuse += max(0., dot(L, normal)) * c_L;\n\n\t// fill light 1 - faked hemisphere\n\tfloat hemi = clamp(.25 + .5 * normal.y, .0, 1.);\n\tdiffuse += hemi * vec3(.4, .6, .8) * .2;\n\n\t// fill light 2 - ambient (reversed key)\n\tfloat amb = clamp(.12 + .8 * max(0., dot(-L, normal)), 0., 1.);\n\tdiffuse += amb * vec3(.4, .5, .6);\n\n\treturn diffuse;\n}\n\nvec3 illuminate(\n\t_in(vec3) pos,\n\t_in(vec3) eye,\n\t_in(mat3) local_xform,\n\t_in(vec2) df\n){\n\t// current terrain height at position\n\tfloat h = df.y;\n\t//return vec3 (h);\n\n\tvec3 w_normal = normalize(pos);\n#define LIGHT\n#ifdef LIGHT\n\tvec3 normal = sdf_terrain_normal(pos);\n\tfloat N = dot(normal, w_normal);\n#else\n\tfloat N = w_normal.y;\n#endif\n\n\t// materials\n\t#define c_water vec3(.015, .110, .455)\n\t#define c_grass vec3(.086, .132, .018)\n\t#define c_beach vec3(.153, .172, .121)\n\t#define c_rock  vec3(.080, .050, .030)\n\t#define c_snow  vec3(.600, .600, .600)\n\n\t// limits\n\t#define l_water .05\n\t#define l_shore .17\n\t#define l_grass .211\n\t#define l_rock .351\n\n\tfloat s = smoothstep(.4, 1., h);\n\tvec3 rock = mix(\n\t\tc_rock, c_snow,\n\t\tsmoothstep(1. - .3*s, 1. - .2*s, N));\n\n\tvec3 grass = mix(\n\t\tc_grass, rock,\n\t\tsmoothstep(l_grass, l_rock, h));\n\t\t\n\tvec3 shoreline = mix(\n\t\tc_beach, grass,\n\t\tsmoothstep(l_shore, l_grass, h));\n\n\tvec3 water = mix(\n\t\tc_water / 2., c_water,\n\t\tsmoothstep(0., l_water, h));\n\n#ifdef LIGHT\n\tvec3 L = mul(local_xform, normalize(vec3(1, 1, 0)));\n\tshoreline *= setup_lights(L, normal);\n\tvec3 ocean = setup_lights(L, w_normal) * water;\n#else\n\tvec3 ocean = water;\n#endif\n\t\n\treturn mix(\n\t\tocean, shoreline,\n\t\tsmoothstep(l_water, l_shore, h));\n}\n\n// ----------------------------------------------------------------------------\n// Rendering\n// ----------------------------------------------------------------------------\nvec3 render(\n\t_in(ray_t) eye,\n\t_in(vec3) point_cam\n){\n\tmat3 rot_y = rotate_around_y(27.);\n\tmat3 rot = mul(rotate_around_x(u_time * -12.), rot_y);\n\tmat3 rot_cloud = mul(rotate_around_x(u_time * 8.), rot_y);\n\n\tsphere_t atmosphere = planet;\n\tatmosphere.radius += max_height;\n\n\thit_t hit = no_hit;\n\tintersect_sphere(eye, atmosphere, hit);\n\tif (hit.material_id < 0) {\n\t\treturn background(eye);\n\t}\n\n\tfloat t = 0.;\n\tvec2 df = vec2(1, max_height);\n\tvec3 pos;\n\tfloat max_cld_ray_dist = max_ray_dist;\n\t\n\tfor (int i = 0; i < TERR_STEPS; i++) {\n\t\tif (t > max_ray_dist) break;\n\t\t\n\t\tvec3 o = hit.origin + t * eye.direction;\n\t\tpos = mul(rot, o - planet.origin);\n\n\t\tdf = sdf_terrain_map(pos);\n\n\t\tif (df.x < TERR_EPS) {\n\t\t\tmax_cld_ray_dist = t;\n\t\t\tbreak;\n\t\t}\n\n\t\tt += df.x * .4567;\n\t}\n\n#ifdef CLOUDS\n\tcloud = begin_volume(hit.origin, vol_coeff_absorb);\n\tclouds_march(eye, cloud, max_cld_ray_dist, rot_cloud);\n#endif\n\t\n\tif (df.x < TERR_EPS) {\n\t\tvec3 c_terr = illuminate(pos, eye.direction, rot, df);\n\t\tvec3 c_cld = cloud.C;\n\t\tfloat alpha = cloud.alpha;\n\t\tfloat shadow = 1.;\n\n#ifdef CLOUDS // clouds ground shadows\n\t\tpos = mul(transpose(rot), pos);\n\t\tcloud = begin_volume(pos, vol_coeff_absorb);\n\t\tvec3 local_up = normalize(pos);\n\t\tclouds_shadow_march(local_up, cloud, rot_cloud);\n\t\tshadow = mix(.7, 1., step(cloud.alpha, 0.33));\n#endif\n\n\t\treturn mix(c_terr * shadow, c_cld, alpha);\n\t} else {\n\t\treturn mix(background(eye), cloud.C, cloud.alpha);\n\t}\n}\n\n#define FOV tan(radians(30.))\n// ----------------------------------------------------------------------------\n// Main Rendering function\n// depends on external defines: FOV\n// ----------------------------------------------------------------------------\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n)\n{\n\t// assuming screen width is larger than height \n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\n\tvec3 color = vec3(0, 0, 0);\n\n\tvec3 eye, look_at;\n\tsetup_camera(eye, look_at);\n\n\tsetup_scene();\n\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\t\tpoint_ndc.y = 1. - point_ndc.y;\n#endif\n\tvec3 point_cam = vec3(\n\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * FOV,\n\t\t-1.0);\n\n\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\tcolor += render(ray, point_cam);\n\n\tfragColor = vec4(linear_to_srgb(color), 1);\n}\n", "user": "9197b10", "parent": null, "id": "32694.0"}