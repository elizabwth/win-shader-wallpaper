{"code": "// Insane recursion with multiple effects by Optimus\n// Guest code by AkumaX (rand function)\n\n// Version Zoomer\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n \nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float recursion_level = 8.0;\n\nfloat rand(vec2 vector)\n{\n    return fract( 43758.5453 * sin( dot(vector, vec2(12.9898, 78.233) ) ) );\n}\n\nfloat get_bump_height(vec2 position)\n{\n\treturn sin((sin(position.x * 32.0) + sin(position.y * 24.0) + sin(position.x * 4.0 + sin(position.y * 8.0 + time))) * 4.0) * 0.5 + 0.5;\n}\n\nfloat get_light(vec2 position)\n{\n\tvec2 tex = mod(position * 4.0, 1.0) - vec2(0.5);\n\treturn 0.0005 / pow(length(tex), 4.0);\n}\n\nvoid main(void)\n{\n\tfloat scale = cos(time / 85.0021) * 8.0 + 8.005;\n\tif (scale < 0.025) scale = 0.025;\n\n\tvec2 position = vec2((gl_FragCoord.x / resolution.x) - 0.5, (gl_FragCoord.y / resolution.y) - 0.5) * scale + time * 1.0;\n\n//\tvec2 rotated_position;\n//\trotated_position.x = ((position.x - 0.5) * cos(sin(0.25 * time) * 2.5) - (position.y - 0.5) * sin(sin(0.25 * time) * 2.5)) * scale;\n//\trotated_position.y = ((position.y - 0.5) * cos(sin(0.25 * time) * 2.5) + (position.x - 0.5) * sin(sin(0.25 * time) * 2.5)) * scale;\n//\tposition = rotated_position;\n\n\tvec2 coord = mod(position,1.0);\t// coordinate of single effect window (0.0 - 1.0)\n\tvec2 effect = floor(mod(position,4.0)); // effect number (0-3,0-3)\n\tfloat effect_number = effect.y * 4.0 + effect.x;\n\tvec2 effect_group = floor(position) * 7.0; // effect group float id\n \n\tfloat gradient = 0.0;\n\tvec3 color = vec3(0.0);\n \n\tfloat angle = 0.0;\n\tfloat radius = 0.0;\n\tconst float pi = 3.141592;\n\tfloat fade = 0.0;\n \n\tfloat u,v;\n\tfloat z;\n \n\tvec2 centered_coord = coord - vec2(0.5);\n\n\tfloat dist_from_center = length(centered_coord);\n\tfloat angle_from_center = atan(centered_coord.y, centered_coord.x);\n\n\tfloat iii = 0.0;\n\tfor (float ii=0.0; ii<=recursion_level; ii++)\n\t{\n\t\tif (effect_number==15.0)\n\t\t{\n\t\t\tposition *= 4.0;\n\n\t\t\tcoord = mod(position,1.0);\n\t\t\teffect = floor(mod(position,4.0));\n\t\t\teffect_number = effect.y * 4.0 + effect.x;\n\t\t\teffect_group = floor(position) * 7.0;\n\n\t\t\tcentered_coord = coord - vec2(0.5);\n\t\t\tdist_from_center = length(centered_coord);\n\t\t\tangle_from_center = atan(centered_coord.y, centered_coord.x);\n\n\t\t\tcolor = vec3(0.5);\t\n\t\t} \n\t\telse if (effect_number==0.0)\n\t\t{\n\t\t\t// gradient = mod(sin(coord.x*400.0) * sin(coord.y * 400.0) * 16.0 * time, 1.0);\n\t\t\tgradient = (rand( vec2(sin(coord*400.0))*time));\n\t\t\tcolor = vec3(gradient);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==1.0)\n\t\t{\n\t\t\tcolor.r = sin(coord.x * 32.0) + sin(coord.y * 24.0) + sin(coord.x * 4.0 + sin(coord.y * 8.0 + time));\n\t\t\tcolor.g = sin(coord.x * 16.0) + sin(coord.y * 12.0) + sin(coord.x * 8.0 + sin(coord.y * 16.0 + 2.0 * time));\n\t\t\tcolor.b = sin(coord.x * 8.0) + sin(coord.y * 48.0) + sin(coord.x * 2.0 + sin(coord.y * 4.0 + 3.0 * time));\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==2.0)\n\t\t{\n\t\t\tradius = dist_from_center + sin(time * 8.0) * 0.1 + 0.1;\n\t\t\tangle = angle_from_center + time;\n\t \n\t\t\tgradient = 0.5 / radius + sin(angle * 5.0) * 0.3;\n\t\t\tcolor = vec3(gradient, gradient / 2.0, gradient / 3.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==3.0)\n\t\t{\n\t\t\tradius = dist_from_center;\n\t\t\tangle = angle_from_center + time;\n\t \n\t\t\tgradient = sin(mod(angle + sin(-radius + time) * 2.0,2.0*pi) * 4.0) + 1.0;\n\t\t\tcolor = vec3(gradient/3.0, gradient / 2.0, gradient);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==4.0)\n\t\t{\n\t\t\tfloat dist_from_center_y = length(centered_coord.y);\n\t\t\tu = 8.0/dist_from_center_y + 16.0*time;\n\t\t\tv = (16.0/dist_from_center_y)* centered_coord.x + sin(time) * 8.0;\n\t \n\t\t\tfade = dist_from_center_y * 2.0;\n\t\t\tgradient = ((1.0 - pow(sin(u) + 1.0, 0.1)) + (1.0 - pow(sin(v) + 1.0, 0.1))) * fade;\n\t\t\tcolor = vec3(gradient / 2.0, gradient, gradient / 2.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==5.0)\n\t\t{\n\t\t\tu = 8.0 / dist_from_center + 16.0 * time;\n\t\t\tv = angle_from_center * 16.0;\n\t \n\t\t\tfade = dist_from_center * 2.0;\n\t\t\tgradient = ((1.0 - pow(sin(u) + 1.0, 0.1)) + (1.0 - pow(sin(v) + 1.0, 0.1))) * fade;\n\t\t\tcolor = vec3(gradient * 4.0, gradient, gradient / 2.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==6.0)\n\t\t{\n\t\t\tfor (float i=0.0; i<=32.0; i++)\n\t\t\t{\n\t\t\t\tvec2 blob_coord = vec2(sin(2.0*i + 2.0*time) * 0.4, cos(3.0*i + 3.0 * time) * 0.4);\n\t\t\t\tgradient += ((0.0001 + sin(i*i + 4.0*time) * 0.000095)) / pow(length(centered_coord - blob_coord), 2.75);\n\t\t\t}\n\t\t\tcolor = vec3(gradient, gradient * 2.0, gradient / 2.0);\n\t\t}\n\t\telse if (effect_number==7.0)\n\t\t{\n\t\t\tgradient = 1.0;\n\t\t\tfor (float i=0.0; i<=16.0; i++)\n\t\t\t{\n\t\t\t\tvec2 blob_coord = vec2(sin(32.0*i + 0.5*time) * 0.5, cos(256.0*i + 1.0 * time) * 0.5);\n\t\t\t\tgradient = min(gradient, length(centered_coord - blob_coord));\n\t\t\t}\n\t\t\tgradient = pow(sin(gradient), 2.0) * 16.0;\n\t\t\tcolor = vec3(gradient / 1.5, gradient / 2.0, gradient * 1.5);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==8.0)\n\t\t{\n\t\t\tfloat disp = 0.005;\n\t\t\tfloat p00 = get_bump_height(centered_coord);\n\t\t\tfloat p10 = get_bump_height(centered_coord + vec2(disp, 0.0));\n\t\t\tfloat p01 = get_bump_height(centered_coord + vec2(0.0, disp));\n\t \n\t\t\tfloat dx = p10 - p00;\n\t\t\tfloat dy = p01 - p00;\n\t \n\t\t\tvec2 light_coord = vec2(sin(time) * 0.3, sin(2.0*time) * 0.3);\n\t\t\tvec2 disp_coord = centered_coord - vec2(dx, dy);\n\t\t\tgradient = 0.1 / length(disp_coord - light_coord);\n\t\t\tcolor = vec3(gradient, gradient, gradient * 1.25);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==9.0)\n\t\t{\n\t\t\tvec2 rotated_coord;\n\t\t\tfloat zoom = sin(time) + 1.25;\n\t\t\trotated_coord.x = zoom * (centered_coord.x * cos(time) - centered_coord.y * sin(time));\n\t\t\trotated_coord.y = zoom * (centered_coord.y * cos(time) + centered_coord.x * sin(time));\n\t\n\t\t\tvec2 pix = floor(rotated_coord * 8.0);\n\t\n\t\t\tgradient = mod(mod(pix.x,2.0) + mod(pix.y,2.0),2.0);\n\t\t\tcolor = vec3(gradient);\n\t\n\t\t\tfloat raster1 = 0.01 / length(centered_coord.y - sin(1.5 * time) * 0.5);\n\t\t\tfloat raster2 = 0.01 / length(centered_coord.y - sin(1.5 * time + 0.3) * 0.5);\n\t\t\tfloat raster3 = 0.01 / length(centered_coord.y - sin(1.5 * time + 0.6) * 0.5);\n\t\t\tvec3 rcolor;\n\t\t\tif (raster1 > 0.25 || raster2 > 0.25 || raster3 > 0.25)\n\t\t\t{\n\t\t\t\trcolor = vec3(raster1, 0.0, 0.0);\n\t\t\t\trcolor += vec3(0.0, raster2, 0.0);\n\t\t\t\trcolor += vec3(0.0, 0.0, raster3);\n\t\t\t\tcolor = rcolor;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==10.0)\n\t\t{\n\t\t\tfor (float i=1.0; i<=128.0; i++)\n\t\t\t{\n\t\t\t\tvec2 star_pos = vec2(sin(i) * 64.0, sin(i*i*i) * 64.0);\n\t\t\t\tfloat z = mod(i*i - 128.0*time, 256.0);\n\t\t\t\tfloat fade = (256.0 - z) / 256.0;\n\t\t\t\tvec2 blob_coord = star_pos / z;\n\t\t\t\tgradient += ((fade / 384.0) / pow(length(centered_coord - blob_coord), 1.5)) * (fade * fade);\n\t\t\t}\n\t\n\t\t\tcolor = vec3(gradient * 2.0, gradient, gradient / 2.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==11.0)\n\t\t{\n\t\t\tfloat z = sqrt(0.25 - centered_coord.x * centered_coord.x - centered_coord.y * centered_coord.y);\n\t\t\tvec2 tex = (centered_coord * 32.0) / z;\n\t \n\t\t\tfade = pow(z,2.0);\n\t\t\tvec2 discolamp = vec2(pow(sin(tex.x + sin(0.5 * time) * 64.0) + 1.0, 2.0), pow(sin(tex.y + sin(0.4 * time) * 128.0) + 1.0, 2.0));\n\t\t\tgradient = (4.0 - discolamp.x - discolamp.y) * fade;\n\t\t\tcolor = vec3(gradient * 4.0, gradient, gradient / 2.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==12.0)\n\t\t{\n\t\t\tconst float steps = 64.0;\n\t\t\tfloat sum = 0.0;\n\t\t\tfor (float i=0.0; i<=steps; i++)\n\t\t\t{\n\t\t\t\tvec2 light_coord = centered_coord + vec2(sin(time), sin(time * 1.24));\n\t\t\t\tvec2 displacement = vec2(mix(centered_coord, 0.25 * light_coord, (steps - i) / steps));\n\t\t\t\tsum = mix(get_light(centered_coord + displacement), sum, 0.9);\n\t\t\t}\n\t\t\tgradient = sum;\n\tif (gradient <= 0.1) gradient = length(centered_coord) * 0.25;\n\t\t\tcolor = vec3(gradient * 4.0, gradient, gradient / 2.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==13.0)\n\t\t{\n\t\t\tfloat xpos = -0.5 + sin(centered_coord.y * 16.0 + time) * 0.06;\n\t\t\tfloat ypos = 0.0 + sin(centered_coord.x * 24.0 + 1.5 * time) * 0.04;\n\t\t\tconst float z_fractal = 0.4;\n\t\n\t\t\tconst float iter = 64.0;\n\t\t\tconst float iter2 = iter / 4.0;\n\t\t\n\t\t\tfloat z0_r = 0.0;\n\t\t\tfloat z0_i = 0.0;\n\t\t\tfloat z1_r = 0.0;\n\t\t\tfloat z1_i = 0.0;\n\t\t\tfloat p_r = (centered_coord.x + xpos * z_fractal) / z_fractal;\n\t\t\tfloat p_i = (centered_coord.y + ypos * z_fractal) / z_fractal;\n\t\t\tfloat d = 0.0;\n\t\t\n\t\t\tfloat nn;\n\t\t\tfor (float n=0.0; n<=iter; n++)\n\t\t\t{\n\t\t\t\tz1_r = z0_r * z0_r - z0_i * z0_i + p_r;\n\t\t\t\tz1_i = 2.0 * z0_r * z0_i + p_i;\n\t\t\t\td = sqrt(z1_i * z1_i + z1_r * z1_r);\n\t\t\t\tz0_r = z1_r;\n\t\t\t\tz0_i = z1_i;\n\t\t\t\tif (d > iter2) break;\n\t\t\t\tnn = n;\n\t\t\t}\n\t\t\n\t\t\tgradient = (nn / iter) * 4.0;\n\t\t\n\t\t\tcolor = vec3(gradient * 2.0, gradient, gradient * 16.0);\n\t\t\tbreak;\n\t\t}\n\t\telse if (effect_number==14.0)\n\t\t{\n\t\t\tfloat zom = 3.5;\n\t\t\tfloat x0 = centered_coord.x * zom;\n\t\t\tfloat y0 = centered_coord.y * zom;\n\t\n\t\t\tfloat x1, y1, mj2;\n\t\t\tconst float iter = 32.0;\n\t\n\t\t\tfloat posx = sin(time * 2.0) * 0.75;\n\t\t\tfloat posy = sin(time * 1.5) * 0.75;\n\t\n\t\t\tfloat nn;\n\t\t\tfor (float n=0.0; n<=iter; n++)\n\t\t\t{\n\t\t\t\tx1 = x0*x0 - y0*y0 + posx;\n\t\t\t\ty1 = 2.0*x0*y0 + posy;\n\t\t\t\tmj2 = x1*x1 + y1*y1;\n\t\t\t\tx0 = x1; y0 = y1;\n\t\t\t\tnn = n;\n\t\t\t\tif (mj2 > iter) break;\n\t\t\t}\n\t\n\t\t\tgradient = (nn / iter) * 2.0;\n\t\n\t\t\tcolor = vec3(1.0 - gradient, 1.0 - gradient * 2.0, gradient * 2.0);\n\t\t}\n\t\tiii = ii;\n\t}\n \n\tcolor.r *= (sin(effect_group.x * (iii+1.0)) * 0.5 + 0.5);\n\tcolor.g *= (sin(effect_group.x + effect_group.y * (iii*iii*iii)) * 0.5 + 0.5);\n\tcolor.b *= (sin(effect_group.x * effect_group.y* (iii*iii+1.5)) * 0.5 + 0.5);\n \n\tgl_FragColor = vec4(color, 1.0 );\n}\n", "user": "aed8c43", "parent": "/e#4252.2", "id": "4254.0"}