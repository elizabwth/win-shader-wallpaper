{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/XllGDj\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n// \"Tetrominos\" by Kali\n\n//#define retro\n//#define scroll\n#define speed 2.\n#define acceleration .017\n#define halfPI 1.57079632679\n\n\nmat2 rot2D(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// -------------------------------------------------------------------------------------\n// Returns the shape and heightmap of the blocks\n// The blocks are made of one, two or three combined rectangles\n// The distance function gives the hmap for the borders.\nvec3 blockhmap(vec2 p, vec4 pos, vec4 c, float type, float rot) {\n\tp=(p-pos.xy)*rot2D(rot*halfPI)+pos.xy; // apply rotation\n\tvec4 rpos=vec4(p,p)-pos;  // relative coordinates\n\tfloat b=0.;\n\tvec2 d1 = abs(rpos.xy-c.xy) - abs(c.xy);\n\tfloat h1=max(0.0,-min(max(d1.x,d1.y),0.0)); // hmap of rectangle1\n\tfloat i1=1.-sign(length(max(vec2(0.),d1+.05))); // inside shape of rectangle1\n\tfloat s1=1.-sign(length(max(vec2(0.),d1+.01))); // shape of rectangle1\n\tvec2 d2 = abs(rpos.zw-c.zw) - abs(c.zw);\n\tfloat h2=max(0.0,-min(max(d2.x,d2.y),0.0)); // hmap of rectangle2\n\tfloat i2=1.-sign(length(max(vec2(0.),d2+.05))); // inside shape of rectangle2\n\tfloat s2=1.-sign(length(max(vec2(0.),d2+.01))); // shape of rectangle2\n\tfloat cent=1.;\n\tif (type>1.5) { // we need another rectangle for the \"Z\" shaped pieces\n\t\tfloat yy=type>2.5?0.:.2;\n\t\tvec2 d3=abs(rpos.xy-vec2(.3,yy))-vec2(.1,.2);\t\n\t\tfloat h3=max(0.0,-min(max(d3.x,d3.y),0.0)); // hmap of rectangle3\n\t\tfloat i3=1.-sign(length(max(vec2(0.),d3+.05))); // inside shape of rectangle3\n\t\tfloat s3=1.-sign(length(max(vec2(0.),d3+.01))); // shape of rectangle3\n\t\th1=max(h1,h3); i1=max(i1,i3); s1=max(s1,s3); // combine rectangle3 with rectangle1\n\t}\n\t// for the square, we need to apply the hole\n\trpos-=.2; // move to the center of square\n\tif (type>.5 && type<1.5 && max(abs(rpos.x),abs(rpos.y))<.07) { //if we are inside the hole\n\t\tcent=-1.; // inverse the hmap\n\t\tif (max(abs(rpos.x),abs(rpos.y))<.03) s1=s2=0.; //flat black square hole\n\t}\n\t//return heightmap, inside shape, mask shape\n\treturn vec3(max(h1,h2)/.1*cent,max(i1,i2)-max(0.,-cent),max(s1,s2));\n}\n\n// -------------------------------------------------------------------------------------\n//the block shading function, it actually compute normals and applies lighting to the borders!\nvec3 draw(vec2 p, vec4 pos, vec4 c, vec3 color, float type, float rot) {\n\tvec2 d=vec2(.0,.0001); \n\tvec3 pi=blockhmap(p+d.yx,pos,c,type,rot); // save one of the calls used to calc normal\n\t\t\t\t\t\t\t\t\t\t\t\t// for using it later\n\tvec3 n=normalize(cross( //get normal\n\t  vec3(d.y,0.,pi-blockhmap(p-d.yx,pos,c,type,rot).x),\n\t  vec3(0.,d.y,blockhmap(p+d.xy,pos,c,type,rot).x-blockhmap(p-d.xy,pos,c,type,rot).x)));\n\n\t//lighting\n\tfloat l=max(0.,dot(n,normalize(vec3(0.5,1.,0.))))*1.6; \n\tl+=max(0.,dot(n,normalize(vec3(-1.,-0.5,0.))))*.4;\n\tvec3 bisel=l*pi.z*(1.-pi.y)*color; //the borders minus the center part of the shape\n\n\t//returns the center shape flat shaded, and the borders with lighting and desaturated\n\treturn color*pi.y+mix(vec3(length(bisel)),bisel,.65)*1.5; \n}\n\n// -------------------------------------------------------------------------------------\n// block design \nvec3 block(vec2 p, vec2 pos, float wich, float rot) {\n\tvec4 pp=vec4(0.); vec4 c=vec4(0.); float type=1.; vec3 color=vec3(0.);\n\n\t// pp.xy: position of rectangle1 - pp.wz: position of rectangle2\n\t// cc.xy: sizes of rectangle1    - cc.wz: sizes of rectangle2\n\t// type: 1=square - 2/3='Z'shapes - 0=all the rest\n\t// color: is the color!\n\n\tfloat f = step( abs(wich-1.0), 0.1 ); // \"O\"\n\tpp=mix(pp,vec4(-.2,-.2,.0,.0),f); c=mix(c,vec4(.2,.2,.0,.0),f); \n\tcolor=mix(color,vec3(0.,70.,200.)/256.,f); type=mix(type,1.,f); \n\tf = step( abs(wich-2.0), 0.1 ); // \"|\"\n\tpp=mix(pp,vec4(.0,.0,.0,.0),f); c=mix(c,vec4(.4,.1,.0,.0),f); \n\tcolor=mix(color,vec3(1.,0.,0.),f); type=mix(type,0.,f); \n\tf = step( abs(wich-3.0), 0.1 ); // \"T\"\n\tpp=mix(pp,vec4(.0,.2,.2,.2),f); c=mix(c,vec4(.3,.1,.1,.2),f); \n\tcolor=mix(color,vec3(50.,200.,0.)/256.,f); type=mix(type,0.,f); \n\tf = step( abs(wich-4.0), 0.1 ); // \"J\"\n\tpp=mix(pp,vec4(.0,.0,.4,.0),f); c=mix(c,vec4(.3,.1,.1,.2),f); \n\tcolor=mix(color,vec3(220.,0.,180.)/256.,f); type=mix(type,0.,f); \n\tf = step( abs(wich-5.0), 0.1 ); // \"L\"\n\tpp=mix(pp,vec4(.0,.0,.0,.0),f); c=mix(c,vec4(.3,.1,.1,.2),f); \n\tcolor=mix(color,vec3(220.,200.,0.)/256.,f);\ttype=mix(type,0.,f); \n\tf = step( abs(wich-6.0), 0.1 ); // \"Z\"\n\tpp=mix(pp,vec4(.0,.0,.2,.2),f); c=mix(c,vec4(.2,.1,.2,.1),f); \n\tcolor=mix(color,vec3(0.,180.,150.)/256.,f); type=mix(type,2.,f); \n\tf = step( abs(wich-7.0), 0.1 ); // \"S\"\n\tpp=mix(pp,vec4(.0,.2,.2,.0),f); c=mix(c,vec4(.2,.1,.2,.1),f); \n\tcolor=mix(color,vec3(250.,150.,0.)/256.,f); type=mix(type,3.,f);\n\n\treturn draw(p, vec4(pos,pos)+pp, c, color ,type, rot); // return the color\n}\n\n// -------------------------------------------------------------------------------------\n// This returns the data for each block (45 total)\n// xy=coordinates - z=wich shape - w=rotation\n// So it returns the place/shape/rotation for all the pieces to fill the screen\n// Looks difficult and tedious but it was actually fun to solve the puzzle :)\nvec4 getblock(float i) {\n\tvec4 pie=vec4(0.);\n\tpie=vec4(0.2,0.2, 1.,0.)*max(0.,1.-i);\t\t\n\tpie+=vec4(0.4,0.0, 2.,0.)*max(0.,1.-abs(1.-i));\t\t\n\tpie+=vec4(0.4,0.0, 3.,0.)*max(0.,1.-abs(2.-i));\t\t\n\tpie+=vec4(1.2,0.0, 4.,0.)*max(0.,1.-abs(3.-i));\t\t\n\tpie+=vec4(2.2,0.2, 1.,0.)*max(0.,1.-abs(4.-i));\t\t\n\tpie+=vec4(2.0,0.0, 2.,1.)*max(0.,1.-abs(5.-i));\t\t\n\tpie+=vec4(1.2,0.2, 6.,0.)*max(0.,1.-abs(6.-i));\t\t\n\tpie+=vec4(2.4,0.0, 2.,0.)*max(0.,1.-abs(7.-i));\t\t\n\tpie+=vec4(1.2,0.0, 7.,1.)*max(0.,1.-abs(8.-i));\t\t\n\tpie+=vec4(0.0,0.4, 5.,0.)*max(0.,1.-abs(9.-i));\t\t\n\tpie+=vec4(3.4,0.2, 1.,0.)*max(0.,1.-abs(10.-i));\t\t\n\tpie+=vec4(2.4,0.0, 3.,0.)*max(0.,1.-abs(11.-i));\t\t\n\tpie+=vec4(3.6,0.6, 4.,2.)*max(0.,1.-abs(12.-i));\t\t\n\tpie+=vec4(2.0,0.4, 5.,0.)*max(0.,1.-abs(13.-i));\t\t\n\tpie+=vec4(1.6,0.8, 1.,0.)*max(0.,1.-abs(14.-i));\t\t\n\tpie+=vec4(2.2,1.2, 4.,3.)*max(0.,1.-abs(15.-i));\t\t\n\tpie+=vec4(2.6,1.0, 6.,3.)*max(0.,1.-abs(16.-i));\t\t\n\tpie+=vec4(2.6,1.2, 7.,3.)*max(0.,1.-abs(17.-i));\t\t\n\tpie+=vec4(3.4,1.4, 2.,3.)*max(0.,1.-abs(18.-i));\t\t\n\tpie+=vec4(3.2,0.8, 1.,0.)*max(0.,1.-abs(19.-i));\t\t\n\tpie+=vec4(1.0,1.0, 3.,3.)*max(0.,1.-abs(20.-i));\t\t\n\tpie+=vec4(0.2,0.6, 4.,0.)*max(0.,1.-abs(21.-i));\t\t\n\tpie+=vec4(1.0,0.4, 2.,1.)*max(0.,1.-abs(22.-i));\t\t\n\tpie+=vec4(0.2,0.8, 6.,0.)*max(0.,1.-abs(23.-i));\t\t\n\tpie+=vec4(1.6,0.8, 7.,0.)*max(0.,1.-abs(24.-i));\t\t\n\tpie+=vec4(3.4,1.2, 4.,2.)*max(0.,1.-abs(25.-i));\t\t\n\tpie+=vec4(0.4,1.2, 2.,0.)*max(0.,1.-abs(26.-i));\t\t\n\tpie+=vec4(1.6,1.0, 5.,1.)*max(0.,1.-abs(27.-i));\t\t\n\tpie+=vec4(0.2,0.6, 7.,1.)*max(0.,1.-abs(28.-i));\t\t\n\tpie+=vec4(2.4,1.2, 3.,2.)*max(0.,1.-abs(29.-i));\t\t\n\tpie+=vec4(3.4,1.8, 1.,2.)*max(0.,1.-abs(30.-i));\t\t\n\tpie+=vec4(1.8,1.2, 4.,1.)*max(0.,1.-abs(31.-i));\t\t\n\tpie+=vec4(1.4,1.2, 6.,1.)*max(0.,1.-abs(32.-i));\t\t\n\tpie+=vec4(3.2,1.6, 3.,3.)*max(0.,1.-abs(33.-i));\t\t\n\tpie+=vec4(0.6,1.6, 4.,2.)*max(0.,1.-abs(34.-i));\t\t\n\tpie+=vec4(1.0,1.4, 7.,2.)*max(0.,1.-abs(35.-i));\t\t\n\tpie+=vec4(2.4,2.0, 1.,2.)*max(0.,1.-abs(36.-i));\t\t\n\tpie+=vec4(1.0,2.0, 5.,2.)*max(0.,1.-abs(37.-i));\t\t\n\tpie+=vec4(1.6,1.8, 3.,2.)*max(0.,1.-abs(38.-i));\t\t\n\tpie+=vec4(2.6,1.2, 6.,1.)*max(0.,1.-abs(39.-i));\t\t\n\tpie+=vec4(3.2,1.8, 4.,2.)*max(0.,1.-abs(40.-i));\t\t\n\tpie+=vec4(1.6,1.8, 2.,0.)*max(0.,1.-abs(41.-i));\t\t\n\tpie+=vec4(3.0,2.0, 4.,2.)*max(0.,1.-abs(42.-i));\t\t\n\tpie+=vec4(3.6,2.0, 5.,2.)*max(0.,1.-abs(43.-i));\t\t\n\tpie+=vec4(0.2,1.8, 1.,0.)*max(0.,1.-abs(44.-i));\t\t\nreturn pie;\n}\n\n\n// -------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col=vec3(0.);\n\n\tfloat spd=speed;\n//make retro mode slower\n#ifdef retro \n\tspd*=.3;\n#endif\n\t\n\tfloat ti=(iTime+5./spd)*spd*(1.+iTime*acceleration); //get time \n\tfloat t=abs(55.-mod(ti,110.)); // make forward/backward cycles\n\n#ifdef scroll\n\tuv.x=mod(uv.x-iTime*.3,1.); // horizontal scrolling\n#endif\n\n\tif (mod(ti,330.)>110.) uv.x=1.-uv.x; //invert X in two sequences\n\tif (mod(ti,330.)>220.) uv.y=1.-uv.y; //invert Y in one sequence\n\n\tuv.x*=iResolution.x/iResolution.y;\n\tuv*=vec2(2.026,2.); // scale to fit screen\n\t\n// pixelate and quantize movement for retro mode\t\n#ifdef retro \n\tt=floor(t*5.)/5.;\n\tuv=floor(uv*51.)/51.;\n#endif\n\n\tfor (int i=0; i<45; i++) { // loop through the pieces\n\t\t// get the data for the block and animate Y coord\n\t\tvec4 pie=getblock(float(i))+vec4(0.,max(0.,t-48.+float(i)),0.,0.); \n\t\tif (distance(uv,pie.xy)<.85) // optimization trick\n\t\t\tcol+=block(uv,pie.xy,pie.z,pie.w); //get color\n\t}\n\tfragColor = vec4(col,1.);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n\nvoid main(void)\n{\n  iTime = time;\n  iResolution = vec3(resolution, 0.0);\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "3dabbd5", "parent": null, "id": "45385.0"}