{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/ldlcRf\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nvec3  iResolution;\nfloat iTime;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n/*\n\tBefore you continue reading, feast your eyes on these beautiful Color Schemes (0,1,2)\n*/\n\n// Modify the number to 0,1,2 or 3 and press play button at bottom for different schemes.\n#define COLOR_SCHEME 3\n\n/*\n\tThis shader is just a tribute to \"Journey\" game by That Game Company. Some answers:\n\t1) No, I do not have any affiliation with That Game Company.\n\t2) Yes, Journey is one of the best games ever made\n\t3) It has taken me around 3-4 months from start to finish, evenings and weekends\n\t4) Most of the time was spent getting the details right\n\t5) Yes, the character needs more work. One day I will finish it\n\t6) Yes, if anybody comes up with something cool to add, I would love to improve :)\n\t7) There is nothing mathemagically amazing in this shader. I hope you do find it pretty though!\n\t8) Yes, the code is fairly ugly. But look at the colors - PRETTY!\n\t9) If you have any other questions, I will be happy to answer\n\n\tThis shader started as a learning playground, but around January, I finished my second round of Journey\n\tand thought, well why the hell not, and so here we are.\n\n\tSpecial thanks to Thibault Girard and Jack Hamilton for their artistic input. Also bigs up to Peter Pimley\n\tfor his constant optimism.\n\n\tYou are hereby granted your wish to follow me on twitter: @shakemayster\n\n\tOther authors (With BIG thanks !!!) \n\tDave_Hoskins\n\tDila\n\tMaurogik\n\tFabriceNeyret2\n*/\n\n#define RGB vec3\n#define mul(a,b) b*a\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\n\n#if COLOR_SCHEME == 0\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.22632, 0.88099, -0.4155) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.73741, 0.63971) ;\nconst RGB _Zenith = RGB(0.67128, 0.94118, 0.69204) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.80147, 0.80147, 0.80147) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.57353, 0.1488, 0.067474) ;\nconst RGB _CharacterTerrainCol = RGB(0.375, 0.21885, 0.15993) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.38971, 0.10735, 0.054444) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.35588, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 20.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.96957, 0.88235) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.47735, 0.59559, 0.49705) ;\nconst RGB _TombScarfColor = RGB(0.45588, 0.093858, 0.093858) ;\nconst RGB _PyramidCol = RGB(0.30147, 0.28329, 0.21059) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.05) ;\nconst RGB _TerrainCol = RGB(0.76863, 0.55294, 0.47059) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.40441, 0.34106, 0.31818) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.81471, 0.74265) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.80882, 0.11671, 0.017842) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.56187, 0.0073529) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 1\nconst float _FogMul = -0.00800 ;\nconst float _FogPow = 1.00000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.83000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(1, 0.95441, 0.77206) ;\nconst RGB _Zenith = RGB(0.77941, 0.5898, 0.41263) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(1, 0.93103, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.96324, 0.80163, 0.38954) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.35294, 0.16016, 0.12197) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.25735, 0.028557, 0.0056769) ;\nconst RGB _CharacterYellowColor = RGB(0.88971, 0.34975, 0) ;\nconst RGB _CharacterWhiteColor = RGB(0.9928, 1, 0.47794) ;\nconst float _CharacterBloomScale = 0.70000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 4.55000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(1, 0.84926, 0.69853) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.64706, 0.38039, 0.27451) ;\nconst RGB _TombScarfColor = RGB(0.38971, 0.10029, 0.10029) ;\nconst RGB _PyramidCol = RGB(0.69853, 0.40389, 0.22086) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.3) ;\nconst RGB _TerrainCol = RGB(0.56618, 0.29249, 0.1915) ;\nconst RGB _TerrainSpecColor = RGB(1, 0.77637, 0.53676) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0.16176, 0.13131, 0.098724) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 2.88000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.48529, 0.13282, 0) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.70588, 0.4644, 0.36851) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.85294, 0.11759, 0.012543) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(1, 0.3931, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 2.61000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 1.75000 ;\n#endif\n\n#if COLOR_SCHEME == 2\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.68000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.23047, 0.87328, -0.42927) ;\nconst float _Brightness = 0.40000 ;\nconst float _Contrast = 0.82000 ;\nconst float _Saturation = 1.21000 ;\nconst vec3 _SunStar = vec3(14.7, 1.47, 0.1) ;\nconst float _SunSize = 26.00000 ;\nconst float _SunScale = 15.00000 ;\nconst float _ExposureOffset = 11.10000 ;\nconst float _ExposurePower = 0.52000 ;\nconst float _ExposureStrength = 0.09000 ;\nconst RGB _SunColor = RGB(0.97059, 0.97059, 0.97059) ;\nconst RGB _Zenith = RGB(0.98039, 0.83137, 0.53725) ;\nconst float _ZenithFallOff = 2.36000 ;\nconst RGB _Nadir = RGB(0, 0, 0) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.84559, 0.77688, 0.6031) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.60294, 0.1515, 0.062067) ;\nconst RGB _CharacterTerrainCol = RGB(0.5, 0.3404, 0.12868) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.31618, 0.14042, 0.039522) ;\nconst RGB _CharacterYellowColor = RGB(0.64706, 0.30233, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 3.84000 ;\nconst float _CharacterFogScale = 12.47000 ;\nconst float _CloudTransparencyMul = 0.80000 ;\nconst RGB _CloudCol = RGB(0.99216, 0.9451, 0.76471) ;\nconst RGB _BackCloudCol = RGB(0.66176, 0.64807, 0.62284) ;\nconst RGB _CloudSpecCol = RGB(0.17647, 0.062284, 0.062284) ;\nconst RGB _BackCloudSpecCol = RGB(0.11029, 0.05193, 0.020275) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.94118, 0.82759, 0.45675) ;\nconst RGB _TombScarfColor = RGB(0.44118, 0.19989, 0.14922) ;\nconst RGB _PyramidCol = RGB(0.92647, 0.73579, 0.3338) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 4.65) ;\nconst RGB _TerrainCol = RGB(0.71324, 0.5076, 0.236) ;\nconst RGB _TerrainSpecColor = RGB(0.32353, 0.32123, 0.31877) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 0.03000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 3.20000 ;\nconst RGB _TerrainRimColor = RGB(0, 0, 0) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 1.61000 ;\nconst float _TerrainRimSpecPower = 0.38000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.28) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.66912, 0.52969, 0.369) ;\nconst RGB _TerrainDistanceShadowColor = RGB(1, 0.75466, 0.43382) ;\nconst float _TerrainDistanceShadowPower = 0.11000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.91912, 0.30412, 0.21626) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.98529, 0.60477, 0.12316) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 4.00000 ;\n#endif\n\n#if COLOR_SCHEME == 3\nconst float _FogMul = -0.00100 ;\nconst float _FogPow = 1.82000 ;\nconst float _IncorrectGammaCorrect = 1.00000 ;\nconst vec3 _LightDir = vec3(-0.29644, 0.6859, -0.66458) ;\nconst float _Brightness = 1.00000 ;\nconst float _Contrast = 1.00000 ;\nconst float _Saturation = 1.00000 ;\nconst vec3 _SunStar = vec3(20.45, 1.49, 0.5) ;\nconst float _SunSize = 26.09000 ;\nconst float _SunScale = 15.04000 ;\nconst float _ExposureOffset = 13.72000 ;\nconst float _ExposurePower = 0.60000 ;\nconst float _ExposureStrength = 0.02000 ;\nconst RGB _SunColor = RGB(0.51471, 0.79919, 1) ;\nconst RGB _Zenith = RGB(0, 0.053922, 0.16176) ;\nconst float _ZenithFallOff = 1.42000 ;\nconst RGB _Nadir = RGB(0.21569, 0.2549, 0.36078) ;\nconst float _NadirFallOff = 1.91000 ;\nconst RGB _Horizon = RGB(0.35191, 0.30223, 0.47794) ;\nconst vec3 _CharacterAOParams = vec3(0.03, 7.36, 0) ;\nconst RGB _CharacterMainColor = RGB(0.36765, 0.097656, 0.045956) ;\nconst RGB _CharacterTerrainCol = RGB(0.083261, 0.11379, 0.16176) ;\nconst RGB _CharacterCloakDarkColor = RGB(0.073529, 0.011604, 0) ;\nconst RGB _CharacterYellowColor = RGB(0.60294, 0.33162, 0) ;\nconst RGB _CharacterWhiteColor = RGB(1, 1, 1) ;\nconst float _CharacterBloomScale = 0.87000 ;\nconst float _CharacterDiffScale = 1.50000 ;\nconst float _CharacterFreScale = 1.77000 ;\nconst float _CharacterFrePower = 19.83000 ;\nconst float _CharacterFogScale = 60.00000 ;\nconst float _CloudTransparencyMul = 0.90000 ;\nconst RGB _CloudCol = RGB(0.0069204, 0.15969, 0.23529) ;\nconst RGB _BackCloudCol = RGB(0, 0.10969, 0.15441) ;\nconst RGB _CloudSpecCol = RGB(0.11765, 0.11765, 0.11765) ;\nconst RGB _BackCloudSpecCol = RGB(0.080882, 0.080882, 0.080882) ;\nconst float _CloudFogStrength = 0.50000 ;\nconst RGB _TombMainColor = RGB(0.23789, 0.27707, 0.40441) ;\nconst RGB _TombScarfColor = RGB(0.066176, 0, 0.034229) ;\nconst RGB _PyramidCol = RGB(0, 0, 0) ;\nconst vec2 _PyramidHeightFog = vec2(38.66, 1.92) ;\nconst RGB _TerrainCol = RGB(0, 0.058832, 0.10294) ;\nconst RGB _TerrainSpecColor = RGB(0.24622, 0.29188, 0.33824) ;\nconst float _TerrainSpecPower = 55.35000 ;\nconst float _TerrainSpecStrength = 1.56000 ;\nconst float _TerrainGlitterRep = 7.00000 ;\nconst float _TerrainGlitterPower = 1.94000 ;\nconst RGB _TerrainRimColor = RGB(0.091021, 0.057093, 0.16176) ;\nconst float _TerrainRimPower = 5.59000 ;\nconst float _TerrainRimStrength = 2.00000 ;\nconst float _TerrainRimSpecPower = 1.46000 ;\nconst float _TerrainFogPower = 2.11000 ;\nconst vec4 _TerrainShadowParams = vec4(0.12, 5.2, 88.7, 0.37) ;\nconst vec3 _TerrainAOParams = vec3(0.01, 0.02, 2) ;\nconst RGB _TerrainShadowColor = RGB(0.11029, 0.11029, 0.11029) ;\nconst RGB _TerrainDistanceShadowColor = RGB(0.0034061, 0.073181, 0.15441) ;\nconst float _TerrainDistanceShadowPower = 0.06000 ;\nconst RGB _FlyingHelperMainColor = RGB(0.12661, 0.004109, 0.13971) ;\nconst RGB _FlyingHelperCloakDarkColor = RGB(1, 0.090909, 0) ;\nconst RGB _FlyingHelperYellowColor = RGB(0.48529, 0.2711, 0) ;\nconst RGB _FlyingHelperWhiteColor = RGB(1, 1, 1) ;\nconst float _FlyingHelperBloomScale = 1.91000 ;\nconst float _FlyingHelperFrePower = 1.00000 ;\nconst float _FlyingHelperFreScale = 0.85000 ;\nconst float _FlyingHelperFogScale = 5.51000 ;\n#endif\n\n//==========================================================================================\n// Play with these at your own risk. Expect, unexpected results!\n//==========================================================================================\n\nconst mat4 _CameraInvViewMatrix = mat4( 1, 0, 0, 1.04, \n0, 0.9684963, 0.2490279, 2.2, \n0, 0.2490279, -0.9684963, 18.6, \n0, 0, 0, 1 ) ;\nconst vec3 _CameraFOV = vec3(1.038, 0.78984, -1) ;\nconst vec3 _CameraPos = vec3(1.0, 2.2, 18.6) ;\nconst vec4 _CameraMovement = vec4(0.15, 0.1, 0.2, 0.25) ;\n\nconst vec3 _WindDirection = vec3(-0.27, -0.12, 0) ;\n\nconst float _DrawDistance = 70.00000 ;\nconst float _MaxSteps = 64.00000 ;\n\nconst vec3 _SunPosition = vec3(0.2, 56, -40.1) ;\nconst float _CharacterRotation = 0.17000 ;\nconst vec3 _CharacterPosition = vec3(0.52, 2.35, 17.6) ;\nconst vec3 _CharacterScale = vec3(0.4, 0.53, 0.38) ;\nconst float _MainClothRotation = 0.30000 ;\nconst vec3 _MainClothScale = vec3(0.3, 0.68, 0.31) ;\nconst vec3 _MainClothPosition = vec3(0, -0.12, 0) ;\nconst vec3 _MainClothBotCutPos = vec3(0, -0.52, 0) ;\nconst vec3 _MainClothDetail = vec3(6, 0.04, 1.3) ;\nconst float _HeadScarfRotation = -0.19000 ;\nconst vec3 _HeadScarfPosition = vec3(-0.005, -0.16, -0.01) ;\nconst vec3 _HeadScarfScale = vec3(0.18, 0.2, 0.03) ;\nconst float _HeadRotationX = -0.30000 ;\nconst float _HeadRotationY = 0.29000 ;\nconst float _HeadRotationZ = 0.00000 ;\nconst vec3 _HeadPos = vec3(0, -0.04, 0.01) ;\nconst vec3 _LongScarfPos = vec3(0.01, -0.15, 0.09) ;\nconst vec3 _LongScarfScale = vec3(0.05, 1.25, 0.001) ;\nconst vec4 _LongScarfWindStrength = vec4(0.3, 4.52, 5.2, 0.02) ;\nconst float _LongScarfRotX = 1.43000 ;\nconst float _LongScarfMaxRad = 1.99000 ;\nconst vec3 _FacePosition = vec3(0, -0.01, 0.05) ;\nconst vec3 _FaceSize = vec3(0.038, 0.05, 0.03) ;\nconst vec3 _UpperLeftLegA = vec3(-0.02, -0.37, 0.01) ;\nconst vec3 _UpperLeftLegB = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _UpperLeftLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerLeftLegA = vec3(-0.02, -0.67, -0.059999) ;\nconst vec3 _LowerLeftLegB = vec3(-0.02, -0.77, 0.12) ;\nconst vec3 _LowerLeftLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _UpperRightLegA = vec3(0.07, -0.5, 0.02) ;\nconst vec3 _UpperRightLegB = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _UpperRightLegParams = vec3(0.026, 1, 1) ;\nconst vec3 _LowerRightLegA = vec3(0.07, -0.61, 0.09) ;\nconst vec3 _LowerRightLegB = vec3(0.07, -0.91, 0.22) ;\nconst vec3 _LowerRightLegParams = vec3(0.028, 0.03, 0.01) ;\nconst vec3 _BodyPos = vec3(0, -0.45, -0.03) ;\nconst vec3 _CharacterTrailOffset = vec3(0.72, 0.01, 0.06) ;\nconst vec3 _CharacterTrailScale = vec3(0.001, 0, 0.5) ;\nconst vec3 _CharacterTrailWave = vec3(1.97, 0, 0.34) ;\nconst vec2 _CharacterHeightTerrainMix = vec2(1.95, -30) ;\nconst vec3 _CloudNoiseStrength = vec3(0.2, 0.16, 0.1) ;\nconst vec3 _FrontCloudsPos = vec3(9.91, 8.6, -12.88) ;\nconst vec3 _FrontCloudsOffsetA = vec3(-9.1, 3.04, 0) ;\nconst vec3 _FrontCloudsOffsetB = vec3(-2.97, 3.72, -0.05) ;\nconst vec3 _FrontCloudParams = vec3(5.02, 3.79, 5) ;\nconst vec3 _FrontCloudParamsA = vec3(3.04, 0.16, 2) ;\nconst vec3 _FrontCloudParamsB = vec3(1.34, 0.3, 3.15) ;\nconst vec3 _BackCloudsPos = vec3(29.99, 13.61, -18.8) ;\nconst vec3 _BackCloudsOffsetA = vec3(24.87, -1.49, 0) ;\nconst vec3 _BackCloudParams = vec3(7.12, 4.26, 1.68) ;\nconst vec3 _BackCloudParamsA = vec3(6.37, 2.23, 2.07) ;\nconst vec3 _PlaneParams = vec3(7.64, 10.85, 3.76) ;\nconst vec3 _CloudGlobalParams = vec3(0.123, 2.1, 0.5) ;\nconst vec3 _CloudBackGlobalParams = vec3(0.16, 1.4, -0.01) ;\nconst vec3 _CloudNormalMod = vec3(0.26, -0.13, 1.22) ;\nconst float _CloudSpecPower = 24.04000 ;\nconst float _CloudPyramidDistance = 0.14500 ;\nconst vec3 _TombPosition = vec3(5, 5, 9.28) ;\nconst vec3 _TombScale = vec3(0.07, 0.5, 0.006) ;\nconst vec3 _TombBevelParams = vec3(0.44, 0.66, 0.01) ;\nconst float _TombRepScale = 0.79000 ;\nconst vec3 _TombCutOutScale = vec3(0.39, 0.06, -14.92) ;\nconst vec3 _TombScarfOffset = vec3(0, 0.46, 0) ;\nconst vec3 _TombScarfWindParams = vec3(-1.61, 6, 0.05) ;\nconst vec3 _TombScarfScale = vec3(0.03, 0.002, 0.5) ;\nconst float _TombScarfRot = -0.88000 ;\nconst mat4 _TombScarfMat = mat4( 0.9362437, 0, -0.3513514, 0, \n0, 1, 0, 0, \n0.3513514, 0, 0.9362437, 0, \n0, 0, 0, 1 ) ;\nconst vec3 _PyramidPos = vec3(0, 10.9, -50) ;\nconst vec3 _PyramidScale = vec3(34.1, 24.9, 18) ;\nconst vec3 _PrismScale = vec3(1, 1.9, 1) ;\nconst vec3 _PyramidNoisePrams = vec3(1.5, 1, 1) ;\nconst vec3 _PrismEyeScale = vec3(0.7, 1.9, 51.5) ;\nconst vec3 _PyramidEyeOffset = vec3(2.0, -4.9, 0) ;\nconst float _PrismEyeWidth = 5.86000 ;\nconst float _TerrainMaxDistance = 30.04000 ;\nconst float _SmallDetailStrength = 0.00600 ;\nconst vec3 _SmallWaveDetail = vec3(3.19, 16, 6.05) ;\nconst vec2 _WindSpeed = vec2(2, 0.6) ;\nconst float _MediumDetailStrength = 0.05000 ;\nconst vec2 _MediumWaveDetail = vec2(2, 50) ;\nconst vec3 _MediumWaveOffset = vec3(0.3, -2, 0.1) ;\nconst vec2 _LargeWaveDetail = vec2(0.25, 0.73) ;\nconst vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;\nconst vec3 _LargeWaveOffset = vec3(-3.65, 4.41, -11.64) ;\nconst vec3 _FlyingHelperPos = vec3(2.15, 4.68, 14.4) ;\nconst vec3 _FlyingHelperScale = vec3(0.25, 0.001, 0.3) ;\nconst vec3 _FlyingHelperMovement = vec3(0.44, 1.44, -2.98) ;\nconst vec3 _FlyingHelperScarfScale = vec3(0.1, 0.001, 1.5) ;\nconst vec3 _FlyingHelperScarfWindParams = vec3(-0.06, 0.31, 0.47) ;\nconst vec3 _FlyingHelperScarfWindDetailParams = vec3(3.93, 0.005, -45.32) ;\nconst vec3 _FlyingHelperSideScarfOffset = vec3(0.16, -0.01, 0) ;\nconst vec3 _FlyingHelperSideScarfScale = vec3(0.06, 0.001, 0.8) ;\nconst vec4 _FlyingScarfSideWindParams = vec4(2.46, -1.59, -0.05, 0.21) ;\n\n// Material ID definitions\n#define MAT_PYRAMID 1.0\n\n#define MAT_TERRAIN 10.0\n#define MAT_TERRAIN_TRAIL 11.0\n\n#define MAT_BACK_CLOUDS 20.0\n#define MAT_FRONT_CLOUDS 21.0\n\n#define MAT_TOMB 30.0\n#define MAT_TOMB_SCARF 31.0\n\n#define MAT_FLYING_HELPERS 40.0\n#define MAT_FLYING_HELPER_SCARF 41.0\n\n#define MAT_CHARACTER_BASE 50.0\n#define MAT_CHARACTER_MAIN_CLOAK 51.0\n#define MAT_CHARACTER_NECK_SCARF 52.0\n#define MAT_CHARACTER_LONG_SCARF 53.0\n#define MAT_CHARACTER_FACE 54.0\n\n#define TEST_MAT_LESS( a, b ) a < (b + 0.1)\n#define TEST_MAT_GREATER( a, b ) a > (b - 0.1)\n\n//==========================================================================================\n// Primitive functions by IQ\n//==========================================================================================\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length( max( abs(p) - b, 0.0) ) - r;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\n\t\tlength(max(d, 0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p, n.xyz) + n.w;\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n//==========================================================================================\n// distance field operations\n//==========================================================================================\nvec2 min_mat( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin_mat( vec2 a, vec2 b, float k, float c )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float x = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    return vec2( x, ( h < c ) ? b.y : a.y);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//==========================================================================================\n// Rotations\n//==========================================================================================\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.y;\n    p.y = -s * q.x + c * q.y;\n}\n\n//==========================================================================================\n// Value noise and its derivatives: https://www.shadertoy.com/view/MdX3Rr\n//==========================================================================================\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n//==========================================================================================\n// Noise function: https://www.shadertoy.com/view/4sfGRH \n//==========================================================================================\nfloat pn(vec3 p) {\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);   \n\treturn mix(a.x, a.y, f.z);\n}\n\n//==========================================================================================\n// Sin Wave approximation http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\n//==========================================================================================\nvec4  SmoothCurve( vec4 x ) {  \n  return x * x * ( 3.0 - 2.0 * x );  \n}\n\nvec4 TriangleWave( vec4 x ) {  \n  return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  \n}\n\nvec4 SmoothTriangleWave( vec4 x ) {  \n  return SmoothCurve( TriangleWave( x ) );  \n}  \n\nfloat SmoothTriangleWave( float x )\n{\n  return SmoothCurve( TriangleWave( vec4(x,x,x,x) ) ).x;  \n}  \n\nvoid Bend(inout vec3 vPos, vec2 vWind, float fBendScale)\n{\n\tfloat fLength = length(vPos);\n\tfloat fBF = vPos.y * fBendScale;  \n\tfBF += 1.0;  \n\tfBF *= fBF;  \n\tfBF = fBF * fBF - fBF;  \n\tvec3 vNewPos = vPos;  \n\tvNewPos.xz += vWind.xy * fBF;  \n\tvPos.xyz = normalize(vNewPos.xyz)* fLength;  \n}\n\n//==========================================================================================\n// Modified cone versions for scarf and main cloak\n//==========================================================================================\nfloat sdScarfCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    float si = 0.5*(r1-r2)/h;\n    p.z = mix(p.z, p.z * 0.2, q);\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec2 sdCloakCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = (p.y - h);\n    r2 = (q * r2) + 0.08;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return vec2(length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.), q);\n}\n\n//==========================================================================================\n// Character\n//==========================================================================================\nvec3 headScarfMatUVW;\nfloat sdHeadScarf(vec3 pos)\n{\n\t\n    vec3 headScarfPos = pos - _HeadScarfPosition;\n    rX( headScarfPos, _HeadScarfRotation );\n\n    float distanceToTop =  min(0.0,(pos.y + 0.01));\n\n    // Put a slight twist in the middle. Gives the feel that the head scarf\n    // is sitting on shoulders. Very subtle, but I can see it :D\n    float midBend = abs( fract( distanceToTop + 0.5 ) * 2.0 - 1.0 );\n    headScarfPos.x += (cos( 2.0 + headScarfPos.y * 50.0 ) * 0.05 * midBend);\n    headScarfPos.z += (sin( 2.0 + headScarfPos.y * 50.0 ) * 0.03 * midBend);\n\n    // Apply wind to head Scarf    \n    headScarfPos += SmoothTriangleWave(vec4(pos.xyz * 5.0+ iTime,1.0) ).xyz * 0.05 * distanceToTop;\n\n    // Scarf shape    \n    float headScarf = sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z );\n    headScarf = max(headScarf, -sdScarfCone(headScarfPos, _HeadScarfScale.x, _HeadScarfScale.y, _HeadScarfScale.z - 0.011));\n    \n    // Cut out the bottom of the head scarf. I have no idea what I was thinking, when I wrote this\n    vec3 cutOutPos = headScarfPos - vec3( 0.0, 0.08, 0.0);\n    vec3 r = vec3(0.12, 0.8, 0.2);\n    float smallestSize = min(min(r.x,r.y),r.z);\n\tvec3 dp = cutOutPos/r;\n    float h = min(1.0, abs(1.0 - abs(dp.y)) );\n\n    // Apply some crazy power until it looks like a scarf sitting on shoulders\n    h =  pow(h, 5.5);\n    \n    float rad = h ;\n    float d = length( cutOutPos/r );\n    \n    float cutOut = (d - rad) * smallestSize;\n    headScarf\t= max(headScarf, cutOut);\n\n    // material information\n    float materialVal = 1.0 - pow(d - rad, 0.02);\n\theadScarfMatUVW = smoothstep( -1.0, 1.0, materialVal / _HeadScarfScale);\n\n\t// Chop the top off, to make room for head\n    vec3 headPos = pos - vec3(0.0, 0.25, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.19, 0.2)); \n    headScarf = max(headScarf, -head);\n    \n    return headScarf;\n}\nvec3 mainCloakMatUVW;\nfloat sdMainCloak(vec3 pos)\n{\n    vec3 cloakPos = pos - _MainClothPosition;\n    float q =  min(0.0,(cloakPos.y + 0.05));\n    rX( cloakPos, _MainClothRotation );\n    \n    // Apply detailing\n    cloakPos += SmoothTriangleWave(vec4(pos.xyz * _MainClothDetail.x + iTime,1.0) ).xyz * _MainClothDetail.y * q;\n    \n    // Add main Wind direction\n    Bend(cloakPos, _WindDirection.xy, _MainClothDetail.z);\n    \n    vec2 cloak = sdCloakCone( cloakPos, _MainClothScale.y, _MainClothScale.x, _MainClothScale.z);\n    // Cut out the internals of the cloak\n    cloak.x = max( cloak.x, -sdCloakCone( cloakPos, _MainClothScale.y * 1.05, _MainClothScale.x * 0.95, _MainClothScale.z * 1.01).x);\n\n    // UV Information\n    mainCloakMatUVW = smoothstep( -1.0, 1.0, cloakPos / _MainClothScale);\n\n    // Cut out the top section\n    vec3 headPos = cloakPos - vec3(0.0, 0.69, 0.0);\n    float head   = sdBox(headPos, vec3(0.2, 0.67, 0.2)); \n\tcloak.x = max(cloak.x, -head);\n    \n    // Cut the bottom\n    float bottomCut   = sdPlane(cloakPos - _MainClothBotCutPos); \n    cloak.x = max(cloak.x, -bottomCut);\n    \n    return cloak.x;\n}\n\nfloat earWigs(in vec3 pos) \n{   \n\t// Symmetrical ear wigs. Is that even a word... Ear Wigs!\n    pos.x = abs(pos.x);\n\n    vec2  earWig = sdSegment( pos, vec3(0.02, 0.11, 0.0), vec3(0.07, 0.16, 0.05));\n    float ear  = earWig.x - 0.026  + (earWig.y * 0.03);\n    return ear;\n}\n\n\nfloat sdHead( vec3 pos )\n{\n    vec3 headPos = pos - _HeadPos;\n\n    // Slight tilt\n    rY(headPos, _HeadRotationY ); // 1.2\n    rX(headPos, _HeadRotationX );\n\n    float head = sdCylinder( headPos, vec2(0.05, 0.13) );\n    head = smin(earWigs(headPos), head, 0.04 );\n    return head;\n}\n\nvec3 longScarfMatUVW;\nfloat sdScarf(vec3 pos) \n{\n    vec3 scarfPos = pos - _LongScarfPos;\n    vec3 scale \t= _LongScarfScale;\n\n\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.04);\n    scarfPos.x += (sin( scarfPos.z * _LongScarfWindStrength.x + iTime ) * 0.1 * distanceToPoint);\n    scarfPos.y += (sin( scarfPos.z * _LongScarfWindStrength.y + iTime ) * 0.1 * distanceToPoint);\n\n    // Apply detailing\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _LongScarfWindStrength.z + iTime,1.0) ).xyz * _LongScarfWindStrength.w * distanceToPoint;\n\n    // Essentially a box pivoted at a specific point\n    vec3 scarfOffset = vec3(0.0, 0.0, -scale.y);\n\n    rX(scarfPos, _LongScarfRotX) ;\n    float scarf = sdBox(scarfPos - scarfOffset.xzy , scale);\n\n    longScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos - scarfOffset.xzy ) / scale);\n\n    return max(scarf, sdSphere( scarfPos, _LongScarfMaxRad ));\n}\n\nfloat sdLegs( in vec3 pos  )\n{\n    vec2  upperLeftLeg = sdSegment( pos, _UpperLeftLegA, _UpperLeftLegB );\n    float leftLeg  = upperLeftLeg.x - _UpperLeftLegParams.x;\n    vec2 lowerLeftLeg = sdSegment( pos, _LowerLeftLegA, _LowerLeftLegB );\n    leftLeg  = smin( leftLeg, lowerLeftLeg.x - _LowerLeftLegParams.x + (lowerLeftLeg.y * _LowerLeftLegParams.y), _LowerLeftLegParams.z);\n\n    // cut bottom of left leg otherwise looks nasty with harsh tip\n    leftLeg = max( leftLeg, -(length( pos - _LowerLeftLegB) - 0.06 ) );\n\n    vec2  upperRightLeg = sdSegment( pos, _UpperRightLegA, _UpperRightLegB );\n    float rightLeg  = upperRightLeg.x - _UpperRightLegParams.x;\n    vec2 lowerRightLeg = sdSegment( pos, _LowerRightLegA, _LowerRightLegB );\n    rightLeg  = smin( rightLeg, lowerRightLeg.x - _LowerRightLegParams.x + (lowerRightLeg.y * _LowerRightLegParams.y), _LowerRightLegParams.z);\n\n    return min( leftLeg, rightLeg );\n}\n\nvec2 sdFace( vec3 pos, vec2 currentDistance )\n{\n    vec3 headPos = pos - vec3(0.0, -0.05, 0.0);\n    rX( headPos, _HeadRotationX );\n    rY(headPos, _HeadRotationY );\n\n    // head hole - Fire in the hole!    \n    // OK this does not look right. Actually looks like there was \"fire in the hole\" for \n    // the poor travellers face. Need to come back to it one day and finish it. Maybe!\n    vec3 headHole = headPos - vec3(0.0, 0.1, -0.07);\n    float hole = sdEllipsoid( headHole,vec3(0.05, 0.03, 0.04) );\n    hole  = smin ( hole, sdEllipsoid( headHole - vec3(0.0, -0.03, 0.0), vec3(0.03,0.03, 0.04)), 0.05 );\n\n    // Cut it OUT!\n    float character =  smax( currentDistance.x, -hole, 0.001);\n\n    // face. Meh just an ellipsoid. Need to add eyes and bandana\n    float face = sdEllipsoid( headHole - _FacePosition.xyz, _FaceSize );\n    return smin_mat( vec2(face, MAT_CHARACTER_FACE), vec2(character,currentDistance.y), 0.01, 0.2 );\n}\n\nvec2 sdCharacter( vec3 pos )\n{\n    // Now we are in character space - Booo YA! - I never ever say Boooo YA!. Peter Pimley \n    // says that. Peter: have you been putting comments in my code?\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    vec2  mainCloakMat = vec2(mainCloak, MAT_CHARACTER_MAIN_CLOAK );\n\n    float headScarf = sdHeadScarf(pos);\n    vec2  headScarfMat = vec2(headScarf, MAT_CHARACTER_NECK_SCARF );\n\n    float longScarf = sdScarf(pos);\n    vec2  longScarfMat = vec2( longScarf, MAT_CHARACTER_LONG_SCARF );\n    headScarfMat = smin_mat( headScarfMat, longScarfMat, 0.02, 0.1 );\n\n    float head      = sdHead( pos );\n    vec2  headMat\t= vec2( head, MAT_CHARACTER_BASE );\n    headScarfMat    = smin_mat(headScarfMat, headMat, 0.05, 0.75);\n\n    vec2  characterMat = min_mat(mainCloakMat, headScarfMat); \n    characterMat = sdFace( pos, characterMat );\n\n    vec2 legsMat = vec2( sdLegs(pos), MAT_CHARACTER_BASE );\n    characterMat = min_mat( characterMat, legsMat );\n\n    // chope the bottom. This is to chop the bottom of right leg. Though\n    // I have positioned the character so that the right leg is hidden by terrain. \n    // Commenting it out for now\n//    characterMat.x = max( characterMat.x, -sdPlane( pos - vec3(0.0, -0.85, 0.0) ) );\n    characterMat.x *= scaleMul;\n\n\n    return characterMat;\n}\n\n//==========================================================================================\n// Clouds\n//==========================================================================================\nfloat sdCloud( in vec3 pos, vec3 cloudPos, float rad, float spread, float phaseOffset, vec3 globalParams)\n{ \n\t// Clouds are simple. A bunch of spheres with varying phase offset, size and \n\t// frequency values. They are also scaled along the z-Axis so more like circles\n\t// than spheres. With additional noise to make them look fluffy. \n\t// While rendering them we \"perturb\" #SpellCheck the normals to get strong specular\n\t// highlights\n\n\t// Add noise to the clouds\n\tpos += pn( pos ) * _CloudNoiseStrength;\n\tpos = pos - cloudPos;\n\n\t// Make us 2d-ish - My artists have confirmed me: 2D is COOL!\n\tpos.z /= globalParams.x;\n\n\t// Repeat the space\n\tfloat repitition = rad * 2.0 + spread;\n\tvec3  repSpace = pos - mod( pos - repitition * 0.5, repitition);\n\n\t// Create the overall shape to create clouds on\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.23  )  * globalParams.y ;\n\n\t// Creates clouds with offset on the main path\n\tpos.y +=  sin(phaseOffset + repSpace.x * 0.9 ) * globalParams.z;\n\n\t// repeated spheres\n\tpos.x = fract( (pos.x + repitition * 0.5) / repitition ) * repitition - repitition * 0.5;\n\n\t// return the spheres  \n\tfloat sphere = length(pos)- rad;\n\treturn sphere * globalParams.x;\n}\n\nvec2 sdClouds( in vec3 pos )\n{\n\t// Two layers of clouds. A layer in front of the big pyramid\n    float c1 = sdCloud( pos, _FrontCloudsPos, _FrontCloudParams.x, _FrontCloudParams.y, _FrontCloudParams.z, _CloudGlobalParams );\n    float c2 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetA, _FrontCloudParamsA.x, _FrontCloudParamsA.y, _FrontCloudParamsA.z, _CloudGlobalParams );\n    float c3 = sdCloud( pos, _FrontCloudsPos + _FrontCloudsOffsetB, _FrontCloudParamsB.x, _FrontCloudParamsB.y, _FrontCloudParamsB.z, _CloudGlobalParams);\n    float frontClouds = min(c3, min(c1, c2));\n\n    // This plane hides the empty spaces between the front cloud spheres. Not needed\n    // for back spheres, they are covered by front spheres\n  \tfloat mainPlane = length(pos.z - _FrontCloudsPos.z) / _CloudGlobalParams.x + (pos.y - _PlaneParams.y  + sin(_PlaneParams.x + pos.x * 0.23 ) * _PlaneParams.z);// - rad;\n  \tfrontClouds = min(mainPlane * _CloudGlobalParams.x, frontClouds);\n\n\t// Second layer behind the big Pyramid\n    float c4 = sdCloud( pos, _BackCloudsPos, _BackCloudParams.x, _BackCloudParams.y, _BackCloudParams.z, _CloudBackGlobalParams );\n    float c5 = sdCloud( pos, _BackCloudsPos + _BackCloudsOffsetA, _BackCloudParamsA.x, _BackCloudParamsA.y, _BackCloudParamsA.z, _CloudBackGlobalParams );\n    float backClouds = min(c4,c5);\n    return min_mat(vec2(frontClouds,MAT_FRONT_CLOUDS), vec2(backClouds,MAT_BACK_CLOUDS));\n}\n\n//==========================================================================================\n// This should really be called Kites. No such thing as Flying Helplers...\n//==========================================================================================\nvec3 helperScarfMatUVW;\nfloat sdHelperScarf(vec3 pos, vec3 scarfOffset, vec3 originalPos ) \n{\n    vec3 scarfPos = pos - scarfOffset;\n\n    vec3 scale = _FlyingHelperScarfScale;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = length(scarfPos );\n\n    // Apply some motion\n    scarfPos += SmoothTriangleWave(vec4(pos.xyz * _FlyingHelperScarfWindDetailParams.x + iTime,1.0) ).xyz * _FlyingHelperScarfWindDetailParams.y * distanceToPoint;\n\n    vec2 wave;\n    wave.x = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.x  );\n    wave.y = SmoothTriangleWave( scarfPos.z * _FlyingHelperScarfWindParams.z  );\n\n    scarfPos.xy += ( wave * _FlyingHelperScarfWindParams.y * distanceToPoint);\n    vec3  pivotOffset = vec3(0.0, 0.0, scale.z);\n    float scarf = sdBox(scarfPos - pivotOffset, scale);\n\n    // Move us along the z-axis because we chop a sphere in the box. Shows borders otherwise\n    vec3 UVWOffset = vec3(0.0, 0.0, 1.0);\n    helperScarfMatUVW = smoothstep(-1.0, 1.0, ( scarfPos + UVWOffset - pivotOffset.xzy ) / scale);\n\n    // Two scarf on each side of the big'un\n    pivotOffset.z = _FlyingHelperSideScarfScale.z;\n\n\twave.y = originalPos.x > 0.0 ? wave.y * _FlyingScarfSideWindParams.x : wave.y * _FlyingScarfSideWindParams.y;\n\tscarfPos.xy += scarfPos.x > 0.0 ? wave * _FlyingScarfSideWindParams.z : wave * _FlyingScarfSideWindParams.w;\n\n\t// legit mirroring!\n\tscarfPos.x = -abs(scarfPos.x);\n\tfloat sideScarfs = sdBox(scarfPos - pivotOffset + _FlyingHelperSideScarfOffset, _FlyingHelperSideScarfScale);\n\n\t// Just override the helperScarfMatUVW value for side scarfs. Too tired to create another variable and use that, not too tired\n\t// to write this long comment of no value\n    helperScarfMatUVW = scarf < sideScarfs ? helperScarfMatUVW : smoothstep(-1.0, 1.0, ( scarfPos - pivotOffset + _FlyingHelperSideScarfOffset ) / _FlyingHelperSideScarfScale);\n\n    // Combine'em\n    scarf = min( scarf, sideScarfs );\n    return scarf;\n}\n\nvec2 sdFlyingHelpers( vec3 pos )\n{\n\tvec3 originalPos = pos;\n\tfloat flyingHelper = _DrawDistance;\n\n\t// Using pos.x to determine, whether we are rendering left or right scarf.\n\tvec3 helperPos = _FlyingHelperPos;\n\thelperPos = pos.x > 0.0 ? helperPos - _FlyingHelperMovement : helperPos;\n\n\t// Rest is just mirroring\n\tpos.x = abs(pos.x);\n\tpos = pos - helperPos;\n\n\tfloat helperScarf = sdHelperScarf( pos, vec3(0.0, 0.0, 0.0), originalPos);\n\n\t// Main helper is a box with a cutout sphere at back. In-game it is more sophisticated. But\n\t// I am running out of time. Maybe will do a proper one, one day!\n\tfloat helper = sdBox( pos, _FlyingHelperScale );\n\thelper\t= max( helper, -sdSphere( pos - vec3(0.0, 0.0, _FlyingHelperScale.z ), _FlyingHelperScale.z) );\n\n\t// Material and combine scarf with main body\n\tvec2 helperMat = smin_mat( vec2(helper,MAT_FLYING_HELPERS), vec2(helperScarf,MAT_FLYING_HELPER_SCARF), 0.01, 0.1);\n\thelperScarfMatUVW = helper < helperScarf ? smoothstep(-1.0, 1.0, (pos + vec3(0.0,0.0,_FlyingHelperScale.z*0.5)) / _FlyingHelperScale) : helperScarfMatUVW;\n\n\treturn helperMat;\n}\n\n//==========================================================================================\n// The big mountain in the distance. Again, not a pyramid\n//==========================================================================================\nfloat sdBigMountain( in vec3 pos )\n{\n    float scaleMul = min(_PyramidScale.x, min(_PyramidScale.y, _PyramidScale.z));\n    vec3 posPyramid\t= pos - _PyramidPos;\n\n    // Apply noise derivative, then we can use a blocky looking texture to make the mountain\n    // look edgy (for lack of better word)\n    float derNoise\t\t= sin(noised(posPyramid.xz * _PyramidNoisePrams.x).x) * _PyramidNoisePrams.y;\n    posPyramid.x\t\t= posPyramid.x + derNoise;\n\n    posPyramid /= _PyramidScale;\n    float pyramid = sdTriPrism(  posPyramid, _PrismScale.xy ) * scaleMul;\n\n    // The piercing eye. Which is just an inverted pyrmaid on top of main pyramid.\n    float eyeScale = _PyramidScale.x;\n\n    vec3 posEye = pos;\n    posEye.y = _PrismEyeScale.z - pos.y;\n    posEye.x = pos.x * _PrismEyeWidth;\n\n\tfloat eye = sdTriPrism(  (posEye -_PyramidEyeOffset) / eyeScale, _PrismEyeScale.xy ) * eyeScale;\n\treturn max(pyramid, -eye);\n}\n\n//==========================================================================================\n// Main desert shape\n//==========================================================================================\nfloat sdLargeWaves( in vec3 pos )\n{\n\t// The main shape of terrain. Just sin waves, along X and Z axis, with a power\n\t// curve to make the shape more pointy \n\n    // Manipulate the height as we go in the distance\n    // We want terrain to be a specific way closer to character, showing a path, but the path \n    // gets muddier as wo go in the distance.\n\n    float distZ = abs(pos.z - _CameraPos.z);\n    float distX = abs(pos.x - _CameraPos.x);\n    float dist = (distZ ) + (distX * 0.1);\n    dist = dist * dist * 0.01;\n\n    float detailNoise = noised(pos.xz).x * -2.5; \n\tfloat largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02)  \n\t\t\t\t\t  * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x) ) * 0.5) + 0.5;\n    largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y - detailNoise * 0.1 ;// - (-pos.z*_LargeWavePowStre.z);// \n\n    // Smoothly merge with the bottom plane of terrain\n    largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);\n    largeWaves = (largeWaves - dist);\n    return largeWaves * 0.9;\n}\n\nfloat sdSmallWaves( in vec3 pos )\n{\n\t// The small waves are used for adding detail to the main shape of terrain\n\tfloat distanceToCharacter = length( pos.xz - _CharacterPosition.xz );\n\n    // movement to give feel of wind blowing\n    float detailNoise = noised(pos.xz).x * _SmallWaveDetail.z; \n\tfloat smallWaves = sin(pos.z * _SmallWaveDetail.y + detailNoise + iTime * _WindSpeed.y ) * \n\t\t\t\t\t   sin(pos.x * _SmallWaveDetail.x + detailNoise + iTime * _WindSpeed.x ) * _SmallDetailStrength;// * min(1.0, distanceToCharacter);\n\t\n\treturn smallWaves * 0.9;\n}\n\nfloat sdTerrain( in vec3 pos)\n{\n\tfloat smallWaves = sdSmallWaves( pos );\n\tfloat largeWaves = sdLargeWaves( pos );\n\n    return (smallWaves + largeWaves);\n}\n\nvec2 sdDesert( in vec3 pos, in float terrain )\n{\n    float distanceToPos = length(pos.xz - _CameraPos.xz);\n    if( distanceToPos > _TerrainMaxDistance)\n        return vec2(_DrawDistance, 0.0);\t\n\n   \tfloat mat = 9.0;//length(pos.xyz) > 9.0 ? 10.0 : 40.0;\n    return vec2( pos.y + terrain, MAT_TERRAIN );\n}\n\n//==========================================================================================\n// Character trail in the sand\n//==========================================================================================\nfloat sdCharacterTrail( vec3 pos, in float terrain )\n{\n\tvec3 trailOffset = (_CharacterPosition);\n\ttrailOffset.yz  += (_CharacterTrailOffset).yz;\n    trailOffset.y = -terrain + _CharacterTrailOffset.y; \n\n    vec3 trailPos = pos - trailOffset;\n    float distanceToPoint = length(trailPos);\n    trailPos.x -= _CharacterTrailOffset.x * distanceToPoint;\n\n    // Make it wavy\n    trailPos.x += (SmoothTriangleWave( trailPos.z * _CharacterTrailWave.x  ) * _CharacterTrailWave.z * distanceToPoint);\n\n    float trail = sdBox(trailPos - vec3(0.0, 0.0, _CharacterTrailScale.z) , _CharacterTrailScale);\n    return trail;\n}\n\n//==========================================================================================\n// The tombs\n//==========================================================================================\nfloat sdTombScarf(vec3 pos, vec3 scarfOffset, float t ) \n{ \n\t//  scarfs, done same as other scarfs\n\n    vec3 scarfPos = pos - scarfOffset;\n\n    scarfPos =  (mul(  _TombScarfMat, vec4(scarfPos,1.0) )).xyz;\n\n    vec3 scale = _TombScarfScale;\n    scale.z  += (t + 1.0 ) * 0.2;\n\n    // How far are we from pivot of scarf\n    float distanceToPoint = max(0.0,length(scarfPos) - 0.1);\n\n    // Make the scarf thicker as it goes out\n    scale.x += distanceToPoint * 0.04;\n\n    // Apply some motion\n    scarfPos.x += (sin( pos.z * _TombScarfWindParams.x + iTime) * _TombScarfWindParams.z * distanceToPoint);\n    scarfPos.y += (sin( pos.z * _TombScarfWindParams.y + iTime) * _TombScarfWindParams.z * distanceToPoint);\n\n     vec3 pivotOffset = vec3(0.0, 0.0, scale.z);\n    rX(scarfPos, _TombScarfRot + ((t - 0.5)* 0.15) + SmoothTriangleWave((iTime + 1.45) * 0.1) * 0.3 );\n\n    float scarf = sdBox(scarfPos - pivotOffset , scale);\n    return scarf;\n}\n\nvec2 sdTombs( in vec3 p )\n{\n\tvec2 mainTomb = vec2(_DrawDistance, MAT_TOMB);\n\n\t// We draw two tombs, t goes -1 -> 1 so we can use negative and positive values\n\t// to mainpulate them both individually\n\tfor( float t = -1.0; t <= 1.0; t += 2.0 )\n\t{\n\t\tvec3 tombPos = (_TombPosition + vec3(-0.25 * t, t * 0.05, 0.1 * t ));\n\n\t\tvec3 pos = p - tombPos;\n\t\trZ( pos, 0.1 * t );\n\n\t\tfloat tombScarf = sdTombScarf( pos, _TombScarfOffset, t + 1.0);\n\n\t\tpos.x = abs(pos.x);\n\n\t\t// Taper them beyond a certain height. Rest is just a rounded box\n\t\tpos.x += abs( pos.y > _TombBevelParams.x  ? (pos.y - _TombBevelParams.x) * _TombBevelParams.y: 0.0 );\n\t\tfloat tTomb = sdRoundBox( pos, _TombScale, _TombBevelParams.z);\n\n\t\t// Cut out a sphere at top\n\t\ttTomb = max( tTomb, -sdSphere( pos - vec3(0.0, _TombCutOutScale.x, 0.0), _TombCutOutScale.y ) );\n\n\t\t// create scarfs at cut off points\n\t\tvec2 tTombMat = min_mat( vec2(tTomb, MAT_TOMB), vec2(tombScarf, MAT_TOMB_SCARF));\n\t\tmainTomb = min_mat( mainTomb, tTombMat);\n\t}\n\treturn mainTomb;\n}\n\n//==========================================================================================\n// The main map function\n//==========================================================================================\nvec2 map( in vec3 pos )\n{\n\tvec2 character = sdCharacter(pos);\n\tvec2 res = character;\n\n\t// I am assuming that since character covers a large portion of screen\n\t// This early out should help and same with the terrain. Assumption only, \n\t// need to look into it \n    if( res.x > 0.01 )\n    {\n    \tfloat desert = sdTerrain(pos);\n\t    vec2 terrain   = sdDesert( pos, desert );\n\t    vec2 trail\t   = vec2(-sdCharacterTrail(pos, desert), MAT_TERRAIN_TRAIL );\n\t    terrain.y\t\t= terrain.x > trail.x ? terrain.y : trail.y;\n\t\tterrain.x\t\t= smax( terrain.x, trail.x, 0.05);\n\n\t\tres\t= min_mat( res, terrain); \n        if( terrain.x > 0.01 )\n        {\n\t\t\tvec2 tombs\t   =  sdTombs(pos);\n            res = smin_mat( res, tombs, 0.2, 0.15 );\n\n            vec2 pyramid   = vec2(sdBigMountain(pos), MAT_PYRAMID);\n            res = min_mat( res, pyramid );\n\n            vec2 clouds\t   = sdClouds(pos);\n            res = min_mat( res, clouds );\n\n            vec2 flyingHelpers = sdFlyingHelpers( pos );\n            res = min_mat( res, flyingHelpers );\n        }\n\t}\n    return res;\n}\n\n\n//==========================================================================================\n// Used for generating normals. As it turns out that only the big mountain doesn't need\n// normals. Everything else does. Hey Ho!\n//==========================================================================================\nvec2 mapSimple( in vec3 pos )\n{\n\treturn map( pos );\n\t/*\n    vec2 character = sdCharacter(pos);\n    vec2 flyingHelpers = vec2( sdFlyingHelpers( pos ), 50.0 );\n    vec2 clouds\t   = sdClouds(pos);\n   \tfloat desert   = sdTerrain(pos);\n    vec2 terrain   = sdDesert( pos, desert );\n    terrain.x = smax( terrain.x, -sdCharacterTrail(pos, desert), 0.1 );\n    vec2 tombs\t   =  vec2(sdTombs(pos), 50.0);\n\n    vec2 res = character;\n    min_mat( res, flyingHelpers );\n\tres = min_mat( res, clouds );\n    res\t= min_mat( res, terrain); \n    res\t= min_mat( res, flyingHelpers); \n    res = smin_mat( res, tombs, 0.2, 0.15 );\n    return res;\n    */\n}\n\n//==========================================================================================\n// Raycasting: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 castRay(vec3 ro, vec3 rd) \n{\n    float tmin = 0.1;\n    float tmax = _DrawDistance;\n   \n    float t = tmin;\n    float m = -1.0;\n    float p = 0.0;\n    float maxSteps = _MaxSteps;\n    float j = 0.0;\n    for( float i = 0.0; i < _MaxSteps; i += 1.0 )\n    {\n        j = i;\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) \n        \tbreak;\n        t += res.x;\n\t    m = res.y;\n    }\n\tp = j / maxSteps;\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, p );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*mapSimple( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapSimple( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapSimple( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapSimple( pos + e.xxx ).x );\n}\n\n//==========================================================================================\n// Ambient Occlusion, only applied to the Traveller\n//==========================================================================================\nfloat AmbientOcclusion(vec3 p, vec3 N, float stepSize, float k)\n{\n    float r = 0.0;\n    float t = 0.0;\n  \n    for(int i = 0; i < 2; i++)\n    {\n        t += stepSize;\n        r += (1.0 / pow(2.0, t)) * (t - sdCharacter(p + (N * t)).x);\n    }\n    return max(0.0, 1.0 - (k * r));\n}\n\n//==========================================================================================\n// Simplified version of Traveller for shadow casting\n//==========================================================================================\nfloat sdCharacterShadow( vec3 pos )\n{\n    pos -= _CharacterPosition;\n    vec3 scale = _CharacterScale;\n    float scaleMul = min(scale.x, min(scale.y, scale.z));\n    \n    rY(pos, _CharacterRotation);\n\n    pos /= scale;\n\n    float mainCloak = sdMainCloak( pos );\n    float longScarf = sdScarf(pos);\n\n    return min( mainCloak, longScarf) * scaleMul;\n}\n\n//==========================================================================================\n// Only character, flying helpers and tombs cast shadows. Only terrain recieves shadows\n//==========================================================================================\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 100; ++i)\n    {\n        if (t >= maxt) {\n            break;\n        }\n    \tfloat flyingHelpers = sdFlyingHelpers( ro + rd * t).x;\n    \tfloat tombs = sdTombs( ro + rd * t ).x;\n        float h = min( sdCharacterShadow( ro + rd*t), min(flyingHelpers, tombs) );\n        if( h<0.001 )\n            return 0.1;\n        res = min( res, k*h/t );\n        t += h;\n    }\n\treturn res;\n}\n\n//==========================================================================================\n// Hi Hussain!\n// Again, somebody wrote Hi Hussain here. It wasn't me, but hi back atcha!\n// Sky\n//==========================================================================================\nvec3 sky( vec3 ro, vec3 rd )\n{\n    // Sun calculation\n    float sunDistance = length( _SunPosition );\n\n    vec3 delta = _SunPosition.xyz - (ro + rd * sunDistance);\n    float dist \t= length(delta);\n\n    // Turn Sun into a star, because the big mountain has a star like shape\n    // coming from top\n    delta.xy *= _SunStar.xy;\n    float sunDist = length(delta);\n    float spot = 1.0 - smoothstep(0.0, _SunSize, sunDist);\n    vec3 sun = clamp(_SunScale * spot * spot * spot, 0.0, 1.0) * _SunColor.rgb;\n\t\n\t// Changing color on bases of distance from Sun. To get a strong halo around\n\t// the sun\n   \tfloat expDist = clamp((dist - _ExposureOffset)  * _ExposureStrength, 0.0, 1.0);\n   \tfloat expControl = pow(expDist,_ExposurePower);\n\n    // Sky colors\n    float y = rd.y;\n    float zen = 1.0 - pow (min (1.0, 1.0 - y), _ZenithFallOff);\n    vec3 zenithColor\t= _Zenith.rgb  * zen;\n    zenithColor = mix( _SunColor.rgb, zenithColor, expControl );\n\n    float nad = 1.0 - pow (min (1.0, 1.0 + y), _NadirFallOff);\n    vec3 nadirColor\t= _Nadir.rgb * nad;\n\n    float hor = 1.0 - zen - nad;\n    vec3 horizonColor\t= _Horizon.rgb * hor;\n\n    // Add stars for Color Scheme 3\nfloat stars  = 0.0;\n#if COLOR_SCHEME == 3\n    vec3 starPos = ro + ( (rd + vec3(iTime * 0.001, 0.0, 0.0) ) * sunDistance);\n    starPos.xyz += iTime*0.01 + noised(starPos.xy) * 3.0;\n\n    starPos      = mod( starPos, 1.5) - 0.75;\n    stars  \t\t = length(starPos);\n\n\tfloat starsA \t= (step( 0.9, 1.0 - stars) * 1.0 - (stars)) * 2.0;\n\tfloat starsB\t= (step( 0.93, 1.0 - stars) * 1.0 - (stars)) * 1.5;\n\tstars = starsA + starsB;\n\n    stars = stars * pow(zen * expControl, 5.0);\n    stars = step( 0.01, stars) * stars * 2.0;\n#endif\n    return stars + (sun * _SunStar.z + zenithColor + horizonColor + nadirColor);\n}\n\n//==========================================================================================\n// The rendering, based on: https://www.shadertoy.com/view/Xds3zN\n//==========================================================================================\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\t// res.z contains the iteration count / max iterations. This gives kind of a nice glow\n\t// effect around foreground objects. Looks particularly nice on sky, with clouds in\n\t// front and also on terrain. Gives rim kind of look!\n\tvec3 res\t= castRay(ro,rd);\n\tvec3 skyCol = sky( ro, rd );\n\tvec3 col\t= skyCol;\n\n\t#if defined (DEBUG_PERFORMANCE)\n\treturn (res.z);\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t*rd;\n\n\t// Return sky\n\tif( m < 0.0 )\n\t{\n\t\t// Bloom for the background clouds. We want Big Mountain to be engulfed with fog. So just chop out\n\t\t// areas around right and left side of BigMountain for creating fake bloom for background clouds by\n\t\t// using the iteration count needed to generate the distance function\n\t\tfloat rightSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(45.0, -5.0, _SunPosition.z));\n\t\tfloat leftSideCloudDist = length( (ro + rd * length(_SunPosition)) - vec3(-50.0, -5.0, _SunPosition.z));\n\t\tif( rightSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, rightSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n\t\telse if( leftSideCloudDist < 40.0 )\n\t\t{\n\t\t\tfloat smoothCloudBloom = 1.0 - smoothstep( 0.8, 1.0, leftSideCloudDist / 40.0);\n\t\t\treturn col + res.z * res.z * 0.2 * smoothCloudBloom;\n\t\t}\n        else\n\t\t\treturn col;\n\t}\n\n\tfloat skyFog = 1.0-exp( _FogMul * t * pow(pos.y, _FogPow) );\n\t#if defined (DEBUG_FOG)\n\treturn (skyFog);\n\t#endif\n\n\t// Render the big mountain. Keep track of it's color, so we can use it for transparency for clouds later\n\tvec3 pyramidCol = vec3(0.0, 0.0, 0.0);\n\tpyramidCol\t\t= mix( _PyramidCol, skyCol, skyFog * 0.5  ); \n\n\tif( TEST_MAT_LESS( m, MAT_PYRAMID) )\n\t{\n\t\t// Height fog, with strong fade to sky \n\t\tfloat nh = (pos.y / _PyramidHeightFog.x);\n\t\tnh = nh*nh*nh*nh*nh;\n\t\tfloat heightFog = pow(clamp(1.0 - (nh), 0.0, 1.0), _PyramidHeightFog.y);\n\t\theightFog\t\t= clamp( heightFog, 0.0, 1.0 );\n\t\tpyramidCol\t\t= mix( pyramidCol, skyCol, heightFog ); \n\t\treturn pyramidCol;       \n\t}\n\n\t// Calculate normal after calculating sky and big mountain\n\tvec3 nor = calcNormal(pos);\n\t// Terrain: https://archive.org/details/GDC2013Edwards\n\tif( TEST_MAT_LESS (m, MAT_TERRAIN_TRAIL ) )\n\t{\n\t\tfloat shadow = softShadow( pos - (rd * 0.01), _LightDir.xyz, _TerrainShadowParams.x, _TerrainShadowParams.y, _TerrainShadowParams.z);\n\t\tshadow\t\t = clamp( shadow + _TerrainShadowParams.w, 0.0, 1.0 );\n\n\t\tvec3 shadowCol = mix( shadow * _TerrainShadowColor, _TerrainDistanceShadowColor, pow(skyFog, _TerrainFogPower * _TerrainDistanceShadowPower) );\n\n\t\t// Strong rim lighting\n\t\tfloat rim\t= (1.0 - saturate(dot( nor , -rd ))); \n\t\trim\t\t\t= saturate(pow( rim, _TerrainRimPower)) *_TerrainRimStrength ; \n\t\tvec3 rimColor\t= rim * _TerrainRimColor;\n\n\t\t// Specular highlights\n\t\tvec3 ref\t\t= reflect(rd, nor);\n\t    vec3 halfDir\t= normalize(_LightDir + rd);\n\n\t    // The strong ocean specular highlight\n\t    float mainSpec = clamp( dot( ref, halfDir ), 0.0, 1.0 );\n\t    if ( TEST_MAT_LESS( m, MAT_TERRAIN ) )\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 2.0 ;\n\t    else\n\t        mainSpec = pow( mainSpec, _TerrainSpecPower ) * _TerrainSpecStrength * 4.0;\n\n\t    float textureGlitter  = 0.0;\n\t    textureGlitter\t= pow(textureGlitter , _TerrainGlitterPower);\n\t    mainSpec \t\t*= textureGlitter;\n\n\t\t// The glitter around terrain, looks decent based on rim value\n\t    float rimSpec\t= (pow(rim, _TerrainRimSpecPower)) * textureGlitter;\n\t    vec3 specColor\t= (mainSpec + rimSpec) * _TerrainSpecColor;\n\t\tvec3 terrainCol\t= mix( (rimColor + specColor * shadow) + _TerrainCol, skyCol, pow(skyFog, _TerrainFogPower) ) + res.z * 0.2;  \n\n\t\t// maybe add a fake AO from player, just a sphere should do!\n\t\treturn mix( shadowCol, terrainCol, shadow );\n\t}\n\n\t// Clouds\n\tif( TEST_MAT_LESS (m, MAT_FRONT_CLOUDS ) )\n\t{\n\t\t// Modify the normals so that they create strong specular highlights\n\t\t// towards the top edge of clouds\n\t\tnor\t\t\t\t= normalize( nor + _CloudNormalMod);\n\t\tfloat dotProd\t= dot( nor, vec3(1.0,-3.5,1.0) );\n\n\t\tfloat spec\t\t=  1.0 -  clamp( pow(dotProd, _CloudSpecPower), 0.0, 1.0 );\n\t\tspec \t\t\t*= 2.0;\n\t\tvec3 cloudCol\t= spec * _CloudSpecCol + _CloudCol;\n\n\t\t// Transparency for mountain\n\t\tif( sdBigMountain( pos + (rd * t * _CloudPyramidDistance)) < 0.2 )\n\t \t{\n\t \t\tcloudCol = mix( pyramidCol, cloudCol, _CloudTransparencyMul ); \n\t\t}\n\n\t\t// Mixing for backdrop mountains. Backdrop mountains take more color from Sky. Foreground mountains\n\t\t// retain their own color values, so I can adjust their darkness\n\t\tvec3 inCloudCol = mix(cloudCol, _BackCloudCol + skyCol * 0.5 + spec * _BackCloudSpecCol, MAT_FRONT_CLOUDS - m);\n\t\treturn mix( inCloudCol , skyCol, skyFog * _CloudFogStrength );    \n\t}\n\n\t// Tombs\n\tif( TEST_MAT_LESS(m, MAT_TOMB_SCARF ) )\n\t{\n\t\t// Simple strong diffuse\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.0, 0.0, 1.0);\n\t\tvec3 col\t= mix( _TombMainColor, _TombScarfColor * 2.0, m - MAT_TOMB );\n\t\treturn mix( diff * col, skyCol, skyFog);\n\t}\n\n\t// Flying Helpers\n\tif( TEST_MAT_LESS(m, MAT_FLYING_HELPER_SCARF ) )\n\t{\n\t\tfloat fres\t= pow( clamp(1.0+dot(nor,rd) + 0.75,0.0,1.0), _FlyingHelperFrePower ) * _FlyingHelperFreScale;\n\t\tfloat diff\t= clamp(dot(nor,_LightDir) + 1.5,0.0,1.0);\n\t\tvec3 col = _FlyingHelperYellowColor;\n\n\t\t// The main head\n\t\tif ( TEST_MAT_LESS( m, MAT_FLYING_HELPERS ) )\n\t\t{\n\t\t\tcol = _FlyingHelperMainColor;\n\n\t\t\t// Yellow borders\n\t\t\tfloat outerBorder = step( 0.95, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol  = mix( col * diff, _FlyingHelperYellowColor,  outerBorder );\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(helperScarfMatUVW.z * 2.0 - 1.0);\n\t\t\tfloat rectsX = abs(helperScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\t// Ideally want to do a separate bass for bloom. maybe one day\n\t\t\tfloat bloomCircle = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1); \n\t\t\tfloat bloom  = max( bloomCircle - 0.5, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\tfloat symbolsX = fract(rects/(helperScarfMatUVW.z * 20.0) * 20.0);\n\t\t\tfloat symbolsY = fract(rects/(helperScarfMatUVW.x * 2.0) * 2.0);\n\t\t\tfloat symbolsZ = fract(rects/((helperScarfMatUVW.z + 0.1) * 16.0) * 16.0);\n\t\t\tfloat symbolsW = fract(rects/((helperScarfMatUVW.x + 0.1) * 3.0) * 3.0);\n\n\t\t\tfloat symbols = symbolsY;\n\t\t\tsymbols = max( symbols, symbolsZ );\n\t\t\tsymbols = min(symbols , max(symbolsX, symbolsW));\n\t\t\tsymbols = step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//  float rects = min(rectsX, max(circles,rectsY));\n\n\t\t\tcol = mix( col, _FlyingHelperYellowColor, circles);\n\t\t\tcol = mix( col, _FlyingHelperWhiteColor * 2.0, symbols)  + bloom  * _FlyingHelperBloomScale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The scarfs, just have a yellow border\n\t\t\tfloat outerBorder = step( 0.9, abs(helperScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tcol \t= mix( _FlyingHelperMainColor * diff, _FlyingHelperYellowColor,  outerBorder );\n\t\t}\n\t\treturn mix( fres * col, skyCol, skyFog * _FlyingHelperFogScale );\n\t}\n\n\t// Character\n\tif( TEST_MAT_GREATER (m, MAT_CHARACTER_BASE ) )\n\t{\n\t\tfloat diff = _CharacterDiffScale * clamp( dot( nor, _LightDir ), 0.0, 1.0 );\n\n\t\t// Why did I fudge these normals, I can't remember. It does look good though, so keep it :)\n\t\tnor\t\t= normalize( nor + vec3(0.3,-0.1,1.0));\n\t\tnor.y\t*= 0.3;\n\n\t\tfloat fres\t= pow( clamp( 1.0 + dot(nor,rd) + 0.75, 0.0, 1.0), _CharacterFrePower ) * _CharacterFreScale;\n\t\tvec3 col\t= _CharacterMainColor;\n\n\t\t// Just base color\n\t\tif( TEST_MAT_LESS( m, MAT_CHARACTER_BASE) )\n\t\t{\n\t\t\t// Add sand fade to legs. Mixing terrain color at bottom of legs\n\t\t\tfloat heightTerrainMix\t= pow((pos.y / _CharacterHeightTerrainMix.x), _CharacterHeightTerrainMix.y);\n\t\t\theightTerrainMix\t\t= clamp( heightTerrainMix, 0.0, 1.0 );\n\t\t\tcol\t= mix( _CharacterMainColor, _CharacterTerrainCol, heightTerrainMix );\n\t\t}\n\t\t// Main Cloak\n\t\telse if( TEST_MAT_LESS( m,MAT_CHARACTER_MAIN_CLOAK) )\n\t\t{\n\t\t\t// Cone kind of shapes\n\t\t\tfloat rectsX\t= fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 7.0) ;\n\t\t\trectsX\t\t\t= abs(rectsX * 2.0 - 1.0);\n\t\t\tfloat rects\t\t= rectsX;\n\t\t\trects\t\t\t= step( 0.5, rects * (1.0 - mainCloakMatUVW.y*3.5) );\n\t\t\tcol = mix( col, _CharacterCloakDarkColor, rects );\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder\t\t= step( 0.915, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat betweenBorders\t= step( 0.88, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\t\t\tfloat innerBorder\t\t= step( 0.87, abs(mainCloakMatUVW.y * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - betweenBorders );\n\n\t\t\tcol  = mix( col, _CharacterCloakDarkColor,  betweenBorders );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterYellowColor,  innerBorder);\n\n\t\t\t// The verticle cubes/lines running across the bottom of cloak\n\t\t\tfloat cubes = abs(fract(atan(mainCloakMatUVW.x/ mainCloakMatUVW.z) * 10.0)  * 2.0 - 1.0);\n\t\t\tcubes\t\t= min(betweenBorders, step( 0.9, cubes) );\n\t\t\tcol\t\t\t= mix( col, _CharacterYellowColor,  cubes);\n\t\t}\n\t\t// headscarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_NECK_SCARF) )\n\t\t{\n\t\t\tcol = mix( col, _CharacterYellowColor, step( 0.7, headScarfMatUVW.y) );\n\t\t}\n\t\t// Long Scarf\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_LONG_SCARF) )\n\t\t{\n\t\t\tcol = _CharacterYellowColor;\n\n\t\t\t// Yellow borders, two lines\n\t\t\tfloat outerBorder = step( 0.9, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\t\t\tfloat innerBorder = step( 0.7, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tinnerBorder = min( innerBorder, 1.0 - step( 0.8, abs(longScarfMatUVW.x * 2.0 - 1.0) ) );\n\n\t\t\t// Mix borders\n\t\t\tcol  = mix( col, _CharacterMainColor,  outerBorder );\n\t\t\tcol  = mix( col, _CharacterMainColor,  innerBorder);\n\n\t\t\t// cubes in middle\n\t\t\tfloat rectsY = abs(fract( longScarfMatUVW.y/ 0.10 ) * 2.0 - 1.0);// - 0.5 * 0.10;\n\t\t\tfloat rectsX = abs(longScarfMatUVW.x * 2.0 - 1.0);\n\n\t\t\tfloat circles = 1.0 - (length( vec2(rectsY, rectsX) ) - 0.1);\n\t\t\tcircles = step( 0.5, circles );\n\n\t\t\tfloat bloomCircle\t= 1.0 - (length( vec2(rectsY, rectsX * 0.7) ) - 0.1); \n\t\t\tfloat bloom \t\t= max( bloomCircle - 0.45, 0.0);\n\n\t\t\trectsY = step( 0.5, abs(rectsY * 2.0 - 1.0) );\n\t\t\trectsX = 1.0 - step( 0.5, abs(longScarfMatUVW.x * 2.0 - 1.0) );\n\n\t\t\tfloat rects = min(rectsX, rectsY);\n\n\t\t\t// There are better ways of doing symbols. Spend some time on it, buddy!\n\t\t\tfloat symbolsX = fract(rects/(longScarfMatUVW.y * 0.17) * 10.0);\n\t\t\tfloat symbolsY = fract(rects/(longScarfMatUVW.x * 18.5) * 10.0);\n\n\t\t\tfloat symbols\t= symbolsX;\n\t\t\tsymbols\t\t\t= max( symbols, symbolsY );\n\t\t\tsymbols\t\t\t= step( 0.5, symbols ); \n\n\t\t\tsymbols = min( symbols, circles );\n\n\t\t\t//        float rects = min(rectsX, max(circles,rectsY));\n\t\t\tcol = mix( col, _CharacterMainColor, circles);\n\t\t\tcol = mix( col, _CharacterWhiteColor * 2.0, symbols)  + bloom * _CharacterBloomScale;\n\n\t\t\t// White glow and disintegrating the scarf, showing depleting scarf energy. Needs bloom effect :(\n\t\t\tcol = mix( col, _CharacterMainColor, 1.0 - smoothstep(0.4, 0.6, longScarfMatUVW.y));\n\t\t\tvec3 whiteMiddle = mix( col, _CharacterWhiteColor + bloom * _CharacterBloomScale, step(0.48, longScarfMatUVW.y));\n\t\t\tcol = mix( whiteMiddle, col, step(0.5, longScarfMatUVW.y));\n\t\t}\n\t\t// Face\n\t\telse if( TEST_MAT_LESS( m, MAT_CHARACTER_FACE)  )\n\t\t{\n\t\t\tcol = vec3(0,0,0);\n\t\t}\n\t\tfloat ao = AmbientOcclusion(pos - (rd * 0.01), nor, _CharacterAOParams.x, _CharacterAOParams.y); \n\t\treturn ao * mix( (fres + diff) * col, skyCol, skyFog * _CharacterFogScale );\n\t}\n\treturn vec3( clamp(col * 0.0,0.0,1.0) );\n}\n\n\nfloat rand(float n)\n{\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n    fc = fc*fc*(3.0-2.0*fc);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Move camera using noise. This is probably quite expensive way of doing it :(\n\tfloat unitNoiseX = (noise(iTime * _CameraMovement.w ) * 2.0)  - 1.0;\n\tfloat unitNoiseY = (noise((iTime * _CameraMovement.w ) + 32.0) * 2.0)  -1.0;\n\tfloat unitNoiseZ = (noise((iTime * _CameraMovement.w ) + 48.0) * 2.0)  -1.0;\n\tvec3 ro = _CameraPos + vec3(unitNoiseX, unitNoiseY, unitNoiseZ) * _CameraMovement.xyz;\n\n\n\tvec3 screenRay\t\t= vec3(fragCoord / iResolution.xy, 1.0);\n\tvec2 screenCoord\t= screenRay.xy * 2.0 - 1.0;\n\n\t// Screen ray frustum aligned\n\tscreenRay.xy = screenCoord * _CameraFOV.xy;\n    screenRay.x\t\t\t*= 1.35;\n\tscreenRay.z  = -_CameraFOV.z;\n\tscreenRay /= abs( _CameraFOV.z); \n\n    // In camera space\n\tvec3 rd = normalize(mul( _CameraInvViewMatrix, vec4(screenRay,0.0))).xyz;\n\n\t// Do the render\n\tvec4 col = vec4(render(ro, rd), 0.0);\n\n\t// No it does not need gamma correct or tone mapping or any other effect that you heard about\n\t// and thought was cool. This is not realistic lighting\n\n\t// vignette\n\tfloat vig = pow(1.0 - 0.4 * dot(screenCoord, screenCoord), 0.6) * 1.25;\n\tvig = min( vig, 1.0);\n\tcol *= vig;\n\n\t// Final color\n\tfragColor =  col;\n\tfragColor.a = 1.0;\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n\nvoid main(void)\n{\n  iResolution = vec3(resolution, 0.0);\n  iTime = time;\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "c15437", "parent": null, "id": "46553.0"}