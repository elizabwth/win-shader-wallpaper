{"code": "// Outrun. Created by Reinder Nijhoff 2013\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/Mdf3Dr\n//\n\n// DON'T LOOK AT THE MATH!!!\n// Gigatron for glslsandbox .//.\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n#define MAXDISTANCE 5000.\n#define TRACKSVISIBLE 5\n#define SEGMENTSPERTRACK 8\n#define SECONDSPERTRACK 0.97\n#define TRACKLENGTH 200.\n\n \n\n//\n// math functions\n//\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise(in float x) {\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\n}\nfloat crossp( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n//\n// intersection functions\n//\n\nvoid intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tdist = MAXDISTANCE;\n\tvec2 p = ro.yz;\n\tvec2 r = rd.yz;\n\tvec2 q = a-p;\n\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn;\n\t}\n\tfloat t = crossp(q, s) / rCrossS;\n\tu = crossp(q, r) / rCrossS;\n\t\n\tif(0. <= t && 0. <= u && u <= 1.){\n\t\tdist = t;\n\t}\n}\n\nfloat trackAngle( float s ) {\n\treturn (2.*noise( s*0.1 )-1.)*2.;\n}\nfloat trackHeight( float s ) {\n\treturn 500.*noise( s*0.2 );\n}\n\nfloat traceTrack( vec3 ro, vec3 rd, out vec2 texcoord ) {\n\tfloat dist = MAXDISTANCE, dtest, xdist, zdist = MAXDISTANCE;\n\tfloat utest;\n\t\n\tfloat tf = time / SECONDSPERTRACK;\n\tfloat starttrack = floor(tf);\n\tfloat fracttrack = fract(tf);\n\t\n\tfloat z = -fracttrack*TRACKLENGTH;\n\t\n\tfloat sa = trackAngle( tf );\n\t\t\n\tfor( int it=0; it<TRACKSVISIBLE; it++) {\n\t\tfloat t = float(it)+starttrack;\n\t\t\t\n\t\tfor( int is=0; is<SEGMENTSPERTRACK; is++ ) {\t\t\t\n\t\t\tfloat dt = float(is)/float(SEGMENTSPERTRACK);\n\t\t\tintersectSegment( ro, rd, vec2( trackHeight( t+dt ), z ), \n\t\t\t\t\t\t\t vec2( trackHeight( t+dt+(1./float(SEGMENTSPERTRACK)) ), z+(TRACKLENGTH/float(SEGMENTSPERTRACK))), dtest, utest );\n\t\t\tif( dtest < dist ) {\n\t\t\t\tdist = dtest;\n\t\t\t\ttexcoord.y = utest;\n\t\t\t\txdist = ro.x+rd.x*dist;\n\t\t\t\tzdist = ro.z+rd.z*dist;\n\t\t\t\ttexcoord.x = xdist + 2.*zdist*sin( trackAngle(t+dt+(utest/float(SEGMENTSPERTRACK)))-sa );\n\t\t\t}\n\t\t\tz+=(TRACKLENGTH/float(SEGMENTSPERTRACK));\n\t\t}\n\t}\n\treturn zdist;\n}\n\nvec3 trackColor( vec2 texcoord ) {\n\tif( abs(texcoord.x)<50. ) { // road\n\t\tif(texcoord.y>0.5) {\n\t\t\treturn abs(texcoord.x)>46.?vec3(1.):vec3( 086./255. );\n\t\t} else {\n\t\t\treturn mod(texcoord.x, 22.)<1.5?vec3(1.):vec3( 054./255. );\n\t\t}\n\t} else { // desert\n\t\treturn (texcoord.y>0.5)?vec3( 000./255., 119./255., 003./255. )\n\t\t\t:vec3( 0./255., 161./255., 005./255. );\n\t}\n}\nvec3 skyColor( vec2 texcoord ) {\n\tvec3 col = vec3( 10./255., 146./255., 255./255.);\n\tfloat n = noise( texcoord.x )*texcoord.y*10.+texcoord.y*4.;\n\tn += noise( texcoord.x * 10. );\n\tif( n < 1. ) col = mix(\n\t\tvec3( 170./255., 154./255., 138./255.),\n\t\tvec3( 235./255., 219./255., 203./255. ), clamp(texcoord.y*32., 0., 1.) );\n\treturn col;\n}\n\nvoid main(){\n\tvec2 q = gl_FragCoord.xy/resolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= resolution.x/resolution.y;\n\n\tvec3 ro = vec3( -20.*sin(trackAngle(time/SECONDSPERTRACK)), 10.+trackHeight(time/SECONDSPERTRACK), -14. );\n\tvec3 rd = normalize( vec3( p, 1. ) );\t\n\tvec3 color = vec3( 0. );\n\t\n\tvec2 texcoord;\n\tfloat d =  traceTrack( ro, rd, texcoord );\n\tif( d < MAXDISTANCE ) {\n\t\tcolor = mix( trackColor( texcoord ), vec3( 170./255., 154./255., 138./255.), d/(float(TRACKSVISIBLE)*TRACKLENGTH));\n\t} else {\n\t\tif( rd.y > 0. ) {\n\t\t\tcolor = skyColor( vec2( p.x-2.*trackAngle(time/SECONDSPERTRACK), p.y) );\n\t\t} else {\n\t\t\tcolor = vec3( 170./255., 154./255., 138./255.);\n\t\t}\n\t}\n\t\n\tgl_FragColor = vec4( clamp(color, 0., 1.),1.0);\n}", "user": "32f5f90", "parent": "/e#25490.0", "id": "28375.1"}