{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D iChannel0, iChannel1, iChannel2, bb;\n\nvarying vec2 SurfacePosition;\nvarying vec2 SurfaceSize;\n\nfloat  iGlobalTime;\n\n// Created by anatole duprat - XT95/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//Maths\nconst float PI = 3.14159265;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\n\n//Raymarching \nfloat map( in vec3 p );\n\nfloat box( in vec3 p, in vec3 data )\n{\n    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);\n}\n\nfloat sphere( in vec3 p, in float size)\n{\n\treturn length(p)-size;\n}\n\nvec4 raymarche( in vec3 org, in vec3 dir, in vec2 nfplane )\n{\n\tfloat d = 1.0, g = 0.0, t = 0.0;\n\tvec3 p = org+dir*nfplane.x;\n\t\n\tfor(int i=0; i<42; i++)\n\t{\n\t\tif( d > 0.001 && t < nfplane.y )\n\t\t{\n\t\t\td = map(p);\n\t\t\tt += d;\n\t\t\tp += d * dir;\n\t\t\tg += 1./42.;\n\t\t}\n\t}\n\t\n\treturn vec4(p,g);\n}\n\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.01, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\nfloat ambiantOcclusion( in vec3 p, in vec3 n, in float d )\n{\n    float dlt = 0.0;\n    float oc = 0.0;\n    \n    for(int i=1; i<=6; i++)\n    {\n\t\tdlt = d*float(i)/6.;\n\t\toc += (dlt - map(p+n*dlt))/exp(dlt);\n    }\n    oc /= 6.;\n    \n    return clamp(pow(1.-oc,d), 0.0, 1.0);\n}\n\n\n\n\n//Geometry\nfloat ill = 0.;\nfloat impulsTime;\nfloat map( in vec3 p )\n{\n\tfloat d = p.y;\n\tvec3 pp = p;\n\till = 0.;\n\t\n\t//mirrors\n\tp = abs(p);\n\tp = rotate(vec3(-1.,0.,0.),40.)*p;\n\tp = abs(p);\n\tp = rotate(vec3(0.,1.,0.),45.)*p;\n\tp = abs(p);\n\t\n\t//make a branch of cubes\n\tfor(int i=0; i<15; i++)\n\t{\n\t\tp -= vec3(.25);\n\t\tp = rotate( normalize( vec3(.5, .25, 1.0 ) ), 20.+pp.x+pp.y+pp.z )*p;\n\t\t\n\t\t\n\t\tfloat size = cos(float(i)/20.*PI*2.-impulsTime);\n\t\tfloat dbox = box( p, vec3( (1.1-float(i)/20.)*.25 + pow(size*.4+.4,10.) ) );\n\t\n\t\tif( dbox < d)\n\t\t{\n\t\t\td = dbox;\n\t\t\till = pow(size*.5+.5, 10.);\n\t\t}\n\t\n\t}\n\t//add another one iteration with a sphere\n\tp -= vec3(.25);\n\tp = rotate( normalize( vec3(.5, .25, 1.0 ) ), 20.+pp.x+pp.y+pp.z )*p;\n\td = min(d, sphere(p,.25) );\n\t\n\treturn d;\n}\n\n//Shading\nvec3 ldir = normalize( vec3(.267,.358,.90) );\nvec3 sky( in vec3 dir )\n{\n\tvec3 col = mix( vec3(40., 34., 30.), vec3(18., 28., 44.), min( abs(dir.y)*2.+.5, 1. ) )/255.*.5;\n\tcol *= (1. + vec3(1.,.7,.3)/sqrt(length(dir-ldir))*4.); //sun\n\t\n\treturn col;\n}\nvec3 shade( in vec4 p, in vec3 n, in vec3 org, in vec3 dir )\n{\t\t\n\t//direct lighting\n\tvec3 col = vec3(.1);\n\tcol += pow(sky(vec3(1.,0.,0.))*max( dot(n, ldir), 0.)*2., vec3(2.));\n\t\n\t//illumination of the tree\n\tcol += mix( vec3(1.,.3,.1), vec3(.1, .7, .1), length(p.xyz)/8.)*ill*p.w*1.;\n\t\n\t//ao\n\tcol *= pow( ambiantOcclusion(p.xyz,n,1.) , 1.5 );\n\t\n\t//fog/sky\n\tcol = mix(col, sky(dir), vec3(1.)*min( pow( distance(p.xyz,org)/20., 2. ), 1. ) );\n\t\n\treturn col;\n}\n\n//Main\nvoid main( void )\n{\n\tiGlobalTime = 1.65*time;\n        impulsTime = iGlobalTime+sin(iGlobalTime+PI);\n\t//screen coords\n\tvec2 q = gl_FragCoord.xy/resolution;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= resolution.x/resolution.y;\n\t\n\t//camera ray\n\tfloat ctime = (iGlobalTime+140.)*.025;\n\tvec3 org = vec3( cos(ctime)*10., 2.+cos(ctime), sin(ctime)*10. );\n\tvec3 dir = normalize( vec3(v.x, v.y, 1.5) );\n\tdir = lookat( -org + vec3(0., 2., 0.), vec3(0., 1., 0.) ) * dir;\n\t\n\t//classic raymarching by distance field\n\tvec4 p = raymarche(org, dir, vec2(4., 20.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, org, dir);\n\t\n\t//post process\n    col = pow( col*2., vec3(1.75) );\n\tcol *= sqrt( 32.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) ); //from iq\n\t\n\tgl_FragColor = vec4( col*min(iGlobalTime/5., 1.), 1. );\n}", "user": "ea1ff41", "parent": null, "id": "17474.1"}