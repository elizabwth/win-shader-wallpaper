{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4ddfzH\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n/*\n * Eyeball Explosion\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1.,0.);\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat smoothstep_noise(float x)\n{\n    float r1 = -1.+2.*rand(floor(x)*c.xx), r2 = -1.+2.*rand(ceil(x)*c.xx);\n    return mix(r1, r2, smoothstep(.25, .75, fract(x)));\n}\n\nfloat mfsmoothstep_noise(float x)\n{\n    float sum = 0.;\n    float a = 1.;\n    const float phi = 0.45;\n    \n    float f = 1.;\n    for (int i = 1; i < 6; i++)\n    {\n        sum = a*smoothstep_noise(f*x) + sum;\n        a = a*phi;\n        f *= 2.0;\n    }\n    \n    return sum;\n}\n\nvec2 rot(vec2 x, float p)\n{\n    return mat2(cos(p), sin(p), -sin(p), cos(p))*x;\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nfloat rect(vec2 x, vec2 b)\n{\n    return length(max(abs(x)-b,0.));\n}\n\nvec3 synthcol(float scale, float phase)\n{\n    vec3 c2 = vec3(207.,30.,102.)/255.,\n        c3 = vec3(245., 194., 87.)/255.;\n    mat3 r1 = rot((5.e-1*phase)*vec3(1.1,1.3,1.5));\n    return \n        (\n            1.1*mix\n            (\n                -(cross(c2, r1*c2)),\n                -(r1*c2), \n                scale\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5-.33*c.xy;\n    uv = rot(uv, .25*iTime);\n    \n    vec4 sdf = vec4(0., c.yyy);\n    \n    float N = 128.,\n        r_inner = .2;\n    \n    for(int i=0; i<12; ++i)\n    {\n        uv = rot(uv, 1.1);\n        vec2 p = vec2(length(uv), atan(uv.y/uv.x)-float(i)*.1*iTime),\n        q = vec2(p.x-.05*float(i), mod(p.y, 2.*pi/N)-pi/N),\n        q0 = vec2(r_inner, q.y);\n    \n    \tfloat index = (p-q).y;\n        \n        r_inner = .2+float(i)*.005+ .0005*12.;\n        \n        float dr = .1*mfsmoothstep_noise(index-iTime-4.*float(i)) + .05*rand(index*c.xx+.2*c.yx),\n            len = abs(.005*float(i)+dr),\n            width = abs(.015+.005*rand(index*c.xx+.4));\n\n        vec4 sda = vec4(rect(q-r_inner*c.xy, len*c.xy+width*c.yx), synthcol(((q.x-r_inner)/.05+(q.y/2./pi)), iTime+sin(iTime+1.*float(i))));\n        sdf = mix(sdf, sda, step(sda.x, sdf.x));\n    }\n    \n    vec3 col = sdf.gba*step(sdf.x, 0.);\n\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\t", "user": "9fde378", "parent": null, "id": "46534.0"}