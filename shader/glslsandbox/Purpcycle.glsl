{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/MtXfD2\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 2.0\n#define PI 3.14159265359\n#define FAR 50.0 \n#define EPS 0.005\n\n#define FLOOR 1.0\n#define ORB 2.0\n#define WHITE_GLOW 3.0\n#define FLAT_L_BLUE 4.0\n#define FLAT_D_BLUE 5.0\n#define WALL 6.0\n#define BLUE_GLOW 7.0\n#define ARCH 8.0\n#define ARCH_2 9.0\n\nvec3 lp = vec3(0.0);\n\nstruct Scene {\n    float t;\n    vec3 n;\n    float id;\n    float wli;\n    float bli;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n    p.z *= 0.8;\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 archway(vec3 rp) {\n    float rr = (mod(rp.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\n    rp.xy *= rot(T * 0.2 * rr);\n    float a = atan(rp.y, rp.x) / 6.2831853;\n    float ia = floor(a * 4.0) / 4.0 * 6.2831853;\n    vec3 q = rp;\n    q.xy *= rot(ia);\n    q.z = mod(q.z, 6.0) - 3.0;\n    float t1 = sdTorus(q.xzy, vec2(1.5, 0.15));\n    float t2 = sdTorus(q.xzy, vec2(1.5, 0.22));\n    float t3 = sdTorus(q.xzy, vec2(1.71, 0.02));\n    float t4 = sdTorus(q.xzy - vec3(0.0, -0.22, 0.0), vec2(1.5, 0.05));\n    t2 = max(t2, q.y - 0.5); \n    t4 = max(t4, q.y - 1.2);\n    q = rp;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 6.0) - 3.0;\n    float t5 = sdTorus(q.zyx - vec3(0.0, 0.0, 1.5), vec2(0.26, 0.03));     \n    vec2 near = vec2(t1, ARCH);\n    near = nearest(near, vec2(t2, WALL));    \n    near = nearest(near, vec2(t3, ARCH_2));    \n    near = nearest(near, vec2(t4, BLUE_GLOW));    \n    near = nearest(near, vec2(t5, WHITE_GLOW));    \n    return vec4(near, t4, t5);\n}\n\nvec3 tower1(vec3 rp) {\n    rp.x = abs(rp.x);\n    rp.z = mod(rp.z, 12.0) - 6.0;\n    vec2 core = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.2, 3.0), FLAT_L_BLUE);\n    float sh = 2.0 + sin(T * 0.2) * 1.;\n    vec2 sleeve = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 3.0), WHITE_GLOW);\n    float sleevecut = fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.4, 3.0);\n    sleeve.x = max(max(sleeve.x, sh - 0.4 - rp.y), rp.y - sh);\n    sleevecut = max(max(sleevecut, sh - 0.3 - rp.y), rp.y - sh + 0.1);\n    sleeve.x = max(sleeve.x, -sleevecut);\n    vec2 base = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 0.5), WALL);\n    return vec3(nearest(nearest(base, core), sleeve), sleeve.x);\n}\n\nvec3 tower2(vec3 rp) {\n    vec3 q = rp;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 24.0) - 12.0;\n    vec2 near = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 2.0, 1.0), WALL);\n    vec2 core = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.2, 6.0), WALL);\n    q = rp;\n    float rh = sin(T * 0.1) * 1.5;    \n    q.y += rh;\n    q.x = abs(q.x);\n    q.z = mod(q.z, 24.0) - 12.0;\n    vec2 ringcore = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.3, 4.2), BLUE_GLOW);\n    q.y = mod(q.y, 0.4) - 0.2;\n    vec2 rings = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.8, 0.1), WALL);\n    rings.x = max(rings.x, rp.y + rh - 4.4);\n    near = nearest(near, core);\n    near = nearest(near, rings);\n    near = nearest(near, ringcore);    \n    return vec3(near, ringcore.x);\n}\n\nvec3 smallorbs(vec3 rp) {\n    rp.z = mod(rp.z, 3.0) - 1.5;\n    rp.x = abs(rp.x);\n    vec2 orb = vec2(sdSphere(rp - vec3(1.2, 0.0, 0.0), 0.2), ORB);\n    vec2 torus = vec2(sdTorus(rp - vec3(1.2, 0.0, 0.0), vec2(0.25, 0.02)), WHITE_GLOW);\n    return vec3(nearest(orb, torus), torus.x);\n}\n\nvec3 mediumorbs(vec3 rp) {    \n    vec3 q = rp;\n    q.z = mod(q.z, 6.0) - 3.0;\n    q.x = abs(q.x);\n    vec2 near = vec2(sdSphere(q - vec3(3.4, 0.0, 0.0), 0.8), ORB);\n    vec2 torus = vec2(sdTorus(q - vec3(3.4, 0.0, 0.0), vec2(1.0, 0.03)), WHITE_GLOW);\n    torus.x = min(torus.x, sdTorus(q - vec3(1.5, 0.0, 0.0), vec2(0.35, 0.03)));\n    float fins = sdSphere(q - vec3(3.4, 0.0, 0.0), 0.9);\n    q.y = mod(q.y, 0.1) - 0.05;\n    fins = max(fins, q.y - 0.01);    \n    vec2 fins1 = vec2(max(fins, rp.y - 0.55), FLAT_L_BLUE);\n    fins1 = max(fins1, 0.4 - rp.y);\n    vec2 fins2 = vec2(max(fins, rp.y - 0.25), FLAT_D_BLUE);\n    fins2 = max(fins2, 0.2 - rp.y);  \n    near = nearest(near, torus);\n    near = nearest(near, fins1);\n    near = nearest(near, fins2);\n    return vec3(near, torus.x);\n}\n\nvec3 largeorbs(vec3 rp) {\n    vec3 q = rp;\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\n    q.x = abs(q.x);\n    vec2 near = vec2(sdSphere(q - vec3(16.0, 0.0, 0.0), 6.0), ORB);\n    vec2 torus = vec2(sdTorus(q - vec3(16.0, 0.0, 0.0), vec2(6.5, 0.1)), WHITE_GLOW);\n    float fins = sdSphere(q - vec3(16.0, 0.0, 0.0), 6.3);\n    q.y = mod(q.y, 0.4) - 0.2;\n    fins = max(fins, q.y - 0.05);    \n    vec2 fins1 = vec2(max(fins, rp.y - 1.8), FLAT_L_BLUE);\n    fins1 = max(fins1, 1.1 - rp.y);\n    vec2 fins2 = vec2(max(fins, rp.y - 0.7), FLAT_D_BLUE);\n    fins2 = max(fins2, 0.3 - rp.y);  \n    near = nearest(near, torus);\n    near = nearest(near, fins1);\n    near = nearest(near, fins2);\n    return vec3(near, torus.x);\n}\n\nvec4 map(vec3 rp) {\n    vec4 arch = archway(rp);\n    vec2 near = arch.xy;\n    vec3 tow1 = tower1(rp);\n    near = nearest(near, tow1.xy);\n    vec3 tow2 = tower2(rp);\n    near = nearest(near, tow2.xy);\n    vec3 sorbs = smallorbs(rp);\n    near = nearest(near, sorbs.xy);\n    vec3 morbs =  mediumorbs(rp);\n    near = nearest(near, morbs.xy);\n    vec3 lorbs = largeorbs(rp);\n    near = nearest(near, lorbs.xy);\n    float blt = min(tow2.z, arch.z); //blue light\n    float wlt = min(sorbs.z, morbs.z); //white light\n    wlt = min(wlt, lorbs.z);\n    wlt = min(wlt, tow1.z);\n    wlt = min(wlt, arch.w);\n    return vec4(near, blt, wlt);\n}\n\nvec3 normal(vec3 rp) {\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(rp + e.xyy).x, d2 = map(rp - e.xyy).x;\n    float d3 = map(rp + e.yxy).x, d4 = map(rp - e.yxy).x;\n    float d5 = map(rp + e.yyx).x, d6 = map(rp - e.yyx).x;\n    float d = map(rp).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Based on original by IQ.\n// http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 rp, vec3 n) {\n\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(rp + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//IQ\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog(vec3  rgb,      // original color of the pixel\n              float d, // camera to point distance\n              vec3  rayDir,   // camera to point vector\n              vec3  sunDir,\n              float b)  // sun light direction\n{\n    //float b = 0.07;\n    float fogAmount = 1.0 - exp(-d * b);\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\n    vec3  fogColor  = mix(vec3(0.5, 0.3, 0.8), // purple\n                          vec3(0.7, 0.7, 1.0), // blue\n                          pow(sunAmount, 8.0));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n    \n    float t = 0.0;\n    float id = 0.0;\n    float bli = 0.0;\n    float wli = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;    \n        vec4 scene = map(rp);\n        if (scene.x < EPS || t > FAR) {\n            id = scene.y;\n            break;   \n        }\n        \n        bli += 0.05 / (1.0 + scene.z * scene.z * 30.0) * step(0.0, rp.y);\n        wli += 0.05 / (1.0 + scene.w * scene.w * 100.0) * step(0.0, rp.y);\n        \n        t += scene.x;\n    }\n    \n    return vec4(t, id, bli, wli);\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    float bli = 0.0;\n    float wli = 0.0;\n    \n    vec3 fo = vec3(0.0, 0.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < mint) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n\n    vec4 scene = march(ro, rd);\n    if (scene.x > 0.0 && scene.x < mint) {\n        if (scene.x < mint) {\n            mint = scene.x;\n            minn = normal(ro + rd * scene.x);\n            id = scene.y;\n        }\n    }\n    \n    bli = scene.z;\n    wli = scene.w;\n\n    return Scene(mint, minn, id, wli, bli);\n}\n\nvec2 floorTexture(vec3 rp, float t) {\n\n    float line = 0.0;\n    float cut = 0.0;\n        \n    //small orbs\n    vec3 q = rp;\n    q.z = mod(q.z, 3.0) - 1.5;\n    q.x = abs(q.x);\n    line += smoothstep(0.33, 0.32, length(q.xz - vec2(1.2, 0.0))); \n    cut += smoothstep(0.3, 0.29, length(q.xz - vec2(1.2, 0.0)));\n                \n    //medium orbs and archway\n    q = rp;\n    q.z = mod(q.z, 6.0) - 3.0;\n    q.x = abs(q.x);\n    line += smoothstep(1.2, 1.18, length(q.xz - vec2(3.4, 0.0))); \n    cut += smoothstep(1.1, 1.08, length(q.xz - vec2(3.4, 0.0)));\n    line += smoothstep(0.5, 0.48, length(q.xz - vec2(1.5, 0.0)));\n    cut += smoothstep(0.42, 0.41, length(q.xz - vec2(1.5, 0.0)));\n        \n    //large orbs\n    q = rp;\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\n    q.x = abs(q.x);\n    line += smoothstep(7.6, 7.5, length(q.xz - vec2(16.0, 0.0))); \n    cut += smoothstep(7.4, 7.3, length(q.xz - vec2(16.4, 0.0)));\n        \n    q = rp;\n    vec2 grid = fract(vec2(q.x * 0.25, q.z * 0.5));\n    float gridline = (smoothstep(0.01, 0.005, grid.x) + smoothstep(0.998, 0.999, grid.x));\n    gridline += smoothstep(0.02 + t / FAR * 0.2, 0.01, grid.y) / (t * 1.0);\n    \n    line = clamp(line + gridline, 0.0, 1.0);\n    line /= t * 0.5;\n\n    return vec2(line, cut);\n}\n\nfloat tex(vec2 uv) {\n    vec2 mx = mod(uv, 0.1) - 0.05;     \n    float tx = (mx.x * mx.y) > 0.0 ? 1.0 : 0.0;\n    tx *= sin(uv.y * 100.0 + T) * 0.6 + 1.0;\n    tx *= sin(uv.x * 100.0 + T) * 0.6 + 1.0;\n    tx *= step(uv.y, 0.1) + step(-uv.y, -0.2); \n    return tx;\n}        \n\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    \n    float diff = 1.0;\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n    float atten = 1.0;\n    float fres = 0.0;\n    \n    if (scene.id == FLOOR) {\n        \n        vec2 flrTex = floorTexture(rp, scene.t);        \n        pc += vec3(0.5, 0.3, 1.0) * clamp(flrTex.x, 0.0, 1.0);\n        pc -= clamp(flrTex.y, 0.0, 1.0);\n        \n    } else if (scene.id == ORB) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n        \n        pc = vec3(0.1) * diff;\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == WALL) {\n\n        diff = max(dot(ld, scene.n), 0.05);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n\n        pc = vec3(0.1) * diff;\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == ARCH) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\n\n        vec3 q = rp;\n        float rr = (mod(q.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\n        q.xy *= rot(T * 0.2 * rr);\n        float a = atan(q.y, q.x) / 6.2831853;\n        a = fract(a * 8.0);\n        \n        pc = vec3(0.1) * diff;\n        pc += vec3(0.6, 0.3, 1.0) * step(a, 0.3) * tex(vec2(length(rp.xy), a));\n        pc += vec3(1.0) * spec;\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\n\n    } else if (scene.id == WHITE_GLOW) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n        \n        pc = vec3(1.0) * diff;\n        \n    } else if (scene.id == BLUE_GLOW) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.3, 0.3, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n\n    } else if (scene.id == FLAT_L_BLUE) {\n        \n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.5, 0.8, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n        \n    } else if (scene.id == FLAT_D_BLUE) {\n\n        diff = max(dot(ld, scene.n), 0.8);\n\n        pc = vec3(0.3, 0.3, 1.0) * diff;\n        pc += vec3(1.0) * spec;\n\n    } else if (scene.id == ARCH_2) {\n        \n        diff = max(dot(ld, scene.n), 0.05);\n        \n        pc = vec3(0.5, 0.3, 1.0);\n        pc *= diff;\n        pc += vec3(1.0) * spec;\n    }\n    \n    //pc *= AO(rp, scene.n);\n    \n    return pc;\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 0.5);\n    lp = lookAt + vec3(4.0, 4.0, -2.0);\n    ro = lookAt + vec3(0.0, 0.8, -4.0);\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        mint = scene.t;\n        pc = colourScene(ro, rd, scene);\n        \n        if (scene.id == FLOOR || \n            scene.id == ORB || \n            scene.id == WALL ||\n            scene.id == ARCH) {\n            \n            float lt = scene.t;\n            vec3 rc = vec3(0.5, 0.3, 1.0) * 0.2;\n            float ra = 0.1;\n            \n            vec3 rpb = ro + rd * (scene.t - EPS);\n            vec3 rrd = reflect(rd, scene.n);\n            Scene refl = drawScene(rpb, rrd);\n            \n            if (refl.t > 0.0 && refl.t < FAR) {\n                rc = colourScene(rpb, rrd, refl); \n                lt += refl.t;\n                if (refl.id == WHITE_GLOW ||\n                    refl.id == BLUE_GLOW) {\n                    ra = 0.02;\n                } else if (refl.id == FLAT_L_BLUE ||\n                           refl.id == FLAT_D_BLUE) {\n                    ra = 0.06;\n                }\n            }\n            float rt = 1.0 / (1.0 + lt * lt * ra);\n            pc += rc * rt * 0.5;\n            pc += vec3(1.0) * refl.wli * rt * 0.5;\n        }\n    }\n\n    pc = applyFog(pc, mint, rd, normalize(vec3(2.0, 2.0, 4.0)), 0.01);\n\n    pc += vec3(1.0) * scene.wli * 0.8;\n    pc += vec3(0.3, 0.3, 1.0) * scene.bli;\n    \n\tfragColor = vec4(pc, 1.0);\n    //fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n\nvoid main(void)\n{\n  iTime = time;\n  iResolution = vec3(resolution, 0.0);\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "a9b2f9d", "parent": null, "id": "45637.0"}