{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform vec2 surfaceSize;\nvarying vec2 surfacePosition;\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//------------------------------------------------------------\n//\n// Dynamics for quadratic 1D polynomials fc(z)=z\u00b2+c\n//\n// * Orange: the Fatou set Kc. \n// * Black: the Julia set Jc.\n// * Checkerboard distortion: the Boettcher map phi(z). \n// * Checkerboard shadowing: the gradient of the Green's function, log|phi(z)|\n// * Blue: the two fixed points. \n// * Green, the period 2 fixed points.\n// * White: c\n// * Yellow: the Koening coordinates\n//\n// Some theory:\n//\n// * c (white) belongs to Kc (orange), for these are all connected Julia sets. \n//\n// * When both fixed points (blue) are in Jc but not in Kc, or in other words, when both points\n//   are repeling (derivative of fc(z) is bigger than one), c does not belong to the Mandelbrot \n//   set's main cardioid, but to bulbs of higher period. In that case Kc (orange) is made of several \n//   branches (as many as the period of the bul)\n//\n// * When one of the two fixed points (blue dots) is inside Kc, meanins it is attractive (derivative\n//   of fc(z) < 1), then c belongs to the main cardiod of the Mandelbrot set, and Kc is a single piece \n//   shape.\n//\n// * When the period 2 fixed points are always repelling (belong to Jc, not to Kc) except for the sets \n//   that have c belonging to the period-2 bulb of the Mandelbrot set. In those cases, the green dots\n//   become attrative and sit inside the orange area Kc.\n// \n// * The Koening coordinates can only been seen when c belongs to the main cariod of the Madelbrot set\n//\n//------------------------------------------------------------\n\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n\n//------------------------------------------------------------\n\nfloat argument( in vec2 p )\n{\n\tfloat f = atan( p.y, p.x );\n\tif( f<0.0 ) f += 6.2831;\n\tf = f/6.2831;\n\treturn f;\n}\n\nfloat grid( in vec2 p )\n{\n\tvec2 q = 16.0*p;\n\tvec2 r = fract( q );\n    float fx = smoothstep( 0.05, 0.06, r.x ) - smoothstep( 0.94, 0.95, r.x );\n    float fy = smoothstep( 0.05, 0.06, r.y ) - smoothstep( 0.94, 0.95, r.y );\n\t\t\n    return 0.5 + 0.5*mod( floor(q.x)+floor(q.y), 2.0 );\n}\n\nfloat cross( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nbool isInTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c )\n{\n    vec3 di = vec3( cross( b - a, p - a ), \n\t\t\t\t    cross( c - b, p - b ), \n\t\t\t\t    cross( a - c, p - c ) );\n\t\t\t\n    return all(greaterThan(di,vec3(0.0)));\n}\n\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvec3 circle( vec3 bcol, vec3 col, in vec2 a, in vec2 b )\n{\n\tfloat rr = 0.04;\n\t\n\tfloat len = length(a-b) * 2.0 / surfaceSize.y;\n\t\n\tvec3 res = mix( bcol, col, 1.0 - smoothstep( rr-0.01, rr, len ) );\n\t\n\tfloat f = smoothstep( rr-0.01, rr, len ) - smoothstep( rr, rr+0.01, len );\n\t\t\n\treturn mix( res, vec3(0.0), f );\n}\n\n//------------------------------------------------------------\n\nvoid main( void )\n{\n\tvec2 p = surfacePosition * 2.0;\n\t\n\tfloat at = mod( (time+.5)/5.0, 8.0 );\n\n\t//vec2 c =    vec2(-0.800, 0.100);\n\t//c = mix( c, vec2( 0.280,-0.490), smoothstep(0.0,0.1,at) );\n\t//c = mix( c, vec2(-0.500,-0.500), smoothstep(1.0,1.1,at) );\n\t//c = mix( c, vec2(-0.160, 0.657), smoothstep(2.0,2.1,at) );\n\t//c = mix( c, vec2(-0.650, 0.100), smoothstep(3.0,3.1,at) );\n\t//c = mix( c, vec2(-0.114, 0.650), smoothstep(4.0,4.1,at) );\n\t//c = mix( c, vec2(-0.731, 0.166), smoothstep(5.0,5.1,at) );\n\t//c = mix( c, vec2(-0.100,-0.660), smoothstep(6.0,6.1,at) );\n\t//c = mix( c, vec2(-0.800, 0.100), smoothstep(7.0,7.1,at) );\n\n\t//vec2 c = (mouse - 0.5) * 2.0 * vec2(resolution.x / resolution.y, 1.0);\n\tvec2 c = ((mouse - ( gl_FragCoord.xy / resolution )) * surfaceSize + surfacePosition) * 2.0;\n\t\n\t// get the 2 fixed points\n\tvec2 one = vec2( 1.0, 0.0 );\n\n    vec2 fix1_1 = 0.5*( one + csqrt( one - 4.0*c ) );\n    vec2 fix1_2 = 0.5*( one - csqrt( one - 4.0*c ) );\n\tvec2 fix2_1 = -(csqrt(-4.0*c-3.0*one)+one)/2.0;\n\tvec2 fix2_2 =  (csqrt(-4.0*c-3.0*one)-one)/2.0;\n\tvec2 fix2_3 = -(csqrt( one-4.0*c)-one)/2.0;\n\tvec2 fix2_4 =  (csqrt( one-4.0*c)+one)/2.0;\n\n\t\t\n\tvec2 z = p;\n\tvec2 dz = vec2( 1.0, 0.0 );\n\n\tvec2 ph = z;\n\tvec2 gr = vec2( log(length(z)), atan(z.y,z.x) );\n\tfloat t = 0.0;\n\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tif( dot(z,z)>10000.0 ) continue;\n\n        t += 1.0;\n\n        // derivative\n        dz = 2.0*cmul( z, dz );\n\n        // point\n        z = cmul(z,z) + c;\n\n        vec2 a = cdiv(z,z-c);\n        float s = pow( 0.5, t );\n\n        // phi\n        ph = cmul( ph, cpow(a, s) );\n\t\t\n        // green\n        gr.x += log(length(a)) * s;\n        float aa = atan(a.y,a.x);\n        if( isInTriangle( z, vec2(0.0), fix1_2, c ) )\n        {\n            aa -= sign(aa)*2.0*3.14159;\n        }\n        gr.y += aa * s;\n\t}\n\t\n\t\n\tvec3 col = vec3(1.0,0.65,0.10);\n\t\n\tif( t<511.0 )\n\t{\n        float s = pow( 0.5, t );\n        vec2  phib = cpow( z, s );\n        float phiR = length( phib );\n        float greenR = log(length(z)) * s;\n        float greenI = argument(z*s);\n        float d = log( length(z) ) * length(z) / length(dz);\n        vec2  gradG = -conj(cmul( dz, conj(z) ));\n        float n = t/50.0;\n        float sn = -log2(abs(greenR))/50.0;\n\t\n        col = vec3( 0.6 + 0.4*dot(normalize(-gradG),vec2(0.707)) );\n\n        col *= vec3( grid( ph ) );\n        col *= vec3(1.0)*clamp(d*50.0,0.0,1.0);\n\t}\n\telse\n\t{\n\t\tz = p;\n\n\t\tfloat t = 0.0;\n\t\tfor( int i=0; i<200; i++ )\n\t\t{\n\t\t\tif( length(z-fix1_2)>0.001 )\n\t\t\t{\n\t\t\tz = cmul(z,z) + c;\n\t\t\tt += 1.0;\n\t\t\t}\n\t\t}\n\t\tvec2 fix = fix1_2;\n\t\tif( length(2.0*fix1_1)<1.0 ) fix=fix1_1;\n\t\tif( length(2.0*fix)<1.0 )\n\t\t{\n\t\t    vec2 ph = cdiv( z - fix, cpow(2.0*fix,t) );\n\t\t    float g = log(length(ph));\n\t\t    float l = 1.0 - 0.1*smoothstep( 0.7, 0.71, sin(48.0*g) );\n\t\t    col += 0.1*(abs(g));\n\t\t    ph = 1.0*vec2( length(ph), atan(ph.y,ph.x)/3.14 );\n\t\t\tcol *= l;\n\t\t}\n\t\t\n\t}\n\n\n\t// color depending of attractive/repulsive fixed point\n\tcol = circle( col, vec3(1.0,1.0,1.0), p, c );\n\n\tvec3 col2 = vec3(0.0,1.0,0.0);\n\tcol = circle( col, col2, p, fix2_1 );\n\tcol = circle( col, col2, p, fix2_2 );\n\tcol = circle( col, col2, p, fix2_3 );\n\tcol = circle( col, col2, p, fix2_4 );\n\n\tvec3 col1 = vec3(0.0,0.7,1.0);\n\tcol = circle( col, col1, p, fix1_1 );\n\tcol = circle( col, col1, p, fix1_2 );\n\n\tgl_FragColor = vec4( col, 1.0 );\n}", "user": "50023fa", "parent": "/e#9772.0", "id": "9773.1"}