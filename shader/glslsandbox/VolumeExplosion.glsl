{"code": "// volume explosion shader\n// simon green / nvidia 2012\n// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n\n// sorry, port from HLSL!\n#define float3 vec3\n#define float4 vec4\n\n// parameters\n// be nice if we had sliders for these!\nconst int _MaxSteps = 64;\nconst float _StepDistanceScale = 0.5;\nconst float _MinStep = 0.001;\nconst float _DistThreshold = 0.005;\n\nconst int _VolumeSteps = 32;\nconst float _StepSize = 0.02; \nconst float _Density = 0.1;\n\nconst float _SphereRadius = 0.5;\nconst float _NoiseFreq = 4.0;\nconst float _NoiseAmp = -0.5;\nconst float3 _NoiseAnim = float3(1, 0, 0);\n\n// iq's nice integer-less noise function\n\n// matrix to rotate the noise octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    p = m*p*2.02; f += 0.03125*abs(noise( p ));\t\n    return f/0.9375;\n}\n\n\n// distance field stuff\nfloat sphereDist(float3 p, float4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\n// returns signed distance to nearest surface\n// displace is displacement from original surface (0, 1)\nfloat distanceFunc(float3 p, out float displace)\n{\t\n\tfloat d = length(p) - _SphereRadius;\t// distance to sphere\n\t//float d = length(p) - (sin(time*0.25)+0.8);\t// animated radius\n\t\n\t// offset distance with pyroclastic noise\n\t//p = normalize(p) * _SphereRadius;\t// project noise point to sphere surface\n\tdisplace = fbm(p*_NoiseFreq + _NoiseAnim*time);\n\td += displace * _NoiseAmp;\n\t\n\treturn d;\n}\n\n// calculate normal from distance field\nfloat3 dfNormal(float3 pos)\n{\n    float eps = 0.001;\n    float3 n;\n    float s;\n#if 0\n    // central difference\n    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - distanceFunc( float3(pos.x-eps, pos.y, pos.z), s );\n    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - distanceFunc( float3(pos.x, pos.y-eps, pos.z), s );\n    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - distanceFunc( float3(pos.x, pos.y, pos.z-eps), s );\n#else\n    // forward difference (faster)\n    float d = distanceFunc(pos, s);\n    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - d;\n    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - d;\n    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - d;\n#endif\n\n    return normalize(n);\n}\n\n// color gradient \n// this should be in a 1D texture really\nfloat4 gradient(float x)\n{\n\tconst float4 c0 = float4(4, 4, 4, 1);\t// hot white\n\tconst float4 c1 = float4(1, 1, 0, 1);\t// yellow\n\tconst float4 c2 = float4(1, 0, 0, 1);\t// red\n\tconst float4 c3 = float4(0.4, 0.4, 0.4, 4);\t// grey\n\t\n\tfloat t = fract(x*3.0);\n\tfloat4 c;\n\tif (x < 0.3333) {\n\t\tc =  mix(c0, c1, t);\n\t} else if (x < 0.6666) {\n\t\tc = mix(c1, c2, t);\n\t} else {\n\t\tc = mix(c2, c3, t);\n\t}\n\t//return float4(x);\n\t//return float4(t);\n\treturn c;\n}\n\n// shade a point based on position and displacement from surface\nfloat4 shade(float3 p, float displace)\n{\t\n\t// lookup in color gradient\n\tdisplace = displace*1.5 - 0.2;\n\tdisplace = clamp(displace, 0.0, 0.99);\n\tfloat4 c = gradient(displace);\n\t//c.a *= smoothstep(1.0, 0.8, length(p));\n\t\n\t// lighting\n\tfloat3 n = dfNormal(p);\n\tfloat diffuse = n.z*0.5+0.5;\n\t//float diffuse = max(0.0, n.z);\n\tc.rgb = mix(c.rgb, c.rgb*diffuse, clamp((displace-0.5)*2.0, 0.0, 1.0));\n\t\n\t//return float4(float3(displace), 1);\n\t//return float4(dfNormal(p)*float3(0.5)+float3(0.5), 1);\n\t//return float4(diffuse);\n\t//return gradient(displace);\n\treturn c;\n}\n\n// procedural volume\n// maps position to color\nfloat4 volumeFunc(float3 p)\n{\n\tfloat displace;\n\tfloat d = distanceFunc(p, displace);\n\tfloat4 c = shade(p, displace);\n\treturn c;\n}\n\n// sphere trace\n// returns hit position\nfloat3 sphereTrace(float3 rayOrigin, float3 rayDir, out bool hit, out float displace)\n{\n\tfloat3 pos = rayOrigin;\n\thit = false;\n\tdisplace = 0.0;\t\n\tfloat d;\n\t//float3 hitPos;\n\tfloat disp;\n\tfor(int i=0; i<_MaxSteps; i++) {\n\t\td = distanceFunc(pos, disp);\n        \tif (d < _DistThreshold) {\n\t\t\thit = true;\n\t\t\tdisplace = disp;\n\t\t\t//hitPos = pos;\n        \t\t//break;\t// early exit from loop doesn't work in ES?\n        \t}\n\t\t//d = max(d, _MinStep);\n\t\tpos += rayDir*d*_StepDistanceScale;\n\t}\n\t\n\treturn pos;\n\t//return hitPos;\n}\n\n\n// ray march volume from front to back\n// returns color\nfloat4 rayMarch(float3 rayOrigin, float3 rayStep, out float3 pos)\n{\n\tfloat4 sum = float4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tfloat4 col = volumeFunc(pos);\n\t\tcol.a *= _Density;\n\t\tcol.a = min(col.a, 1.0);\n\t\t\n\t\t// pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n#if 0\n\t\t// exit early if opaque\n        \tif (sum.a > _OpacityThreshold)\n            \t\tbreak;\n#endif\t\t\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid main(void)\n{\n    vec2 q = gl_FragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= resolution.x/resolution.y;\n\t\n    float rotx = mouse.y*4.0;\n    float roty = mouse.x*4.0;\n\t\n    // camera\n    vec3 ro = 2.5*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere trace distance field\n    bool hit;\n    float displace;\n    vec3 hitPos = sphereTrace(ro, rd, hit, displace);\n\n    vec4 col = vec4(0, 0, 0, 1);\n    if (hit) {\n\t// shade\n   \tcol = shade(hitPos, displace);\t// opaque version\n\t//col = rayMarch(hitPos, rd*_StepSize, hitPos);\t// volume render\n    }\n\n    gl_FragColor = col;\n}", "user": "bd3126f", "parent": "/e#2077.5", "id": "2080.1"}