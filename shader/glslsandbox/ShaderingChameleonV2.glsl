{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/Msc3z8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nvec3  iMouse;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n#define mouse       stemu_mouse\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Created by sebastien durand - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n// Change this to improve quality - Rq only applied on edge\n#define ANTIALIASING 5\n\n// decomment this to see where antialiasing is applied\n//#define SHOW_EDGES\n\n#define RAY_STEP 48\n//#define NOISE_SKIN\n\n#define PI 3.14159279\n\n\nbool WithChameleon;\t    // for optim : true if the ray intersect the bounding sphere of the chameleon\n\nfloat Anim;\t\t\t\t// pos in animation\nmat2 Rotanim, Rotanim2, Rot3; // rotation matrix\nfloat ca3, sa3;         // pre calculater sin and cos\nfloat closest;\t\t\t// min distance to chameleon on the ray (use for glow light) \n\n// ----------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n\n#ifdef NOISE_SKIN\n// By Shane -----\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    float ref = (tex3D(tex,  p , nor)).x;                 \n    vec3 grad = vec3( (tex3D(tex, vec3(p.x-eps, p.y, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y-eps, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y, p.z-eps), nor).x)-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\n#endif\n\n\n// ----------------------------------------------------\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n// ----------------------------------------------------\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  \treturn length(max(abs(p)-b,0.))-r;\n}\n\n// capsule with bump in the middle -> use for arms and legs\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float dd = cos(3.14*h*2.5);  // Little adaptation\n    return vec2(length(pa - ba*h) - r*(1.-.1*dd+.4*h), 30.-15.*dd); \n}\n\nvec2 smin(in vec2 a, in vec2 b, in float k ) {\n\tfloat h = clamp( .5 + (b.x-a.x)/k, 0., 1. );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n\tfloat h = clamp( .5 + (b-a)/k, 0., 1. );\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\nvec2 min2(in vec2 a, in vec2 b) {\n\treturn a.x<b.x?a:b;\n}\n\n// ----------------------------------------------------\n\nvec2 spiralTail(in vec3 p) {\n    float a = atan(p.y,p.x)+.2*Anim;\n\tfloat r = length(p.xy);\n    float lr = log(r);\n    float th = 0.475-.25*r; // thickness according to distance\n    float d = fract(.5*(a-lr*10.)/PI); //apply rotation and scaling.\n\t\n    d = (0.5-abs(d-0.5))*2.*PI*r/10.;\n  \td *= 1.1-1.1*lr;  // space fct of distance\n   \n    r+=.05*cos(a*60.); // radial bumps\n    r+=(.2-.2*(smoothstep(0.,.08, abs(p.z))));\n\n    return vec2(\n        max(max(sqrt(d*d+p.z*p.z)-th*r, length(p.xy-vec2(.185,-.14))-1.05), -length(p.xy-vec2(.4,1.5))+.77),\n        abs(30.*cos(10.*d)) + abs(20.*cos(a*10.)));\n}\n\nvec2 body(in vec3 p) {\n    const float scale = 3.1;\n    \n    p.y=-p.y;\n    p.x += 2.;\n    p/=scale;\n    \n    float a = atan(p.y,p.x);\n\tfloat r = length(p.xy);\n    float d = (.5*a-log(r))/PI; //apply rotation and scaling.\n    float th = .4*(1.-smoothstep(.0,1.,abs(a+.35-Anim*.05)));    \n \n    d = (1.-2.*abs(d-.5))*r*1.5;\n    \n   // r +=.005*cos(80.*d); // longitudinal bumps\n    r+=.01*cos(a*200.); // radial bumps\n    r-=.2*(smoothstep(0.,.1,abs(p.z)));\n    \n    float dis = sqrt(d*d+p.z*p.z)-th*r;\n \tdis *= scale;\n    dis = max(dis, length(p.xy-vec2(.86,-.07))-.7);\n    return vec2(dis, abs(30.*cos(17.*d)) + abs(20.*cos(a*20.)));\n}\n\nvec2 head(in vec3 p) {\n //   p.yz *= Rotanim;  // small rotation of head \n   \n   \n    p.z = abs(p.z);\n    \n    p.y += .25+.03*Anim;\n    p.x += .03+.03*Anim;\n    p.xy *= Rotanim;\n\n    vec3 pa1 = p, ba = vec3(1.,-.2,-.3);\n    pa1.z = p.z-.22;\n    \n    float h = clamp(dot(pa1, ba), 0.0, 1.0 );\n    pa1.x -= h;\n\n    // Head\n\tfloat dh = length(pa1) - .8*(-.5+1.3*sqrt(abs(cos(1.5701+h*1.5701))))+.08*(1.+h)*smoothstep(0.,.2,abs(p.z));\n    dh = max(-p.y-.2, dh); \n    dh += -.04+.04*(smoothstep(0.,.2,abs(p.z)));\n    dh = min(dh, max(p.x-1.35,max(p.y+.3, length(p-vec3(1.-.035*Anim,.25,-.1))-.85)));\n    dh += .01*cos(40.*h) -.06;\n    \n    // Eyes\n    vec3 eye = vec3(-.2,-.0105,.15);\n  \teye.zy *= Rotanim2;\n    float de = max(length(p-vec3(.7,.26,.45))-.3, -(length(p-vec3(.7,.26,.45) - eye)-.13*clamp(Anim+.2,.7,1.1)));\n    vec2 dee = min2(vec2(de,20.+1000.*abs(dot(p,eye))), vec2(length(p-vec3(.7,.26,.45))-.2, -102.));\n  \n    return smin(dee, vec2(dh*.8, 40.- abs(20.*cos(h*3.))) ,.06); \n}\n    \nvec2 support(vec3 p, vec2 c, float th) {\n    p-=vec3(-2.5,-.7,0);\n    float d1 = length(p-vec3(0,-6.5,0)) - 3.;          \n    float d = length(max(abs(p-vec3(0,-2,.75))-vec3(.5,2.5,.1),0.))-.11;     \n    p.xy *= Rot3; \n    d = min(d, max(length(max(abs(p)-vec3(4,3,.1),0.))-.1,\n                  -length(max(abs(p)-vec3(3.5,2.5,.5),0.))+.1));\n    return min2(vec2(d1,-105.),\n        min2(vec2(d,-100.), \n                 vec2(length(max(abs(p-vec3(0,0,.2))-vec3(3.4,2.4,.01),0.))-.3, -103.)));\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 map(in vec3 pos) {\n    // Ground\n    vec2 res1 = vec2( pos.y+4.2, -101.0 );\n    // Screen\n\tres1 = min2(support(pos+vec3(2.5,-0.56,0), vec2(.1,15.), 0.05), res1);\n    \n    if (WithChameleon) {\n        // Tail + Body\n        vec2 res = smin(spiralTail(pos.xyz-vec3(0,-.05-.05*Anim,0)), body( pos.xyz-vec3(-.49,1.5,0)),.1 ); \n        // Head\n        res = smin(res, head(pos - vec3(-2.8,3.65,0)), .5);\n        pos.z = abs(pos.z);\n        // legs\n        res = min2(res, min2(sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(.75,-.1*Anim+.6,.05),.16),\n                             sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(-.35,1.35,.3),.16)));\n        res = min2(res, vec2(length(pos-vec3(-.35,1.35,.1))- .33, 30.));   \n        // arms \n        res = smin(res, min2(sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85),vec3(-1.25+.03*Anim,3.,.2), .16),\n                             sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85), vec3(-1.25,2.1,.3),.16)),.15);\n        res = min2(res, vec2(length(pos-vec3(-1.55,1.9,.1))- .3, 30.));\n        \n        if (res.x < closest) {\n            closest = abs(res.x);\n        }\n        return min2(res, res1);\n    }\n    else {\n        return res1;\n    }\n}\n\n\n//----------------------------------------------------------------------\n#define EDGE_WIDTH 0.15\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd, inout float hmin) {\n    closest = 9999.; // reset closest trap\n\tfloat precis = .0006, h = EDGE_WIDTH+precis, t = 2., m = -1.;\n    hmin = 0.;\n    for( int i=0; i<RAY_STEP; i++) {\n        if( abs(h)<t*precis || t>maxd ) break;\n        t += h;\n\t    vec2 res = map(ro+rd*t);\n        if (h < EDGE_WIDTH && res.x > h + 0.001) {\n\t\t\thmin = 10.0;\n\t\t}\n        h = res.x;\n\t    m = res.y;\n    }\n    \n\t//if (hmin != h) hmin = 10.;\n    if( t>maxd ) m = -200.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<26; i++ ) {\n\t\tif( t>maxt ) break;\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp( res, 0., 1.);\n}\n\n// normal with kali edge finder\nfloat Edge=0.;\nvec3 calcNormal(vec3 p, vec3 rd, float t) { \n    float pitch = .2 * t / iResolution.x; \n\tpitch = max( pitch, .015 );\n\n\tvec3 e = vec3(0.0,2.*pitch,0.0);\n\tfloat d1=map(p-e.yxx).x,d2=map(p+e.yxx).x;\n\tfloat d3=map(p-e.xyx).x,d4=map(p+e.xyx).x;\n\tfloat d5=map(p-e.xxy).x,d6=map(p+e.xxy).x;\n\tfloat d=map(p).x;\n    \n\tEdge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5)); //edge finder\n\tEdge=min(1.,pow(Edge,.55)*15.);\n    \n    vec3 grad = vec3(d2-d1,d4-d3,d6-d5);\n\treturn normalize(grad - max(.0,dot (grad,rd ))*rd);\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 mandelbrot(in vec2 uv, vec3 col) {\n    uv.x += 1.5;\n    uv.x = -uv.x;\n\n    float a=.05*sqrt(abs(Anim)), ca = cos(a), sa = sin(a);\n    mat2 rot = mat2(ca,-sa,sa,ca);\n    uv *= rot;\n\tfloat kk=0., k = abs(.15+.01*Anim);\n    uv *= mix(.02, 2., k);\n\tuv.x-=(1.-k)*1.8;\n    vec2 z = vec2(0);\n    vec3 c = vec3(0);\n    for(int i=0;i<50;i++) {\n        if(length(z) >= 4.0) break;\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.y*z.x) + uv;\n        if(length(z) >= 4.0) {\n            kk = float(i)*.07;\n            break; // does not works on some engines !\n        }\n    }\n    return clamp(mix(vec3(.1,.1,.2), clamp(col*kk*kk,0.,1.), .6+.4*Anim),0.,1.);\n}\n\nvec3 screen(in vec2 uv, vec3 scrCol) {\n    // tv effect with horizontal lines and color switch\n    vec3 oricol = mandelbrot(vec2(uv.x,uv.y), scrCol);\n    vec3 col;\n\tfloat colorShift = .2*cos(.5*iTime);\n    col.r = mandelbrot(vec2(uv.x,uv.y+colorShift), scrCol).x;\n    col.g = oricol.y;\n    col.b = mandelbrot(vec2(uv.x,uv.y-colorShift), scrCol).z;\n    \n\tuv *= Rot3;\t\n\tcol =(.5*scrCol+col)*(.5+.5*cos(iTime*5.))*cos(iTime*10.+40.*uv.y);  \n    return col*col;\n}\n\n// clean lines on the ground\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.1,.9,abs(mod(p+v*.5, v)-v*.5)/.08);\n    return k.x * k.y;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, inout float hmin) { \n    // Test bounding sphere (optim)\n    WithChameleon = intersectSphere(ro,rd,vec3(-.5,1.65,0),3.15); //2.95);\n    \n    vec2 res = castRay(ro,rd,60.0, hmin);\n    float distCham = abs(closest);\n    \n#ifdef SHOW_EDGES\n     if( res.y>-150.)  {\n           vec3 pos = ro + res.x*rd;\n     \tvec3 nor = calcNormal(pos, rd, res.x);\n     }\n    return vec3(1);\n#else\n    \n    float t = res.x;\n\tfloat m = res.y;\n    vec3 cscreen = vec3(sin(.1+1.1*iTime), cos(.1+1.1*iTime),.5);\n    cscreen *= cscreen;\n \n    vec3 col;\n\tfloat dt;\n    float glow = 1.-smoothstep(Anim + cos(iTime),.9+1.15,2.2);\n    glow *= step(.3, hash(iTime)); //floor(.01+10.5*iTime)));\n    \n    if( m>-150.)  { \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, rd, t);\n\n        if( m>0. ) { // Chameleon\n\t\t\tcol = vec3(.4) + .35*cscreen + .3*sin(1.57*.5*iTime + vec3(.05,.09,.1)*(m-1.) );\n#ifdef NOISE_SKIN\n            nor = doBumpMap(iChannel0, pos*.5, nor, 0.05);\n#endif            \n        } else if (m<-104.5) {  // bottom of screen\n            col = vec3(.92);\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n            col += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0); \n        } else if (m<-102.5) {\n           \tif (pos.z<0.) { // screen\n            \tcol = screen(pos.xy,cscreen);\n                col += 20.*glow*col;\n            } else { // back of screen\n                col = vec3(.92);\n            \tdistCham *= .25; // Hack for chameleon light on screen\n            }\n        } else if (m<-101.5) {\n            col = .2+3.5*cscreen*glow;\n            \n        } else if(m<-100.5) {  // Ground\n            float f = mod( floor(2.*pos.z) + floor(2.*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.);\n            col = .1+.9*col*isGridLine(pos.xz, vec2(2.));\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n \t\t\tcol += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0);     \n    \t\t//col = clamp(col,0.,1.);\n        } else {  // Screen\n            col = vec3(.92);\n            distCham *= .25; // Hack for chameleon light on screen\n        }\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { \n            WithChameleon = intersectSphere(pos,lig,vec3(-.5,1.65,0),2.95);\n            sh = softshadow( pos, lig, 0.02, 13., 8.0 ); \n            dif *= sh; \n        }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.80*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 1.80*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 0.8*dif*vec3(1.00,0.90,0.70)*ao;\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = 1.2*sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf*(.5+.5*sh) + vec3(.25)*col*spe + 0.2*fre*(0.5+0.5*col);\n        \n        float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n        col += vec3((.1+cscreen*.1 )* pow( rimMatch, 10.));\n\t}\n\n\tcol *= 2.5*exp( -0.01*t*t );\n    float BloomFalloff = 15000.; //mix(1000.,5000., Anim);\n \tcol += .5*glow*cscreen/(1.+distCham*distCham*distCham*BloomFalloff);\n    \n\treturn vec3( clamp(col,0.0,1.0) );\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // animation\n    float GlobalTime = iTime; // + .1*hash(iTime);\n    \n    Anim = clamp(5.6*cos(GlobalTime)*cos(4.*GlobalTime),-2.5,1.2);\n    ca3 = cos(.275+.006*Anim); sa3 = sin(.275+.006*Anim);   \n\tRot3 = mat2(ca3,-sa3,sa3,ca3);\n    float a=.1+.05*Anim, ca = cos(a), sa = sin(a);\n    Rotanim = mat2(ca,-sa,sa,ca);\n    float b = mod(GlobalTime,12.)>10.?cos(8.*GlobalTime):.2*cos(4.*GlobalTime), cb = cos(b), sb = sin(b);\n    Rotanim2 = mat2(cb,-sb,sb,cb);\n    float time = 17. + /*14.5 +*/ GlobalTime;\n    \n    // mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // camera\t\n    float dist = 13.;\n    vec3 ro = vec3( -0.5+dist*cos(0.1*time + 6.0*mo.x), 3.5 + 10.0*mo.y, 0.5 + dist*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -3.5, .5, 0. );\n\n    // camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    // render\n    vec3 colorSum = vec3(0);\n    int nbSample = 0;\n    \n #if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = 0.; //hash(iTime); // Use frame rate to improve antialiasing ... not sure of result\n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));\n\t\t//vec3 ray = Ray(2.0,fragCoord.xy+subPix);\n\t\tvec2 q = (fragCoord.xy+subPix)/iResolution.xy;\n\t\t//vec2 q = (fragCoord.xy+.4*vec2(cos(6.28*float(i)/float(ANTIALIASING)),sin(6.28*float(i)/float(ANTIALIASING))))/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n        \n        nbSample++;\n        float hmin = 100.;\n        colorSum += sqrt(render( ro, rd, hmin));\n        \n#ifdef SHOW_EDGES\n \t\tcolorSum = vec3(1);\n        if (Edge>0.3) colorSum = vec3(.6);  \n        if (hmin>0.5) colorSum = vec3(0,0,0);   \n        break;\n#endif\n        \n#if (ANTIALIASING > 1)\n        // optim : use antialiasing only on objects edges //exit if far from objects\n        if (Edge<0.3 && hmin<0.5 ) break;\n\t}\n#endif\n    \n    fragColor = vec4(colorSum/float(nbSample), 1.);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n#undef mouse\n\nvoid main(void)\n{\n  iTime = time;\n  iResolution = vec3(resolution, 0.0);\n  iMouse = vec3(mouse * resolution, 0.0);\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n  gl_FragColor.a = 1.0;\n}", "user": "5c3d30b", "parent": null, "id": "45488.0"}