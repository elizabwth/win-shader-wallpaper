{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4djXzz\n */\n\n//#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nconst vec3  iMouse = vec3(0.0);\n\n// Emulate a black texture\n#define textureLod(s, uv, lod) vec4(0.0)\n\n// --------[ Original ShaderToy begins here ]---------- //\n/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise2dT(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;\t// use constant here instead?\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat Density(vec3 p)\n{\n    //float ws = 0.06125*0.125;\n    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));\n    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n        //temp *= saturate(t-1.0);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.01,0.1,1.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "6412275", "parent": null, "id": "46548.0"}