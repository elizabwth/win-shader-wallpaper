{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n///  IDEAS NEEDED .. See U @ TrSac 2014 in Denmark -Harley ;-)\nuniform float time;\nvarying vec2 surfacePosition;\n#define time time + length(surfacePosition)\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//#define ENABLE_HARD_SHADOWS // turn off to enable faster AO soft shadows \n//#define ENABLE_VIBRATION\n//#define ENABLE_POSTPROCESS // Works better on window view rather than full screen\n\n// Parameters for a shitty computer\n#define RAY_STEPS 60\n#define SHADOW_STEPS 12\n#define LIGHT_COLOR vec3(.85,.9,1.)\n#define AMBIENT_COLOR vec3(.3,.9,1.)\n#define FLOOR_COLOR vec3(1.,.7,.9)\n#define ENERGY_COLOR vec3(1.,.7,.4)\n#define BRIGHTNESS .9\n#define GAMMA 2.1\n#define SATURATION .9\n\n\n#define detail .00005\n#define t time*.1\n\n// Ported from Kali's amazing work on www.shadertoy.com\n\nvec3 lightdir=normalize(vec3(0.4,-0.3,-1.));\nvec3 ambdir=normalize(vec3(0.,0.,1.));\nconst vec3 origin=vec3(0.,3.11,0.);\nvec3 energy=vec3(0.01);\n#ifdef ENABLE_VIBRATION\nfloat vibration=sin(time*60.)*.0013;\n#else\nfloat vibration=0.;\n#endif\nfloat det=0.0;\nvec3 pth1;\n\nfloat fnoo() {\n\treturn sin(time) * 0.5 + 0.5;\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec3 path(float ti) {\nreturn vec3(sin(ti),.3-sin(ti*.632)*.3,cos(ti*.5))*.5;\n}\n\nfloat Sphere(vec3 p, vec3 rd, float r){//A RAY TRACED SPHERE\n\tfloat b = dot( -p, rd );\n\tfloat inner = b * b - dot( p, p ) + r * r;\n\tif( inner < 0.0 ) return -1.0;\n\treturn b - sqrt( inner );\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.xz=abs(.5-mod(tpos.xz,1.));\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\tfor (int i=0; i<7; i++) {//LOWERED THE ITERS\n\t\tp.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);\n\t\tp=p*(2.0+vibration*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);\n\t\tp.xz*=mat2(-0.416*fnoo(),-0.91,0.91,-0.416*fnoo());\n\t}\n\tfloat fl=pos.y-3.013;\n\tfloat fr=(length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;//RETURN A RRECT\n\t//float fr=length(p.xyz)/p.w;\n\tfloat d=min(fl,fr);\n\td=min(d,-pos.y+3.95);\n\tif (abs(d-fl)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\tfloat t1=Sphere((pos-.005*sdir)-pth1,-sdir,0.015);\n\tif (t1>0. && t1<.5) {\n\t\tvec3 sphglowNorm=normalize(pos-t1*sdir-pth1);\n\t\tsh=1.-pow(max(.0,dot(sphglowNorm,sdir))*1.2,3.);\n\t} \n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<.6 && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 14.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nfloat texture(vec3 p) {\n\tp=abs(.5-fract(p*10.));\n\tvec3 c=vec3(3.);\n\tfloat es, l=es=0.;\n\tfor (int i = 0; i < 10; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .0, 1.);\n\t\t\tp = p* -1.5 + c;\n\t\t\tif ( mod(float(i), 2.) < 1. ) { \n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-1. / abs(l - pl));\n\t\t\t}\n\t}\n\treturn es;\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL\n\t#ifdef ENABLE_HARD_SHADOWS\n\t\tfloat sh=shadow(p, lightdir);\n\t#else\n\t\tfloat sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS\n\t#endif\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh;\n\tfloat y=3.35-p.y;\n\tvec3 amb=max(.5,dot(dir,-n))*.5*AMBIENT_COLOR;\n\tif (hid<.5) {\n\t\tamb+=max(0.2,dot(vec3(0.,1.,0.),-n))*FLOOR_COLOR*pow(max(0.,.2-abs(3.-p.y))/.2,1.5)*2.;\n\t\tamb+=energy*pow(max(0.,.4-abs(y))/.4,2.)*max(0.2,dot(vec3(0.,-sign(y),0.),-n))*2.;\n\t}\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.);\n\tvec3 col;\n\tfloat energysource=pow(max(0.,.04-abs(y))/.04,4.)*2.;\n\tif (hid>1.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=texture(p)*.23+.2; \n\t\tk=min(k,1.5-energysource);\n\t\tcol=mix(vec3(k,k*k,k*k*k),vec3(k),.3);\n\t\tif (abs(hid-1.)<.001) col*=FLOOR_COLOR*1.3;\n\t}\n\tcol=col*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\tif (hid<.5) { \n\t\tcol=max(col,energy*2.*energysource);\n\t}\n\tcol*=min(1.,ao+length(energy)*.5*max(0.,.1-abs(y))/.1);\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat ey=mod(t*.5,1.);\n\tfloat glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\tvec3 origdir=dir,origfrom=from,sphNorm;\n\t\n\t//FAKING THE SQUISHY BALL BY MOVING A RAY TRACED BALL\n\tvec3 wob=cos(dir*500.0*length(from-pth1)+(from-pth1)*250.+time*10.)*0.0005;\n\tfloat t1=Sphere(from-pth1+wob,dir,0.015);\n\tfloat tg=Sphere(from-pth1+wob,dir,0.02);\n\tif(t1>0.){\n\t\tref=1.0;from+=t1*dir;sphdist=t1;\n\t\tsphNorm=normalize(from-pth1+wob);\n\t\tdir=reflect(dir,sphNorm);\n\t} \n\telse if (tg>0.) { \n\t\tvec3 sphglowNorm=normalize(from+tg*dir-pth1+wob);\n\t\tglow+=pow(max(0.,dot(sphglowNorm,-dir)),5.);\n\t};\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<3.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*60.)*(1.+ref*5.);\n\t\t\ttotdist+=d.x; \n\t\t\tenergy=ENERGY_COLOR*(1.5+sin(time*20.+p.z*10.))*.25;\n\t\t\tif(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t\tif (d.y<.5 && d.x<0.03){//ONLY DOING THE GLOW WHEN IT IS CLOSE ENOUGH\n\t\t\t\tfloat glw=min(abs(3.35-p.y-ey),abs(3.35-p.y+ey));//2 glows at once\n\t\t\t\teglow+=max(0.,.03-d.x)/.03*\n\t\t\t\t(pow(max(0.,.05-glw)/.05,5.)\n\t\t\t\t+pow(max(0.,.15-abs(3.35-p.y))/.15,8.))*1.5;\n\t\t\t}\n\t\t}\n\t}\n\tfloat l=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);\n\tl*=max(0.2,dot(-dir,lightdir));\n\tvec3 backg=.5*(1.2-l)+LIGHT_COLOR*l*.7;\n\tbackg*=AMBIENT_COLOR;\n\tif (d.x<=det) {\n\t\tvec3 norm=normal(p-abs(d.x-det)*dir);//DO THE NORMAL CALC OUTSIDE OF LIGHTING (since we already have the sphere normal)\n\t\tcol=light(p-abs(d.x-det)*dir, dir, norm, d.y)*exp(-.2*totdist*totdist); \n\t\tcol = mix(col, backg, 1.0-exp(-1.*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(l,30.)*.5;\n\tcol+=glow*(backg+lglow)*1.3;\n\tcol+=pow(eglow,2.)*energy*.015;\n\tcol+=lglow*min(1.,totdist*totdist*.3);\n\tif (ref>0.5) {\n\t\tvec3 sphlight=light(origfrom+sphdist*origdir,origdir,sphNorm,2.);\n\t\tcol=mix(col*.3+sphlight*.7,backg,1.0-exp(-1.*pow(sphdist,1.5)));\n\t}\n\treturn col; \n}\n\nvec3 move(inout mat2 rotview1,inout mat2 rotview2) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=atan(advec.x,advec.z);\n\trotview1=mat2(cos(an),sin(an),-sin(an),cos(an));\n\t\t  an=advec.y*1.7;\n\trotview2=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\n\n\nvoid main()\n{\n\tpth1 = path(t+.3)+origin+vec3(0.,.01,0.);\n\tvec2 uv = gl_FragCoord.xy / resolution.xy*2.-1.;\n\tvec2 uv2=uv;\n#ifdef ENABLE_POSTPROCESS\n\tuv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*.07;\n#endif\n\tuv.y*=resolution.y/resolution.x;\n\tvec2 mouse=(mouse.xy/resolution.xy-.5)*3.;\n\tif (mouse.x<1.) mouse=vec2(0.);\n\tmat2 rotview1, rotview2;\n\tvec3 from=origin+move(rotview1,rotview2);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tdir.yz*=rotview2;\n\tdir.xz*=rotview1;\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n#ifdef ENABLE_POSTPROCESS\n\tvec3 rain=vec3(0.);//pow(texture2D(iChannel0,uv2+iGlobalTime*7.25468).rgb,vec3(1.5));\n\tcolor=mix(rain,color,clamp(time*.5-.5,0.,1.));\n\tcolor*=1.-pow(length(uv2*uv2*uv2*uv2)*1.1,6.);\n\tuv2.y *= resolution.y / 360.0;\n\tcolor.r*=(.5+abs(.5-mod(uv2.y     ,.021)/.021)*.5)*1.5;\n\tcolor.g*=(.5+abs(.5-mod(uv2.y+.007,.021)/.021)*.5)*1.5;\n\tcolor.b*=(.5+abs(.5-mod(uv2.y+.014,.021)/.021)*.5)*1.5;\n\tcolor*=.9+rain*.35;\n#endif\n\tgl_FragColor = vec4(color,1.);\n}", "user": "60e3272", "parent": "/e#17420.0", "id": "17427.0"}