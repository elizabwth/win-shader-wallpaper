{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n// Converted by Batblaster\n\nfloat \tt;\nfloat\ta; // angle used both for camera path and distance estimator\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n#define\tCAM_PATH 0\t\t\t// only interesting for the default shape\n\t\t\t\t\t\t\t// take 0 or 1\n\n//#define\tPULSE\t\t\t// uncomment this line to get it pulsing\n\n//#define\tOUTSIDE\t\t\t// let you see the outside of the shape\n//#define\tCOUNTOURED\t\t// see another rendering mode\n//#define\tCENTERED\t\t// set the view in the middle\n//#define\tALTERNATE_DE\t// another shape\n// #define\tNO_MOUSTACHE\t// only work with ALTERNATE_DE ENABLED\n//#define\tEXPERIMENTAL\t// only work if ALTERNATE_DE is DISABLED\n\t\t\t\t\t\t\t// EXPERIMENTAL is beautiful with COUNTOURED enabled\n#define\tVIGNETTE_RENDER\t// vignetting\n#define\t\tFWD_SPEED\t-5.\t// the speed at wich the tunnel travel\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = time;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = resolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 20.0);\n\n    #ifndef OUTSIDE\n    pos.z = t*FWD_SPEED;\n\t#endif\n    \n    vec4\tinter = (march(pos, dir));\n\n    #ifndef COUNTOURED\n    col.xyz = blackbody(inter.x*300./inter.w);\n    #else\n   \tfloat countour = 5.*-inter.x;\n    col.xyz = blackbody( inter.w*100. + countour);\n\t#endif\n    #ifdef\tVIGNETTE_RENDER\n    col.xyz = blackbody( ( (1.1-length(uv)*1.1)*inter.x) *70. );\n    #endif\n    c_out =  vec4(col,1.0);\n}    \n\nfloat\tde_0(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p *.35;\n\n\trotate(pr.xy, (a) );\n\n\tpr.xy *= 2.;\n\tpr.xyz = fract(pr.xyz);\n\tpr -= .5;\n    #ifndef ALTERNATE_DE\n    mind = length(pr.yz)-.3252;\n    #ifdef\tEXPERIMENTAL\n    mind += (length(-abs(pr.zz)+abs(pr.xy)) - .2);\n    #endif\n    mind = min(mind, (length(pr.xyz)-.432 ) );\n    mind = min(mind, (length(pr.xy)-.32 ) );\n\t#else\n     #ifndef NO_MOUSTACHE\n    \tmind = length(pr.yz+abs(pr.xx)*.2 )-.25;\n     #else\n    \tmind = length(pr.yz )-.25;\n     #endif\n    #endif\n    \n\treturn (mind);\n}\n\nfloat\tde_1(vec3 p) // cylinder\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\t\n\tvec2\tq;\n    \n\tq = vec2(length(pr.yx) - 4., pr.z );\n    #ifdef PULSE\n    q.y = rot(q.xy, vec2(-1.+sin(t*10.), 0.)).x;\n\t#else\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n    #endif\n\tmind = length(q) - 4.5;\n\n\treturn mind;\n}\n\n// add 2 distances to constraint the de_0 to a cylinder\nfloat\tde_2(vec3 p)\n{\n    #ifndef OUTSIDE\n    return (de_0(p)-de_1(p)/8.);\n    #else\n    return (de_0(p)+de_1(p)/8.);\n    #endif\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    a = (t*1.5) + 1.5*cos( .8*(p.y*.015+p.x*.015+p.z *.15)  + t);\n    #ifdef\tCAM_PATH\n    vec2\trot = vec2( cos(a+1.57), sin(a+1.57) );\n    #else\n    vec2\trot = vec2( cos(t*.5), sin(t*.5) );\n    #endif\n    #ifndef CENTERED\n\t #ifdef\tCAM_PATH\n      #if CAM_PATH == 0\n\t\tp.x += rot.x*2.+sin(t*4.)/2.;\n\t\tp.y += rot.y*2.+cos(t*4.)/2.;\n      #elif CAM_PATH == 1\n    \tp.x += rot.x*2.+sin(t*2.);\n\t\tp.y += rot.y*2.+cos(t*2.);\n      #endif\n     #else\n    \tp.x += rot.x*4.;\n\t\tp.y += rot.y*4.;\n \t #endif\n    #endif\n    #ifdef OUTSIDE\n    vec2\trot1 = vec2( .54, .84 );\t\t\t\t// cos(1.), sin(1.)\n    p.xz *= mat2(rot1.x, rot1.y, -rot1.y, rot1.x);\n\t#endif\n\tmind = de_2(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 30.)\n        {\n            s.y = 1.;\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y;\n    return (s);\n}\n\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid main( void ) {\n\n\tmainImage(gl_FragColor,gl_FragCoord.xy);\n}", "user": "62c2e01", "parent": null, "id": "39017.2"}