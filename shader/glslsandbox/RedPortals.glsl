{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// consts\nconst float EPS = 1e-4;\nconst float OFFSET = EPS * 10.0;\nconst float PI = 3.14159;\nconst float INF = 1e+10;\n\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nconst vec3 backgroundColor = vec3( 0.0 );\nconst vec3 gateColor = vec3( 1.0, 0.1, 0.1 );\n\nconst float totalTime = 75.0;\n\n// globals\nvec3 cPos, cDir;\nfloat normalizedGlobalTime = 0.0;\n//vec3 illuminationColor;\n\nstruct Intersect {\n    bool isHit;\n\n    vec3 position;\n    float distance;\n    vec3 normal;\n\n    int material;\n    vec3 color;\n};\n    \nconst int BASIC_MATERIAL = 0;\nconst int MIRROR_MATERIAL = 1;\n\n\n// distance functions\nvec3 opRep( vec3 p, float interval ) {\n    return mod( p, interval ) - 0.5 * interval;\n}\n\nvec2 opRep( vec2 p, float interval ) {\n    return mod( p, interval ) - 0.5 * interval;\n}\n\nfloat opRep( float x, float interval ) {\n    return mod( x, interval ) - 0.5 * interval;\n}\n\nfloat sphereDist( vec3 p, vec3 c, float r ) {\n    return length( p - c ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat udFloor( vec3 p ){\n    float t1 = 1.0;\n    float t2 = 3.0;\n    float d = -0.5;\n    for( float i = 0.0; i < 3.0; i++ ) {\n        float f = pow( 2.0, i );\n    \td += 0.1 / f * ( sin( f * t1 * p.x + t2 * time ) + sin( f * t1 * p.z + t2 * time ) );\n    }\n\treturn dot(p,vec3(0.0,1.0,0.0)) - d;\n}\n\nfloat dGate( vec3 p ) {\n    p.y -= 1.3 * 0.5;\n    \n    float r = 0.05;\n    float left  = sdCappedCylinder( p - vec3( -1.0, 0.0, 0.0 ),  vec2(r, 1.3));\n    float right = sdCappedCylinder( p - vec3( 1.0,  0.0, 0.0 ),  vec2(r, 1.3));\n\n    float ty = 0.02 * p.x * p.x;\n    float tx = 0.5 * ( p.y - 1.3 );\n    float katsura  = udBox( p - vec3( 0.0, 1.3 + ty, 0.0 ), vec3( 1.7 + tx, r * 2.0 + ty, r ) );\n\n    float kan = udBox( p - vec3( 0.0, 0.7, 0.0 ), vec3( 1.3, r, r ) );\n    float gakuduka = udBox( p - vec3( 0.0, 1.0, 0.0), vec3( r, 0.3, r ) );\n\n    return min( min( left, right ), min( gakuduka, min( katsura, kan ) ) );\n}\n\nfloat dRepGate( vec3 p ) {\n    if ( normalizedGlobalTime <= 0.5 ) {\n        p.z = opRep( p.z, 1.0 + 20.0 * cos( PI * normalizedGlobalTime ) );\n    } else {\n        p.xz = opRep( p.xz, 10.0  );\n    }\n    return dGate( p );\n}\n\nfloat sceneDistance( vec3 p ) {\n    return udFloor( p );\n}\n\n\n// color functions\nvec3 hsv2rgb( vec3 c ) {\n\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n\n}\n\nIntersect minIntersect( Intersect a, Intersect b ) {\n    if ( a.distance < b.distance ) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nIntersect sceneIntersect( vec3 p ) {\n\n    Intersect a;\n    a.distance = udFloor( p );\n    a.material = MIRROR_MATERIAL;\n    // return minIntersect( a, b );\n    return a;\n}\n\nvec3 getNormal( vec3 p ) {\n\tvec2 e = vec2( 1.0, -1.0 ) * 0.001;\n\treturn normalize(\n\t\te.xyy * sceneDistance( p + e.xyy ) + e.yyx * sceneDistance( p + e.yyx ) + \n\t\te.yxy * sceneDistance( p + e.yxy ) + e.xxx * sceneDistance( p + e.xxx ) );\n}\n\nfloat getShadow( vec3 ro, vec3 rd ) {\n\n    float h = 0.0;\n    float c = 0.0;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n\n    for ( float t = 0.0; t < 50.0; t++ ) {\n\n        h = sceneDistance( ro + rd * c );\n\n        if ( h < EPS ) return shadowCoef;\n\n        r = min( r, h * 16.0 / c );\n        c += h;\n\n    }\n\n    return 1.0 - shadowCoef + r * shadowCoef;\n\n}\n\nIntersect getRayColor( vec3 origin, vec3 ray ) {\n\n    // marching loop\n    float d, minDist, trueDepth;\n    float distance = 0.0;\n    vec3 p = origin;\n    int count = 0;\n    Intersect nearest;\n\n    // first pass (water)\n    for ( int i = 0; i < 120; i++ ){\n\n        d = sceneDistance( p );\n        distance += d;\n        p = origin + distance * ray;\n\n        count = i;\n        if ( abs(d) < EPS ) break;\n\n    }\n\n    if ( abs(d) < EPS ) {\n\n        nearest = sceneIntersect( p );\n        nearest.position = p;\n        nearest.normal = getNormal(p);\n        nearest.distance = distance;\n        float diffuse = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );\n        float specular = pow( clamp( dot( reflect( lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 6.0 );\n        //float shadow = getShadow( p + nearest.normal * OFFSET, lightDir );\n\n        if ( nearest.material == BASIC_MATERIAL ) {\n        } else if ( nearest.material == MIRROR_MATERIAL ) {\n            nearest.color = vec3( 0.5, 0.7, 0.8 ) * diffuse + vec3( 1.0 ) * specular;\n        }\n\n        nearest.isHit = true;\n\n    } else {\n\n        nearest.color = backgroundColor;\n        nearest.isHit = false;\n\n    }\n    nearest.color = clamp( nearest.color - 0.1 * nearest.distance, 0.0, 1.0 );\n\n    // second pass (gates)\n    p = origin;\n    distance = 0.0;\n    minDist = INF;\n    for ( int i = 0; i < 20; i++ ){\n        d = dRepGate( p );\n        minDist = min(d, minDist);\n        /*if ( d < minDist ) {\n            minDist = d;\n            trueDepth = distance;\n        }*/\n        distance += d;\n        p = origin + distance * ray;\n        if ( i == 9 && normalizedGlobalTime <= 0.5 ) {\n            break;\n        }\n    }\n\n    if ( abs(d) < EPS ) {\n        nearest.color += gateColor;\n    } else {\n        nearest.color += gateColor * clamp( 0.05 / minDist, 0.0, 1.0 );\n    }\n\n    return nearest;\n\n}\n\nvoid main( void ) {\n    normalizedGlobalTime = mod( time / totalTime, 1.0 );\n\n    // fragment position\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution.xy ) / min(  resolution.x,  resolution.y );\n\n    // camera and ray\n    if ( normalizedGlobalTime < 0.7 ) {\n        cPos = vec3( 0.0, 0.6 + 0.4 * cos( time ), 3.0 * time );\n        cDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    } else {\n        cPos = vec3( 0.0, 0.6 + 0.4 * cos( time ) + 50.0 * ( normalizedGlobalTime - 0.7 ), 3.0 * time );\n        cDir = normalize( vec3( 0.0, -0.1 - ( normalizedGlobalTime - 0.7 ), 1.0 ) );\n    }\n    vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );\n    vec3 cUp   = normalize( cross( cSide, cDir ) );\n    float targetDepth = 1.3;\n    vec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );\n\n    // Illumination Color\n    // illuminationColor = hsv2rgb( vec3( time * 0.02 + 0.6, 1.0, 1.0 ) );\n\n    vec3 color = vec3( 0.0 );\n    float alpha = 1.0;\n    Intersect nearest;\n\n    for ( int i = 0; i < 3; i++ ) {\n\n        nearest = getRayColor( cPos, ray );\n\n        color += alpha * nearest.color;\n        alpha *= 0.5;\n        ray = normalize( reflect( ray, nearest.normal ) );\n        cPos = nearest.position + nearest.normal * OFFSET;\n\n        if ( !nearest.isHit || nearest.material != MIRROR_MATERIAL ) break;\n\n    }\n\n    gl_FragColor  = vec4(color, 1.0);\n\n}", "user": "d84f96d", "parent": "/e#39638.0", "id": "39784.1"}