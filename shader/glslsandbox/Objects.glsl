{"code": "// Shader by Nicolas Robert [NRX]\n// Latest version: http://glsl.heroku.com/e#14872\n// Forked from: https://www.shadertoy.com/view/lsXXz8\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\n#define DELTA\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t50.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\tvec3 (0.5, 0.75, 1.0)\n#define BACK_COLOR\t\tvec3 (0.25, 0.5, 1.0)\n#define AMBIENT\t\t\t0.2\n#define SPECULAR_POWER\t\t4.0\n#define SPECULAR_INTENSITY\t0.5\n#define REFLECT_COUNT\t\t2\n#define FADE_POWER\t\t2.0\n#define GAMMA\t\t\t(1.0 / 2.2)\n#define M_PI\t\t\t3.1415926535897932384626433832795\n\n#define SHADOW\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\nfloat sphere (in vec3 p, in float r) {\n\treturn length (p) - r;\n}\n\nfloat box (in vec3 p, in vec3 b, in float r) {\n\tvec3 d = abs (p) - b + r;\n\treturn min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0)) - r;\n}\n\nfloat plane (in vec3 p, in vec3 n, in float d) {\n\treturn dot (p, normalize (n)) + d;\n}\n\nfloat torusZ (in vec3 p, in float r1, in float r2) {\n\tvec2 q = vec2 (length (p.xy) - r1, p.z);\n\treturn length (q) - r2;\n}\n\nfloat cylinderX (in vec3 p, in float r) {\n \treturn length (p.yz) - r;\n}\n\nfloat cylinderY (in vec3 p, in float r) {\n \treturn length (p.xz) - r;\n}\n\nvec3 twistY (in vec3 p, in float k, in float angle) {\n\treturn vRotateY (p, angle + k * p.y);\n}\n\nfloat fixDistance (in float d, in float correction, in float k) {\n\tcorrection = max (correction, 0.0);\n\tk = clamp (k, 0.0, 1.0);\n\treturn min (d, max ((d - DELTA) * k + DELTA, d - correction));\n}\n\nfloat getDistance (in vec3 p, out vec4 q) {\n\n\t// Ground\n\tvec3 q_ = p;\n\tq_.z += 0.8 * (sin (time + p.x * 0.5) + sin (p.y * 0.5));\n\tfloat dist = fixDistance (plane (q_, vec3 (-0.2, 0.0, 1.0), 5.0), 0.6, 0.8); // need to fix the distance because of the sine deformation\n\tq = vec4 (q_, 0.0);\n\n\t// Twisted box\n\tq_ = p;\n\tq_.x -= 5.0;\n\tq_ = twistY (q_, cos (time), time);\n\tfloat dist_ = box (q_, vec3 (1.0, 1.0, 1.0), 0.1); // no need to fix the distance here, despite of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 1.0);\n\t\tdist = dist_;\n\t}\n\n\t// Simple box\n\tq_ = p;\n\tq_.y -= 3.0;\n\tq_ = mRotate (vec3 (0.7, 0.0, -0.2)) * q_;\n\tdist_ = box (q_, vec3 (1.0, 0.5, 1.0), 0.3);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 2.0);\n\t\tdist = dist_;\n\t}\n\n\t// Sphere\n\tq_ = p + vec3 (3.0, -1.0, sin (time * 2.0) - 1.0);\n\tdist_ = sphere (q_, 1.0);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 3.0);\n\t\tdist = dist_;\n\t}\n\n\t// Twisted torus\n\tq_ = p;\n\tq_.y += 4.0;\n\tq_ = twistY (q_, 2.0, 0.0);\n\tdist_ = fixDistance (torusZ (q_, 1.0, 0.3), 0.8, 0.5); // need to fix the distance because of the twist\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 4.0);\n\t\tdist = dist_;\n\t}\n\n\t// Cylinders\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.y = mod (q_.y, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderX (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 5.0);\n\t\tdist = dist_;\n\t}\n\tq_ = p;\n\tq_.z += 2.0;\n\tq_.x = mod (q_.x, 5.0) - 0.5 * 5.0;\n\tdist_ = cylinderY (q_, 0.2);\n\tif (dist_ < dist) {\n\t\tq = vec4 (q_, 6.0);\n\t\tdist = dist_;\n\t}\n\n\t// Smallest distance\n\treturn dist;\n}\n\nvec3 getObjectColor (in vec4 q, out float reflection) {\n\tfloat tint = 0.6 + 0.4 * sin (q.x * 10.0) * sin (q.y * 10.0) * sin (q.z * 10.0);\n\tif (q.w < 0.5) {\n\t\treflection = 0.0;\n\t\treturn (0.6 + 0.4 * tint) * vec3 (0.2, 1.0, 1.0);\n\t}\n\tif (q.w < 1.5) {\n\t\treflection = 0.2;\n\t\treturn tint * vec3 (1.0, 0.0, 0.0);\n\t}\n\tif (q.w < 2.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (0.0, 0.0, 1.0);\n\t}\n\tif (q.w < 3.5) {\n\t\treflection = 0.5;\n\t\treturn tint * vec3 (1.0, 1.0, 0.0);\n\t}\n\tif (q.w < 4.5) {\n\t\treflection = 0.0;\n\t\treturn tint * vec3 (1.0, 0.2, 0.5);\n\t}\n\treflection = 0.0;\n\treturn tint * vec3 (0.5, 0.5, 0.6);\n}\n\nvec3 getNormal (in vec3 p) {\n\tvec4 q;\n\tvec2 h = vec2 (DELTA, 0.0);\n\treturn normalize (vec3 (\n\t\tgetDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),\n\t\tgetDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),\n\t\tgetDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)\n\t));\n}\n\nvoid main () {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * gl_FragCoord.xy - resolution) / resolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tfloat angle = M_PI * sin (0.1 * time);\n\tvec3 origin = vec3 (10.0 * cos (angle), 10.0 * sin (angle), 2.5);\n\tdirection = mRotate (vec3 (M_PI / 2.0 + 0.45, 0.0, angle - M_PI / 2.0)) * direction;\n\n\t// Compute the fragment color\n\tvec3 lightDirection = normalize (LIGHT);\n\tfloat moveAway = DELTA * 10.0;\n\n\tvec3 color = vec3 (0.0, 0.0, 0.0);\n\tfloat absorb = 1.0;\n\tfloat fade = 0.0;\n\tfor (int reflectionIndex = 0; reflectionIndex < REFLECT_COUNT; ++reflectionIndex) {\n\n\t\t// Ray marching\n\t\tvec4 objectInfo;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (origin, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += dist * direction;\n\t\t}\n\n\t\t// Combine colors\n\t\tif (reflectionIndex == 0) {\n\t\t\tfade = pow (max (0.0, 1.0 - rayLength / RAY_LENGTH_MAX), FADE_POWER);\n\t\t} else {\n\t\t\tcolor *= 1.0 - absorb;\n\t\t}\n\t\tif (rayLength > RAY_LENGTH_MAX) {\n\t\t\tcolor += BACK_COLOR * absorb;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the object color\n\t\tfloat reflection;\n\t\tvec3 objectColor = getObjectColor (objectInfo, reflection);\n\n\t\t// Lighting\n\t\tvec3 normal = getNormal (origin);\n\t\tdirection = reflect (direction, normal);\n\n\t\t#ifdef SHADOW\n\t\tvec3 p = origin + moveAway * lightDirection;\n\t\trayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tfloat dist = getDistance (p, objectInfo);\n\t\t\trayLength += dist;\n\t\t\tif (dist < DELTA || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp += dist * lightDirection;\n\t\t}\t\t\n\t\tif (rayLength < RAY_LENGTH_MAX) {\n\t\t\tobjectColor *= AMBIENT;\n\t\t}\n\t\telse\n\t\t#endif\n\t\t{\n\t\t\tfloat diffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat specular = pow (max (0.0, dot (direction, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tobjectColor = (AMBIENT + diffuse) * objectColor + specular;\n\t\t}\n\t\tcolor += objectColor * absorb;\n\n\t\t// Next ray...\n\t\tif (reflection < DELTA) {\n\t\t\tbreak;\n\t\t}\n\t\tabsorb *= reflection;\n\t\torigin += moveAway * direction;\n\t}\n\n\t// Fading\n\tcolor = mix (BACK_COLOR, color, fade);\n\n\t// Gamma correction\n\tcolor = pow (color, vec3 (GAMMA));\n\n\t// Set the fragment color\n\tgl_FragColor = vec4 (color, 1.0);\n}", "user": "c7ac4f5", "parent": "/e#14825.2", "id": "14872.22"}