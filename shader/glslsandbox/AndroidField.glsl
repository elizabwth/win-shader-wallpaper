{"code": "// distance field ray caster\n// simon green 06/01/2011\n// \n// based on Inigo Quilezles's:\n// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n// http://www.iquilezles.org/apps/shadertoy/\n// \n// Google Android robot:\n// http://www.android.com/branding.html\n// fixed bug with Chrome\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat plane(vec3 p, vec3 planeN, vec3 planePos)\n{\n    return dot(p - planePos, planeN);\n}\n\nfloat box(vec3 p, vec3 abc )\n{\n    vec3 di=max(abs(p)-abc, 0.0);\n    //return dot(di,di);\n    return length(di);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\n// given segment ab and point c, computes closest point d on ab\n// also returns t for the position of d, d(t) = a + t(b-a)\nvec3 closestPtPointSegment(vec3 c, vec3 a, vec3 b, out float t)\n{\n    vec3 ab = b - a;\n    // project c onto ab, computing parameterized position d(t) = a + t(b-a)\n    t = dot(c - a, ab) / dot(ab, ab);\n    // clamp to closest endpoint\n    t = clamp(t, 0.0, 1.0);\n    // compute projected position\n    return a + t * ab;\n}\n\n// generic capsule\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    float t;\n    vec3 c = closestPtPointSegment(p, a, b, t);\n    return length(c - p) - r;\n}\n\nfloat cylinderY(vec3 p, float r, float h)\n{\n     float d = length(vec2(p.x, p.z)) - r;\n     d = difference(d, plane(p, vec3(0.0, -1.0, 0.0), vec3(0.0, h, 0.0)));\n     d = difference(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0)));\n     return d;\n}\n\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\n\nfloat halfSphere(vec3 p, float r)\n{\n    return difference( \n               sphere(p, r),\n               plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0)) );\n}\n\n// distance to scene\nfloat scene(vec3 p)\n{\n#if 1\n    // army of droids\n    p += vec3(-3.0, 0.0, -3.0);\n    p.x = mod(p.x, 6.0);\n    p.z = mod(p.z, 6.0);\n    p -= vec3(3.0, 0.0, 3.0);\n#endif\t\n\np.x = abs(p.x);  // mirror in X to reduce no. of primitives\t\n\t\n    float d = 1e10;\n\n    p -= vec3(0.0, 1.0, 0.0);\n    //vec3 hp = rotateY(p, sin(time*0.5)*0.5);\n\tvec3 hp = p;\n\n    // head\n    //d = sphere(p, 1.0);\n    d = halfSphere(hp, 1.0);\n\n    // eyes\n    //d = _union(d, sphere(hp - vec3(-0.3, 0.3, 0.9), 0.1));\n    d = _union(d, sphere(hp - vec3(0.3, 0.3, 0.9), 0.1));\n\n    // antenna\n    //d = _union(d, capsule(hp, vec3(-0.4, 0.7, 0.0), vec3(-0.75, 1.2, 0.0), 0.05));\n    d = _union(d, capsule(hp, vec3(0.4, 0.7, 0.0), vec3(0.75, 1.2, 0.0), 0.05));\n\n    // body\n    d = _union(d, capsuleY((p*vec3(1.0, 4.0, 1.0) - vec3(0.0, -4.6, 0.0)), 1.0, 4.0));\n    //d = _union(d, cylinderY(p - vec3(0.0, -1.1, 0.0), 1.0, 1.0));\n\n    // arms\n    //d = _union(d, capsuleY(p - vec3(-1.2, -0.9, 0.0), 0.2, 0.7));\n    //d = _union(d, capsuleY(p - vec3(1.2, -0.9, 0.0), 0.2, 0.7));\n    //d = _union(d, capsuleY(rotateX(p, cos(time)) - vec3(-1.2, -0.9, 0.0), 0.2, 0.7));\n    d = _union(d, capsuleY(rotateX(p, sin(time)) - vec3(1.2, -0.9, 0.0), 0.2, 0.7));\n\n    // legs\n    //d = _union(d, capsuleY(p - vec3(-0.4, -1.8, 0.0), 0.2, 0.5));\n    d = _union(d, capsuleY(p - vec3(0.4, -1.8, 0.0), 0.2, 0.5));\n\n    // floor\n    p += vec3(0.0, 1.0, 0.0);\n    d = _union(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, -1.0, 0.0)));\n\n    return d;\n}\n\n// calculate scene normal\nvec3 sceneNormal( in vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - scene( vec3(pos.x, pos.y-eps, pos.z) );\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    const vec3 lightPos = vec3(5.0, 10.0, 5.0);\n    const vec3 color = vec3(0.643, 0.776, 0.223);\n    const float shininess = 100.0;\n\n    vec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    float diff = dot(n, l);\n    float spec = max(0.0, pow(dot(n, h), shininess)) * float(diff > 0.0);\n    //diff = max(0.0, diff);\n    diff = 0.5+0.5*diff;\n\n    float fresnel = pow(1.0 - dot(n, v), 5.0);\n    float ao = ambientOcclusion(pos, n);\n\n//    return vec3(diff*ao) * color + vec3(spec + fresnel*0.5);\n    return vec3(diff*ao) * color + vec3(spec);\n//    return vec3(ao);\n//    return vec3(fresnel);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    const int maxSteps = 128;\n    const float hitThreshold = 0.001;\n    hit = false;\n    vec3 pos = ro;\n    vec3 hitPos = ro;\n\n    for(int i=0; i<maxSteps; i++)\n    {\n        float d = scene(pos);\n        if (d < hitThreshold) {\n            hit = true;\n            hitPos = pos;\n            //return pos;\n        }\n        pos += d*rd;\n    }\n    return hitPos;\n}\n\nvec3 background(vec3 rd)\n{\n     //return mix(vec3(1.0), vec3(0.0), rd.y);\n     return mix(vec3(1.0), vec3(0.0, 0.25, 1.0), rd.y);\n     //return vec3(0.0);\n}\n\nvoid main(void)\n{\n    vec2 pixel = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\n\n    // compute ray origin and direction\n    float asp = resolution.x / resolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.5, 4.5);\n\n    float a;\n    a = sin(time*0.3)*1.5;\n    rd = rotateY(rd, a);\n    ro = rotateY(ro, a);\n    a = sin(time*0.25)*0.3;\n    rd = rotateX(rd, a);\n    ro = rotateX(ro, a);\n\n    // trace ray\n    bool hit;\n    vec3 pos = trace(ro, rd, hit);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n        rgb = shade(pos, n, ro);\n\n#if 1\n        // reflection\n        vec3 v = normalize(ro - pos);\n        float fresnel = 0.1 + 0.4*pow(1.0 - dot(n, v), 5.0);\n\n        ro = pos + n*0.01; // offset to avoid self-intersection\n        rd = reflect(-v, n);\n        pos = trace(ro, rd, hit);\n\n        if (hit) {\n            vec3 n = sceneNormal(pos);\n            rgb += shade(pos, n, ro) * vec3(fresnel);\n        } else {\n            rgb += background(rd) * vec3(fresnel);\n        }\n#endif \n\n     } else {\n        rgb = background(rd);\n     }\n\n    // vignetting\n    rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\n    gl_FragColor=vec4(rgb, 1.0);\n}", "user": "68754d0", "parent": "/e#399.0", "id": "2922.2"}