{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI 3.14159265359\n#define TWOPI (2.0 * PI)\n#define MOUTHCLOSE_FREQ 2.82\n#define R 8.0\n#define ORIG_Z\t2.0*R\n#define GRID_Z\tORIG_Z-2.0\n#define TIMESCALE 1.0\n\n#define SMOOTHERSTEP01(x_) dot(vec3(10.0,-15.0,6.0), pow(vec3(x_), vec3(3.0,4.0,5.0)))\n\nstruct Ray {\n\tvec3 p;\n\tvec3 d;\n};\n\n   \n\n//\tx: pan amount\n//\ty: perspective amount\n// \tz: mouth close amount\nvec3 prp;\n\nbool coll_pacman(in vec3 q) {\n\tq.z *= 2.5; // bit thinner pacman\n\treturn (dot(q, q) < R * R)\n\t\t&& (prp.z <= (abs(q.y) + 1.05) / max(1.0, q.x + 5.0));\n}\n\nbool coll_pill(in vec3 q) {\n\tvec3 pill = q;\n\tpill.x = floor(2.0 * R * fract(pill.x * (0.5 / R) + time * MOUTHCLOSE_FREQ) - R + 2.0);\n\tpill += 0.5;\n\treturn (dot(pill, pill) <= 1.0) && (2.0 <= q.x);\n}\n\nbool coll_level(in vec3 q) {\n\treturn (abs(abs(q.y) - 1.50 * R) <= 0.8);\n}\n\nbool coll(in vec3 p) {\n\tvec3 q = floor(p + vec3(0.0,0.0,-ORIG_Z));\n\treturn coll_pacman(q) || coll_level(q) || coll_pill(q);\n}\n\nbool traverse_step(inout vec3 t, inout float fact, in vec3 div, in Ray ray) {\n\t// min of components gets the projection factor for the ray to reach cell border\n\tfact = min(t.x, min(t.y, t.z));\n\t// calculate next projection to intersection as min of xyz\n\tt += step(t.xyz, t.yxy) * step(t.xyz, t.zzx) * div;\n\t// check for collision and get color\n\treturn (coll(ray.p + fact * ray.d));\n}\n\n#define STEP() if (traverse_step(t, fact, div, ray)) return fact\n#define STEP2() STEP(); STEP()\n#define STEP4() STEP2(); STEP2()\n\nfloat traverse(in Ray ray) {\n\tvec3 t;\n\tfloat fact;\n\tvec3 div = vec3(1.0) / ray.d; // for projection\n\n\tif (coll(ray.p)) return 0.0;\n\n\t// calculate initial projection to intersection as difference from ray.p to\n\t// an intersection, which is based from floor(ray.p) and offseted with\n\t// ceil(ray.d) (which always yields xyz={0,1} when -1<=xyz<=1)\n\tt = ((floor(ray.p) + ceil(ray.d)) - ray.p) * div;\n\tray.p += 1e-4 * ray.d; // slight adjust to get inside cell\n\tdiv = abs(div); // following steps are unsigned\n\t\n\tSTEP4();\n\tSTEP4();\n\tSTEP4();\n\t\n\treturn R;\n}\n\nmat3 lookat_lh(in Ray cam, in vec3 up) {\n\tvec3 uz = normalize(cam.d - cam.p);\n\tvec3 ux = normalize(cross(up, uz));\n\tvec3 uy = cross(uz, ux);\n\treturn mat3(ux,uy,uz);\n}\n\nvec3 n_from_d(in vec3 d) {\n\tvec3 ad = abs(d);\n\t// get normal as max of xyz and apply sign\n\treturn (sign(d)\t\t\t\t\t// not normalized\n\t\t\t* step(ad.yxy, ad.xyz)\n\t\t\t* step(ad.zzx, ad.xyz)\n\t);\n}\n\nvoid main() {\n\tprp = vec3(\n\t\tvec2(SMOOTHERSTEP01(0.5 - 0.5 * cos(0.51 * time - 0.125 * PI))),\n\t\t0.5 - 0.5 * sin(TWOPI * MOUTHCLOSE_FREQ * time)\n\t);\n\n\tvec2 uv = 2.0 * (gl_FragCoord.xy / resolution.xy) - 1.0;\n\tuv.x *= resolution.x / resolution.y;\n\t\n\t// manual inspection\n\t \n\t\n\t// setup ray/camera and rotate\n\tRay ray = Ray(\n\t\tR * mix(vec3(1.0,0.1,0.0), vec3(4.45,0.5,0.0), prp.x),\n\t\tR * mix(vec3(1.0,0.1,1.0), vec3(4.00,0.4,1.1), prp.x)\n\t);\n\tmat3 rot = lookat_lh(ray, vec3(0.0,1.0,0.0));\n\tray.d = normalize(vec3(uv * (1e-4 + 0.4 * prp.y),0.5));\n\tray.p += 2.0 * R * (1.0 - prp.y) * vec3(uv,0.0);\t\n\tray.d = rot * ray.d;\n\t\n\t// project ray to grid wall\n\tfloat t = (GRID_Z - ray.p.z) / ray.d.z;\n\tray.p += t * ray.d;\n\t\n\tt = traverse(ray);\n\t\n\t// calc shading\n\tray.p += (t + 1e-5) * ray.d;\t\t// move slighty inside cell\n\tvec3 n = n_from_d(fract(ray.p) - 0.5);\n\tfloat ldiff = 0.65 - 0.35 * min(0.0, dot(n, ray.d));\n\tfloat lfade = max(0.0, 1.0 - (t / (0.80*R)));\n\t\n\t// determine color\n\tvec3 c = vec3(\n\t\tvec2(step(abs(ray.p.y), R)),\n\t\tfloat(coll_pill(floor(ray.p + vec3(0.0,0.0,-ORIG_Z))))\n\t);\n\tc.b += 1.0 - c.r;\n\n\tc *= lfade * ldiff;\t\t\t\t\t// shade\n\tc += (0.11 + 0.018 * abs(uv.x));\t// add greyish bg\n\tc *= (1.39 - 0.24 * dot(uv,uv));\t// darken\n\t\n\tgl_FragColor = vec4(c,1.0);\n}\n", "user": "b9e8db2", "parent": null, "id": "28497.1"}