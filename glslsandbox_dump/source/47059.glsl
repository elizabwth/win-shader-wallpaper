{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4scBW2\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 1.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 2.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 2;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n    \n    // get if bit is on for this pixel in the glyph\n    // 0x01110, 0x01110, \n\t// 0x11011, 0x11110,\n\t// 0x11011, 0x01110, \n\t// 0x11011, 0x01110,\n\t// 0x01110, 0x11111\n\t//  0        1\n    \n    if (g == 0)\n    {\n     \tif (pos.x > 0 && pos.x < 4 && (pos.y == 0 || pos.y == 4))\n            return 1;\n     \tif (pos.y > 0 && pos.y < 4 && pos.x != 2)\n            return 1;\n  \t    return 0;\n    }\n    else\n    {\n        if (pos.x == 0 && (pos.y == 4 || pos.y == 2 || pos.y == 1))\n            return 0;\n        if (pos.x == 4 && pos.y > 0)\n            return 0;\n        return 1;\n    }\n    \n    return 0;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst float gsfi = 1.0 / glyphSizeF;\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3(1.0);\n        \n    myColor.r *= mix(0.3, 1.0, RandFloat(i + r + 11*glyphPosLast.x + 13*glyphPosLast.y));\n    myColor.b *= mix(0.3, 1.0, RandFloat(i + r + 17*glyphPosLast.x + 19*glyphPosLast.y));\n    myColor *= mix(0.2, 0.7, RandFloat(i + r + 31*glyphPosLast.x + 37*glyphPosLast.y));\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // brighten\n    color += vec3(0.05);\n    \n    // make green\n    color *= vec3(0.7, 1.0, 0.7);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\tuv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint imod(int a, int b) { return int(mod(float(a), float(b))); }\nint GetFocusGlyph(int i) { return imod(RandInt(i), glyphCount); }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 18;\t// OPT - 1 and 0 glyps both have 18 pixels\n\n    // find a random valid pixel in glyph\n    c -= imod(RandInt(iterations), c);\n    for (int y = 0; y < glyphSize; ++y)\n    for (int x = 0; x < glyphSize; ++x)\n    {\n            c -= GetGlyphPixel(ivec2(x, y), g);\n            if (c == 0)\n                return ivec2(x, y);\n    }\n    \n    return ivec2(0);\n}\n  \nivec2 GetFocusPos(int i) { return CalculateFocusPos(i); }\n\nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return imod(RandInt(seed), glyphCount); \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(iterations-2);\n\tivec2 glyphPos =     GetFocusPos(iterations-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(iterations+r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n\treturn color;\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += ((vec2(GetFocusPos(iterations+i)) + vec2(glyphMargin)) * gsfi) * pow(gsfi, float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "98e81e8", "parent": null, "id": 47059}