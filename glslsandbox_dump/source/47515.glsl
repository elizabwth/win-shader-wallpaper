{"code": "// \"Over the Moon\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// GLSLSandbox implementation of Shadertoy's https://www.shadertoy.com/view/4s33zf\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#extension GL_OES_standard_derivatives : enable\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,b) S(x, x+b, z)*S(y+b, y, z)\n#define saturate(x) clamp(x,0.,1.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n#define MOONPOS vec2(1.3, .8)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n    // From Dave Hoskins\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a) / (b-a)) * (d-c) + c;\n}\n\nfloat within(float a, float b, float t) {\n\treturn (t-a) / (b-a); \n}\n\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n\tfloat y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    \n    float horizontal = B(left, right, uv.x, blur);\n    float vertical = B(bottom.z, top.z, uv.y, blur);\n    return horizontal*vertical;\n}\n\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n\tuv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);\n    \n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n   \n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    \n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    \n    return col;\n}\n\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\n\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n\tuv *= d;\n    float x = uv.x*PI*f+p;\n    float c = getheight(x)*a+y;\n    \n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    \n    float e = fwidth(uv.y);\n    \n    vec4 col = vec4(S(c+e, c-e, uv.y));\n    //col.rgb *= mix(0.9, 1., abs(uv.y-c)*20.);\n    \n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    \n    x = fract(x);\n    \n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus+d*.1);\n    //col += pineCol;\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);\n    \n    return saturate(col);\n}\n\nvec4 gradient(vec2 uv) {\n    \n\tfloat c = 1.-length(MOONPOS-uv)/1.4;\n    \n    vec4 col = vec4(c);\n    \n    return col;\n}\n\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n\tfloat dist = length(uv-pos);\n    return S(radius+blur, radius-blur, dist);\n}\n\nvec4 moon(vec2 uv) {\n   \tfloat c = circ(uv, MOONPOS, .07, .001);\n    \n    c *= 1.-circ(uv, MOONPOS+vec2(.03), .07, .001)*.95;\n    c = saturate(c);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.8;\n    \n    return col;\n}\n\nvec4 moonglow(vec2 uv, float foreground) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n    return col;\n}\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n    float t = time*.05;\n     \n    vec2 bgUV = uv*vec2(resolution.x/resolution.y, 1.);\n    vec4 col = gradient(bgUV)*.8;\n    col += moon(bgUV);\n    col += stars(uv, t);\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.);\n        trees = mix(trees, layer, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    col = mix(col, trees, trees.a);\n    \n    col += moonglow(bgUV, 1.);\n    col = saturate(col);\n    \n    vec4 foreground = landscape(uv, .02, t, 3., .0, -0.04, 1., .1);\n    foreground.rgb *= vec3(.1, .1, .2)*.5;\n    \n    col = mix(col, foreground, foreground.a);\n    \n    gl_FragColor = vec4(col);\n}", "user": "f5c9d4f", "parent": null, "id": 47515}