{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/MdGfWm\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n\n\n#define mul(a,b) ((b)*(a))\n#define saturate(a) clamp(a,0.0,1.0)\n\nstruct ObjectData\n{\n    float     distance;\n    float     materialId;\n    mat4      world2LocalMatrix;\n};\n\n#define Degree2Raduis(a) ((a) * 3.1415926 / 180.0)\n#define Raduis2Degree(a) ((a) * 180.0 / 3.1415926)\n\nfloat max2(vec2 a)\n{\n    return max(a.x,a.y);\n}\n\nfloat min2(vec2 a)\n{\n    return min(a.x,a.y);\n}\n\nfloat max3(vec3 a)\n{\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat min3(vec3 a)\n{\n    return min(a.x,min(a.y,a.z));\n}\n\nfloat max4(vec4 a)\n{\n    return max(a.x,max(a.y,max(a.z,a.w)));\n}\n\nfloat min4(vec4 a)\n{\n    return min(a.x,min(a.y,min(a.z,a.w)));\n}\n\nvec3 RGBtoHSV(vec3 arg1)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 P = mix(vec4(arg1.bg, K.wz), vec4(arg1.gb, K.xy), step(arg1.b, arg1.g));\n    vec4 Q = mix(vec4(P.xyw, arg1.r), vec4(arg1.r, P.yzx), step(P.x, arg1.r));\n    float D = Q.x - min(Q.w, Q.y);\n    float E = 1e-10;\n    return vec3(abs(Q.z + (Q.w - Q.y) / (6.0 * D + E)), D / (Q.x + E), Q.x);\n}\n\nvec3 HSVtoRGB(vec3 arg1)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 P = abs(fract(arg1.xxx + K.xyz) * 6.0 - K.www);\n    return arg1.z * mix(K.xxx, clamp(P - K.xxx,0.0,1.0), arg1.y);\n}\n\nvoid sincos(float a,out float si,out float co)\n{\n    si = sin(a);\n    co = cos(a);\n}\n\nmat3 FromEuler(vec3 ang) \n{   \n    vec2 a1,a2,a3;\n    sincos(Degree2Raduis(ang.x),a1.x,a1.y);\n    sincos(Degree2Raduis(ang.y),a2.x,a2.y);\n    sincos(Degree2Raduis(ang.z),a3.x,a3.y);\n\n    mat3 m;\n    m[0] = vec3(a3.y*a2.y,-a3.x*a2.y,a2.x);\n    m[1] = vec3(a3.x*a1.y + a1.x*a2.x*a3.y,a3.y*a1.y - a1.x*a2.x*a3.x,-a1.x*a2.y);\n    m[2] = vec3(a1.x*a3.x - a1.y*a2.x*a3.y,a3.y*a1.x + a1.y*a2.x*a3.x,a1.y*a2.y);\n    return m;\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang,vec3 scale)\n{   \n    mat3 rot = FromEuler(ang);\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    return mul(rot,p);\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang)\n{\n    return mul(FromEuler(ang),p);\n}\n\nmat3 SetCamera(vec3 ro,vec3 ta)\n{\n    vec3 rz = normalize(ta - ro);\n    vec3 p = vec3(0.0, 1.0, 0.0);\n    vec3 rx = normalize(cross(rz,p));\n    vec3 ry = normalize(cross(rz,rx));\n\n    return mat3(-rx,ry,rz);\n}\n\n//Union\nfloat OpU(float o1,float o2)\n{\n    return min(o1,o2);\n}\n\n//Smooth Union\nfloat OpSU(float o1,float o2,float k)\n{\n    float h = clamp( 0.5+0.5*(o2-o1) / k, 0.0, 1.0 );\n    return mix( o2, o1, h ) - k*h*(1.0-h);\n}\n\n//Smooth Intersection\nfloat OpSI(float o1,float o2,float k)\n{\n    return -OpSU(-o1,-o2,k);\n}\n\n//subtract\nfloat OpS(float o1,float o2)\n{\n    return max(o1,-o2);\n}\n\n//Intersection\nfloat OpI(float o1,float o2)\n{   \n    return max(o1,o2);\n}\n\n//Union\nvec2 OpU2(vec2 o1,vec2 o2)\n{\n    return o1.x < o2.x ? o1 : o2;\n}\n\nObjectData OpU_OD(ObjectData o1,ObjectData o2)\n{\n    if(o1.distance < o2.distance)\n    {\n        return o1;\n    }\n    return o2;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCone3( vec3 p,vec2 h)\n{\n    float apy = p.y;\n    float st = (apy + h.y) / (h.y*2.0);\n\n    st = smoothstep(0.0,h.y,apy);\n\n    float  d = p.y;\n    d = clamp(d,-h.y,h.y);\n    p.y -= d;\n    return (length(p) - h.x * mix(0.0,1.0,st))* 0.8;\n}\n\n\nmat4 trs(vec3 translate,vec3 angle,vec3 scale)\n{\n    mat3 rot = FromEuler(angle);\n    mat4 mat;\n\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    mat[0] = vec4(rot[0],translate.x);\n    mat[1] = vec4(rot[1],translate.y);\n    mat[2] = vec4(rot[2],translate.z);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n\n    return mat;\n}\n\nvec3 mulMat(mat4 mat,vec3 p)\n{\n    vec4 p2 = mul(mat,vec4(p.xyz,1.0));\n    return p2.xyz;\n}\n\nObjectData createObject(float d,float m,mat4 w2l)\n{\n    ObjectData od;\n    od.distance = d;\n    od.materialId = m;\n    od.world2LocalMatrix = w2l;\n\n    return od;\n}\n\nObjectData createObject(float d,float m)\n{\n    mat4 w2l;\n    w2l[0] = vec4(1.0,0.0,0.0,0.0);\n    w2l[1] = vec4(0.0,1.0,0.0,0.0);\n    w2l[2] = vec4(0.0,0.0,1.0,0.0);\n    w2l[3] = vec4(0.0,0.0,0.0,1.0);\n    \n    return createObject(d,m,w2l);\n}\n\nObjectData SlimeObjective(vec3 p)\n{\n    vec3 rotate = vec3(0.0,0.0,0.0);\n    mat4 w2l = trs(vec3(0.0,0.0,0.0),rotate,vec3(2.1,1.0,2.1));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    vec3 p1 = localPos;\n    vec3 offset = vec3(0.0);\n    offset.x = 0.05*sin(iTime*10.0/2.0)*((0.8 - localPos.y)/0.8);\n    offset.y = 0.2*sin(iTime*10.0)*((0.8 - localPos.y)/0.8);\n    offset.z = offset.x;\n    p1 += offset;\n\n    vec3 p2 = p1 + vec3(0.049,-0.25,-0.11);\n    vec3 p3 = p1 + vec3(-0.049,-0.25,-0.11);\n\n    vec3 o1 = localPos;\n    vec3 o2 = localPos;\n\n    o1.y += 1.7*sin(o1.x/8.0);\n    o1.y += sin(iTime*10.0)*0.01;\n    o1.x += cos(iTime*10.0)*0.01;\n\n    vec3 p4 = o1 + offset + vec3(0.049,-0.24,-0.16);\n    vec3 p5 = o1 + offset + vec3(-0.049,-0.24,-0.16);\n    vec3 p6 = o2 + offset + vec3(0.0,-0.4,-0.18);\n\n    p6.y += 5.0*pow(p6.x,2.0);\n    p6.y -= offset.y*0.2;\n\n    ObjectData obj1_0 = createObject(sdCone3(p1,vec2(0.2,0.4)),11.0,w2l);\n    ObjectData obj2_0 = createObject(sdSphere(p2,0.05),3.0,w2l);\n    ObjectData obj2_1 = createObject(sdSphere(p3,0.05),3.0,w2l);\n    ObjectData obj3_0 = createObject(sdSphere(p4,0.02),10.0,w2l);\n    ObjectData obj3_1 = createObject(sdSphere(p5,0.02),10.0,w2l);\n    ObjectData obj4_1 = createObject(sdEllipsoid(p6,vec3(0.1,0.05,0.04)),12.0,w2l);\n\n    ObjectData obj = obj1_0;\n    obj4_1.distance = OpI(obj.distance,obj4_1.distance);\n    obj = OpU_OD(obj,obj4_1);\n    obj = OpU_OD(obj,obj2_0);\n    obj = OpU_OD(obj,obj2_1);\n    obj = OpU_OD(obj,obj3_0);\n    obj = OpU_OD(obj,obj3_1);\n\n    return obj;\n}\n\n\nObjectData ObjectsGroup(vec3 p)\n{   \n    ObjectData slime = SlimeObjective(p);\n    return slime;\n}\n\n#define RAYMARCH_STEP_NUM 256\nObjectData Raymarching(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 10.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float n = 0.5e-8;\n    mat4 w2l;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = n*t;\n        ObjectData res = ObjectsGroup( ro + rd*t );\n        if( res.distance < precis || t > tmax ) break;\n        t += res.distance;\n        m = res.materialId;\n        w2l = res.world2LocalMatrix;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    ObjectData data = createObject(t,m,w2l);\n\n    return data;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        ObjectsGroup(pos+eps.xyy).distance - ObjectsGroup(pos-eps.xyy).distance,\n        ObjectsGroup(pos+eps.yxy).distance - ObjectsGroup(pos-eps.yxy).distance,\n        ObjectsGroup(pos+eps.yyx).distance - ObjectsGroup(pos-eps.yyx).distance );\n\n    return normalize(nor);\n}\n\nvec4 RenderMaterial0(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor,1.0);\n}\n\nvec4 RenderMaterial4(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float rampSmooth = 0.005;\n    float threshold1 = 0.5;\n    float threshold2 = 0.2;\n    float rampThresholdBlend = 0.7;\n    float spec = 0.6;\n\n    float ramp1 = smoothstep(threshold1 - rampSmooth, threshold1,ndl);\n    float ramp2 = smoothstep(threshold2 - rampSmooth, threshold2,ndl);\n\n    float ramp = mix(0.0,mix(mix(threshold2,threshold1,rampThresholdBlend) ,1.0,ramp1),ramp2);\n\n\n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.1,0.3,0.3));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n    float specular = smoothstep(spec - rampSmooth,spec,pow(rdv,35.0));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0.0,0.0,0.0),diffuseColor + 0.15*specular,outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 RenderMaterial6(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float rampSmooth = 0.005;\n    float threshold1 = 0.5;\n    float threshold2 = 0.2;\n    float rampThresholdBlend = 0.7;\n    float spec = 0.2;\n\n    float ramp1 = smoothstep(threshold1 - rampSmooth, threshold1,ndl);\n    float ramp2 = smoothstep(threshold2 - rampSmooth, threshold2,ndl);\n\n    float ramp = mix(0.0,mix(mix(threshold2,threshold1,rampThresholdBlend) ,1.0,ramp1),ramp2);\n\n\n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.03,0.03,0.05));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n    float specular = smoothstep(spec - rampSmooth,spec,pow(rdv,6.0));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0.0,0.0,0.0),diffuseColor + specular,outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 RenderMaterial7(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float rim = smoothstep(0.8 - 0.01,0.8,pow(max(0.0,dot(normal,viewDir)*0.72+0.28),1.4478));\n\n    vec3 finalColor = mix(vec3(0,0,0),diffuseColor,rim);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 Render(vec3 orgPos,vec3 rayDir)\n{\n    vec4 color = vec4(0,0,0,0) ;\n\n    ObjectData result = Raymarching(orgPos, rayDir);\n    float  dist = result.distance;\n    float  material = result.materialId;\n\n    if(material >= 0.0)\n    {\n        mat4 w2l = result.world2LocalMatrix;\n        vec3 position = orgPos + rayDir * dist;\n        vec3 normal = CalcNormal(position);\n        vec3 lightDir = normalize(vec3(-1.9,-0.7,0.75));\n        vec3 diffColor = vec3(1,1,1);\n        vec3 uViewDir = -rayDir * dist;\n        vec3 localPos = mulMat(w2l,position);\n        float  shadow = 1.2;\n\n        mat4 w2l_2nd;\n        w2l_2nd[0]=vec4(1,0,0,w2l[0].w);\n        w2l_2nd[1]=vec4(0,1,0,w2l[1].w);\n        w2l_2nd[2]=vec4(0,0,1,w2l[2].w);\n        w2l_2nd[3]=vec4(0,0,0,1);\n        \n\n        vec3 localPos_2nd = mulMat(w2l_2nd,position);\n\n\n        if(material == 3.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderMaterial0(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 10.0)\n        {\n            diffColor = vec3(0,0,0);\n            color = RenderMaterial6(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 11.0)\n        {\n            diffColor = vec3(0,0.248,0.5);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 12.0)\n        {\n            diffColor = vec3(1,0.1,0.1);\n            color = RenderMaterial7(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n    }\n\n    return color;\n}\n\nvec3 pow3(vec3 a,float b)\n{\n    return vec3(pow(a.x,b),pow(a.y,b),pow(a.z,b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 canvasPos = fragCoord / iResolution.xy;\n    vec2 screenSize = iResolution.xy;\n    vec2 pos = canvasPos * screenSize;\n    vec2 orgPos = canvasPos * 2.0 - 1.0;\n    orgPos.y *= screenSize.y/screenSize.x;\n\n    vec3 cameraPos = vec3(0,0,3);\n    vec3 lookAtPos = vec3(0,0,0);\n\n    mat3 cameraMatrix = SetCamera(cameraPos,lookAtPos);\n\n    vec3 rayDir = mul(cameraMatrix,normalize(vec3(orgPos,1)));\n\n    vec4 skyBox = mix(vec4(1,1,1,1),vec4(0,0.3,1,1),pow(canvasPos.y,0.4));\n\n    vec4 color = Render(cameraPos,rayDir);\n\n    vec4 finialColor = vec4(mix(skyBox.rgb,color.rgb,color.a),skyBox.a);\n    finialColor.rgb = pow3(finialColor.rgb,1.1) + 0.55 * finialColor.rgb;\n    fragColor = finialColor;\n}\n\n\n\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "7d9efdc", "parent": null, "id": 47500}