{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4tKXzm\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nvec3  iMouse;\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define SPEED .1\n#define FOV 3.\n#define SLICES 12.\n#define CAKE_POS .15\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 50.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 20.\n#define LIGHT_COLOR vec3(0.3,.2,.23)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// repeat space along an axis\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// cylinder distance r - radius, l - height\nfloat sdCylinder(vec3 p, float r, float l) {\n    p.xy = vec2(abs(p.y) - l, length(p.xz) - r);\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.));\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// the icing on the cake\nfloat sdIcingOnTheCake(vec3 p) {\n    \n    // twist\n    tRotate(p.xz, p.y * 4.);\n    \n    // add an infinite box\n    float d = sdRect(p.xz, vec2(.4));\n    \n    // add another box, rotated by 45 degrees, smoothly\n    tRotate(p.xz, PI / 4.);\n    d = opSU(d, sdRect(p.xz, vec2(.4)), .1);\n    \n    // add a slope\n    d += p.y + .2;\n    \n    // divide the distance, because by now it has been ruined, then intersect smoothly with a sphere\n    d = -opSU(-d * .5, -sdSphere(p, .5), .1);\n    return d;\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n    // rounded cylinder for the cake\n    float r = .02;\n    float d = sdCylinder(p, .5 - r, .2 -r) - r;\n    \n    // blend in the icing\n    tFan(q.xz, SLICES);\n\td = opSU(d, sdIcingOnTheCake((q - vec3(.4, .328, 0)) * 5.) / 5., .4);\n    \n    // cut the cake\n    tRotate(p.xz, PI / SLICES);\n    float slice = p.z;\n    float a = PI*3.; //+fract((floor(iTime * SPEED * SLICES)) / SLICES - .5) * PI * 2.;\n    tRotate(p.xz, a);\n    slice = (a < PI) ? opU(slice, p.z) : opI(slice, p.z);\n    return opS(d, slice);\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = map(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 q = p;\n    q.y += .05;\n    tRepeat1(q.y, .095);\n    vec3 t = mix(fbm(fbm(p * 10.) + p * 10.) * vec3(1.5) + vec3(.5),\n                 fbm(p * 100.) * vec3(.5, .0, .0),\n\t\t 1. - saturate((opI(sdCylinder(p, .5, .175),\n\t\t\t\t    sdCylinder(q, .48, .035)) \n\t\t\t\t+ (fbm(p * 40.)- .75) * .02 ) * 10.));\n    return saturate(t);\n}\n\n// texture used for bump mapping\nfloat bumpTexture(vec3 p) {\n    vec3 q = p;\n    q.y += 2.5;\n    tRepeat1(q.y, 22.5);\n    float t = mix(fbm(fbm(p * 50.) + p * 10.) * 1.5 + .25,\n                fbm(p * 100.), 1. - \n                saturate((opI(sdCylinder(p, .5, .175),sdCylinder(q, .48, .035)) + (fbm(p * 100.)- .5) * .02 ) * 100.));\n    return saturate(t);\n}\n\n// bump mapping from Shane\nvec3 doBumpMap(vec3 p, vec3 nor, float bumpfactor) {\n    \n    vec2 e = vec2(.0001, 0);\n    float ref = bumpTexture(p);                 \n    vec3 grad = vec3(bumpTexture(p - e.xyy) - ref,\n                     bumpTexture(p - e.yxy) - ref,\n                     bumpTexture(p - e.yyx) - ref) / e.x;\n             \n    grad -= nor * dot(nor, grad);          \n                      \n    return normalize(nor + grad * bumpfactor);\n\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n//    mouse *= 2.;\n    \n    // set up camera position\n    vec3 ro =  vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // light is relative to the camera\n    vec3 light = ro + vec3(-.6, .1, -.1);\n    \n    vec2 rot = vec2(0);\n    if (iMouse.z > 0.) {\n    \t// rotate the scene using the mouse\n        rot = -mouse;\n    } else {\n        // otherwise rotate constantly as time passes\n        rot = vec2(0);\n    }\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(light.yz, rot.y);\n//    tRotate(light.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    normal = doBumpMap( p, normal, .01);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal) * .5 + .5;\n    \n    // add this all up\n    fragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR);\n    \n    // fog\n    vec4 fogColor = vec4(vec3(0.02, .01, .03) * (2. - length(uv)), 1.);\n    fragColor = mix(fragColor, fogColor, saturate(dist * dist * .05));\n    \n    // if we passed the cake, then apply a dark glow, this makes the cake pop out\n    if (length(p) > .6) \n        fragColor *= saturate(1. - sqrt(steps / float(MAX_STEPS)) * 1.5);\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n    iMouse = vec3(mouse * resolution, 1.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "a875ffb", "parent": "/e#47077.0", "id": 47083}