{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/MlX3Wr\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Galvanize Tunnel\n// From Alcatraz 8K intro Galvanize\n\n// http://www.pouet.net/prod.php?which=63821\n// https://www.youtube.com/watch?v=z5cFJryE_fc\n\n\n// Jochen \"Virgill\" Feldkoetter\n\n//*****************************************************\n\n\nfloat blend =0.0; float scene = 35.;\nfloat d = 0.0; float m = 0.0;\nfloat kalitime;\nfloat depth = 0.0; \nfloat prec =0.002;\nvec4 orbitTrap = vec4(0.0);\n\n\n// Rotate\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2; p.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2; p.z = z2;\n\treturn p;\n}\n\nvec3 rotZaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\n\tp.x = x2; p.y = y2;\n\treturn p;\n}\n\n\n// Rand\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Polyomial smooth min (IQ)\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Length\nfloat length2(vec2 p) \n{ \n  \treturn dot(p, p); \n}\n\n// Worley effect \nfloat worley(vec2 p) \n{\n\tfloat d = 1.;\n\tfor (int xo = -1; xo <= 1; ++xo)\n\tfor (int yo = -1; yo <= 1; ++yo) \n    {\n\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\td = min(d, length2(p - tp - vec2(rand1(tp))));\n\t}\n\treturn 3.*exp(-4.*abs(2.*d - 1.));\n}\n\nfloat fworley(vec2 p) \n{\n\treturn sqrt(sqrt(sqrt(worley(p*32. + 4.3 + iTime*.250) * sqrt(worley(p * 64. + 5.3 + iTime * -.125)) * sqrt(sqrt(worley(p * -128. +7.3))))));\n}\n\n\n\n\n\n// Kalibox (Kali / Fractalforums.com)\nfloat Kalibox(vec3 pos) \n{\n\tfloat Scale = 1.84;\t\t\t\t\t\t\n\tint Iterations = 14;\t\t\t\n\tint ColorIterations = 3;\t\t\n\tfloat MinRad2 = 0.34;\t\n\tvec3 Trans = vec3(0.076,-1.86,0.036);\t\t\t\n\tvec3 Julia = vec3(-0.66,-1.2+(kalitime/80.),-0.66);\t\n\tvec4 scale = vec4(Scale, Scale, Scale, abs(Scale)) / MinRad2;\n\tfloat absScalem1 = abs(Scale - 1.0);\n\tfloat AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations));\n    vec4 p = vec4(pos,1), p0 = vec4(Julia,1); \n\tfor (int i=0; i<14; i++)\n\t\t{\n\t\t\tp.xyz=abs(p.xyz)+Trans;\n\t\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\t\tp *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0); \n\t\t\tp = p*scale + p0;\n\t\t\tif (i<ColorIterations) orbitTrap = min(orbitTrap, abs(vec4(p.xyz,r2)));\n\t\t}\n\treturn (    (length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters    );\n}\n\n\n\n// Plane\nfloat sdPlane(in vec3 p) \n{\n\treturn p.y+(0.025*sin(p.x*10.  +1.4*iTime  ))+(0.025*sin(p.z*12.3*cos(0.4-p.x)+  1.6*iTime  ))-0.05;\n}\n\n// Cylinder \nfloat sdCylinder( vec3 p, vec3 c )\n{\n\treturn length(p.xz-c.xy)-c.z;\n}\n\n\n// Map\nfloat map(in vec3 p)\n{\n\torbitTrap = vec4(10.0);\n\td = sdPlane(p);\n\n\tvec3 c = vec3(2.0, 8.0, 2.0);\n\tvec3 q = mod(p-vec3(1.0,0.1*iTime,1.0),c)-0.5*c;\n\tfloat kali = Kalibox(rotYaxis(q,0.04*iTime));\n\tm = max(kali,-sdCylinder(p,vec3(0.0,0.0,0.30+0.1*sin(iTime*0.2))) );\n\n\td = sminPoly (m, d, 0.04); \n   return d;\n}\n\n\n// Normal Calculation\nvec3 calcNormal(in vec3 p) \n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx));\n    return normalize(nor);\n}\n\n// Cast\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt) \n{\n    float precis = prec;\n    float h = precis * 2.0;\n    float t = depth;\n\n    for(int i = 0; i < 122; i++) \n\t{\n        if(abs(h) < precis || t > maxt) break;\n        orbitTrap = vec4(10.0);\n\t\th = map(ro + rd * t);\n        t += h;\n\t}\n    return t;\n}\n\n// Softshadow (IQ)\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) \n{\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 19; i++) \n\t{\n        if(t > maxt) continue;\n\t\torbitTrap = vec4(10.0);\n        h = map(ro + rd * t);\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\n\n// Orbit color\nvec3 getColor()\n{\n\tvec3 BaseColor = vec3(0.2,0.2,0.2);\n\tvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\n\tvec4 X = vec4(0.5, 0.6, 0.6, 0.2);\n\tvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\n\tvec4 Z = vec4(0.8, 0.7, 1.0, 0.3);\n\tvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\n    orbitTrap.w = sqrt(orbitTrap.w);\n\tvec3 orbitColor = X.xyz*X.w*orbitTrap.x + Y.xyz*Y.w*orbitTrap.y + Z.xyz*Z.w*orbitTrap.z + R.xyz*R.w*orbitTrap.w;\n\tvec3 color = mix(BaseColor,3.0*orbitColor,OrbitStrength);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    kalitime = iTime-15.0; \n \tblend=min(2.0*abs(sin((iTime+0.0)*3.1415/scene)),1.0); \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat theta = sin(iTime*0.03) * 3.14 * 2.0;\n    float x = 3.0 * cos(theta);\n    float z = 3.0 * sin(theta);\n\tvec3 ro; \n\n\n\tro = vec3(0.0, 8.0, 0.0001);  \n\n\tvec3 ta = vec3(0.0, 0.25, 0.0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n\n// Render:\n    vec3 col = vec3(0.0);\n    float t = castRay(ro, rd, 12.0);\n\tvec3 pos = ro + rd *t;\n\tvec3 nor = calcNormal(pos);\n\tvec3 lig;\t\n\tlig = normalize(vec3(-0.4*sin(iTime*0.15), 1.0, 0.5));\n\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n\tvec3 color = getColor();\n\tcol = ((0.8*dif+ spec) + 0.35*color);\n\tcol = col*clamp(sh, 0.0, 1.0);\n\n\n// Postprocessing\n\tfloat klang1=0.4;\n\tvec2 uv2=-0.3+2.*fragCoord.xy/iResolution.xy;\n\tcol-=0.20*(1.-klang1)*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\n\tcol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.x*iResolution.x);\t\n\tcol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.y*iResolution.y);\t\n\tfloat Scr=1.-dot(uv2,uv2)*0.15;\n\tvec2 uv3=fragCoord.xy/iResolution.xy;\n\tfloat worl = fworley(uv3 * iResolution.xy / 2100.);\n\tworl *= exp(-length2(abs(2.*uv3 - 1.))); \n\tworl *= abs(1.-0.6*dot(2.*uv3-1.,2.*uv3-1.));\n\tcol += vec3(0.40*worl,0.35*worl,0.25*worl);\n\n// Border    \n\tfloat g2 = (blend/2.)+0.39;\n\tfloat g1 = ((1.-blend)/2.);\n\tif (uv3.y >=g2+0.11) col*=0.0;\n\tif (uv3.y >=g2+0.09) col*=0.4;\n\tif (uv3.y >=g2+0.07) {if (mod(uv3.x-0.06*iTime,0.18)<=0.16) col*=0.5;}\n\tif (uv3.y >=g2+0.05) {if (mod(uv3.x-0.04*iTime,0.12)<=0.10) col*=0.6;}\n\tif (uv3.y >=g2+0.03) {if (mod(uv3.x-0.02*iTime,0.08)<=0.06) col*=0.7;}\n\tif (uv3.y >=g2+0.01) {if (mod(uv3.x-0.01*iTime,0.04)<=0.02) col*=0.8;}\n\tif (uv3.y <=g1+0.10) {if (mod(uv3.x+0.01*iTime,0.04)<=0.02) col*=0.8;}\n\tif (uv3.y <=g1+0.08) {if (mod(uv3.x+0.02*iTime,0.08)<=0.06) col*=0.7;}\n\tif (uv3.y <=g1+0.06) {if (mod(uv3.x+0.04*iTime,0.12)<=0.10) col*=0.6;}\n\tif (uv3.y <=g1+0.04) {if (mod(uv3.x+0.06*iTime,0.18)<=0.16) col*=0.5;}\n\tif (uv3.y <=g1+0.02) col*=0.4;\n\tif (uv3.y <=g1+0.00) col*=0.0;\n    \n    \n    fragColor = vec4(col*Scr,1.0)*blend;\n \n }\n\n\n\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "d3c0b0e", "parent": null, "id": 47209}