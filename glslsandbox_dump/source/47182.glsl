{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/ltSGDW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\nconst float charWidth = 0.013;\nconst float charHeight = 0.02;\n\nconst float charMax = 40.0;\nconst float tabMax = 8.0;\nconst float charsPerTab = 4.0;\n\nconst float speed = 0.6;\nconst float jitter = 0.5;\nconst float warp = 0.7;\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\n//\tHash function adapted from David Hoskins:\n//\thttps://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nvec2 hash22(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nfloat noise12(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash12(i + vec2(0.0, 0.0)), \n                               hash12(i + vec2(1.0, 0.0)), u.x),\n                           mix(hash12(i + vec2(0.0, 1.0)), \n                               hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec2 noise22(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash22(i + vec2(0.0, 0.0)), \n                               hash22(i + vec2(1.0, 0.0)), u.x),\n                           mix(hash22(i + vec2(0.0, 1.0)), \n                               hash22(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm12(vec2 p) {\n    float f = noise12(p); p = m * p;\n    f += 0.5 * noise12(p); p = m * p;\n    f += 0.25 * noise12(p); p = m * p;\n    f += 0.125 * noise12(p); p = m * p;\n    f += 0.0625 * noise12(p);\n    return f / 1.9375;\n}\n\nvec2 fbm22(vec2 p) {\n    vec2 f = noise22(p); p = m * p;\n    f += 0.5 * noise22(p); p = m * p;\n    f += 0.25 * noise22(p); p = m * p;\n    f += 0.125 * noise22(p); p = m * p;\n    f += 0.0625 * noise22(p);\n    return f / 1.9375;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat screenWidth = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    float green = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        float id = float(i);\n\n        float x = uv.x - 0.2 * screenWidth * id;\n        float y = uv.y - speed * iTime + jitter * fbm12(vec2(0.2 * iTime, id));\n\n        vec2 w = fbm22(0.2 * uv + vec2(0.1 * iTime, 4.0 * id));\n        x += warp * w.x;\n        y += warp * w.y;\n\n        float charX = mod(x, charWidth) / charWidth;\n        float charY = mod(y, charHeight) / charHeight;\n        float col = x / charWidth;\n        float row = floor(y / charHeight);\n\n        float rowHash = hash12(vec2(row, id));\n        float rowWidth = 1.0 + floor(charMax * rowHash * rowHash);\n        float rowIndent = charsPerTab * floor(tabMax * abs(fbm12(vec2(0.15 * row, id))));\n\n        float char = -0.5 + 4.0 * noise12(vec2(4.0 * col, 6.0 * y / charHeight));\n        char *= smoothstep(0.0, 0.4, charX) * smoothstep(1.0, 0.6, charX);\n        char *= smoothstep(0.1, 0.4, charY) * smoothstep(1.0, 0.7, charY);\n        char *= step(rowIndent, col);\n        char *= step(col, rowIndent + rowWidth);\n        \n        green += clamp(char, 0.0, 1.0);\n    }\n    fragColor = vec4(0.0, green, 0.0, 1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "ca05b67", "parent": null, "id": 47182}