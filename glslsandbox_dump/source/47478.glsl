{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4dVfzW\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nconst vec3  iMouse = vec3(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n\n#define MAX_STEPS 512\n#define CLOSE_CLIP 0.1\n#define FAR_CLIP 100.0\n#define EPSILON 0.0001\n\nmat2 rotmat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 mouse()\n{\n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n\treturn m;\n}\n\nfloat sdSphere(vec3 rayPos, float radius)\n{\n \treturn length(rayPos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 k,float t)\n{\n\treturn vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\n}\n\nvec2 map(vec3 pos)\n{\n \t\n    vec3 b = vec3(0.9 , 4.5, 0.70);\n    float p = sin(pos.z * 0.1) * 2.0;\n  \n    pos = vec3(rotate(pos.xy, p), pos.z);\n    \n    pos.y += iTime * 1.2;\n    pos = mod(pos, b) -0.5 * b;\n    \n    pos.x *= sin(length(pos * 1.8) * 2.0) * 1.4;\n    \n    float boxScale = 0.4;\n    \n    vec2 result = vec2(sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(boxScale)), 1.0);\n  \n    return result;\n}\n\n\n\nvec2 sdScene(vec3 pos)\n{\n    \n    vec2 scene = map(pos);\n    \n    return scene;\n    \n}\n\nvec2 raymarch(vec3 rayStartPos, vec3 ray_direction)\n{\n    float depth = CLOSE_CLIP;\n \t\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec2 result = sdScene(rayStartPos + ray_direction * depth);\n            \n        if(result.x < EPSILON)\n            return vec2(depth, result.y);\n        \n        depth += result.x;\n        \n        if(depth > FAR_CLIP)\n            return vec2(FAR_CLIP, 0.0);;\n        \n    }\n    \n    return vec2(FAR_CLIP, 0.0);\n}\n\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{  \n    vec3 n;\n    vec2 dn = vec2(smoothness, 0.0);\n    \n    float d = sdScene(ray_hit_position).x;\n    \n    n.x = sdScene(ray_hit_position + dn.xyy).x - d;\n    n.y = sdScene(ray_hit_position + dn.yxy).x - d;\n    n.z = sdScene(ray_hit_position + dn.yyx).x - d;\n    \n    return normalize(n);\n}\n\n\nfloat softshadow( vec3 ray_origin, vec3 ray_direction, float mint, float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<8; i++ )\n    {\n\t\tfloat h = map( ray_origin + ray_direction * t ).x;\n        \n        res = min( res, 8.0*h/t );\n        \n        t += clamp( h, 0.02, 0.10 );\n        \n        if( h<0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(vec3 ray_pos, vec3 ray_direction)\n{\n \t   \n    vec2 result = raymarch(ray_pos, ray_direction);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n   \tfloat d = result.x;\n    float m = result.y;\n    \n    vec3 pos = ray_pos + d * ray_direction;\n    \n    vec3 nrml = normal(pos, 0.001);\n    float occ = calcAO( pos, nrml ); // ambient occlusion\n    \n   \n    vec3  lig = normalize( vec3(-0.5, 0.5, -0.5) ); // sunlight\n   \n    if(m == 1.0)\n        col = vec3(0.3, 0.3, 0.45);\n    \n    vec3 lin = vec3(0.0);\n    vec3 ref = reflect( ray_direction, nrml ); // reflected ray\n   \n\tfloat amb = clamp( 0.5 + 0.5 * nrml.y, 0.0, 1.0 ); // ambient light\n    float dif = clamp( dot( nrml, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n    float spec = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n    float fre = pow( clamp(1.0 + dot(nrml,ray_direction),0.0,1.0), 2.0 ); // fresnel\n    float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n    \n    dif *= softshadow( pos, lig, 0.3, 4.5 );\n    dom *= softshadow( pos, ref, 0.3, 2.5 ) ;\n    \n    lin += 2.30 * dif * vec3(1.00,0.80,0.55) ;\n    lin += 2.00 * spec * vec3(1.00,0.90,0.70) * dif ;\n    lin += 0.20 * amb * vec3(0.40,0.60,1.00) * occ ;\n    lin += 0.45 * fre * vec3(1.00,1.00,1.00) * occ ;\n    lin += 0.20 * dom * vec3(0.40,0.60,1.00) ;\n   \n    col = col * lin;\n    \n    col = mix( col, vec3(0.6,0.9,1.0), 1.0 - exp( -0.00035*d*d*d ) );\n    \n    return vec3( clamp(col, 0.0, 1.0));    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n   \n    vec3 camera = vec3(0.0, 0.0, 0.0);\n    camera.z += iTime * 3.0;\n    //camera.y = mouse().y * 20.0;\n    vec3 ray_direction = normalize(vec3(uv, 2.0));\n   \n    //ray_direction.xz *= rotmat(-mouse().x * 10.0);\n    //ray_direction.yz *= rotmat(mouse().y * 10.0);\n    \n    vec3 col = render(camera, ray_direction);\n    \n    float o = smoothstep(0.99, 0.2, length(uv));\n  \n    fragColor = vec4(col, 1.0) ;\n    \n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "d6c40cd", "parent": null, "id": 47478}