{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/ldyBDD\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n// this was inspired by the following two shaders:\n// https://www.shadertoy.com/view/Mdf3z7\n// https://www.shadertoy.com/view/MlfczH\n\n#define A 2. * iTime\n#define MinimumDistance 0.0009\n#define asgt(i) abs(sin(i * iTime))\n#define acgt(i) abs(cos(i * iTime))\n#define sgt(i) sin(i * iTime)\n#define cgt(i) cos(i * iTime)\n#define Giter 5\n#define MaxSteps 10\n#define Iterations 10\n#define raySteps 32 // changing this to 64 might open your third eye\n\nfloat DE(in vec3 z) {\n    vec3 Offset = vec3(0.92858,0.92858,0.32858);\n    Offset.y += 0.5*asgt(0.05);\n    Offset.x -= 0.2*cgt(0.1);\n    \n    float Scale = 2.0 + 1.2*asgt(0.1);\n    Scale += 0.2*sgt(1.);\n\n\tz  = abs(2.-mod(z,4.0));\n\n    z.x *= (1. - 0.01*sgt(1.));\n    z.y *= (1. + 0.01*cgt(1.0));\n    z.z *= (1. + 0.01*sgt(1.0));\n\n\tfloat d = 10.0;\n\tfor (int m = 0; m < Iterations; m++) {\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(2.*Scale-1.);\n\t\tif( z.z < -0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\n        d = min(d, length(z) * pow(Scale, float(-m)-1.0));\n\t}\n\n\treturn d-0.001;\n}\n    \nvec3 Glow(vec3 z, float b){\n    z = fract( z * .2) * 2. -1.;\n\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    return z;\n}\n\nvec3 fog(float a,vec3 b,float c){ \n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c );\n}\n\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e=(fog( .1, abs(fr), d)*1. +\n            fog( .1, vec3(length( fr.yz ), length( fr.zx ), length( fr.xy )), d) * 5.0 \n            * (sin( A * vec3(2.1, 1.3, 1.7) + b*10.) + 1.)); \n\n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( .5 -c *(200.+500.*asgt(1.)) / d, 0. ) / d * 70.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float speed = 0.5;\n    vec3 base = vec3(0.1, 0.3*sgt(0.1), 0.3*cgt(0.1)) * speed;\n\n    vec3 camPos = 0.2*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos); \n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); \n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color = vec3(0.); float totalDistance = 0., distance, v;\n\n    for(int i = 0; i < raySteps; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = DE(pos);        \n        v = sin( A * .1 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance + .001; \n        color += ( W( x, v, distance, 1.) ) * (distance + 0.001);      \n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "6a93bf0", "parent": null, "id": 47480}