{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/ldGGRc\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define time iTime * 0.5\nconst float PI=3.14159265;\nconst float PIH = PI*0.5;\nconst int MAX_ITER = 110;\nconst float EPSILON = 0.00001;\nvec3 lightDir = normalize(vec3(0, 1, 0.75)); \n\nfloat bgMatType = 0.0;\nfloat EyesNoseAndMouthType = 1.0;\nfloat BodyMatType = 2.0;\nfloat PlaneMatType = 3.0;\nfloat BoxMatType = 4.0;\nfloat RibbonMatType = 5.0;\n\nvec3 boxPos = vec3(0, 10, -18);\nvec3 boxSize = vec3(8, 5, 5);\n\nvec3 skyColor = vec3(0.8, 0.9, 1.0);\nvec3 bodyColor = vec3(0.35,0.35,0.35);\nvec3 planeColor = vec3(0.7,0.7,0.7);\nvec3 eyesColor = vec3(0.0, 0.0, 0.0);\nvec3 boxColor = vec3(0.7,0.0,0.0);\nvec3 ribbonColor = vec3(0.7,0.7,0.0);\n\n//#define SELF_SHADOW\n#define CHEAP_AO\n\n//---------------------------------------------\nvec3 rotationCoord(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//------------------------------------------\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//------------------------------------------\nvec2 rot(vec2 p,float r)\n{\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n\n//------------------------------------------\nvec2 rotsim(vec2 p,float s)\n{\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n\n//----------------------------------------------------\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float basic = 0.61;\n    return max(q.z-h.y,max(q.x* basic +p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n\n//----------------------------------------------------------------\nvec3 InstantiateRotY(vec3 p, float inPiFrac)\n{\n\tfloat rad\t\t= mod(atan(p.x, p.z) +  PIH*inPiFrac, PI*inPiFrac) - PIH*inPiFrac;\n\tp.xz\t\t\t= vec2(sin(rad), cos(rad)) * length(p.xz);\n\treturn p;\n}\n\n//----------------------------------------------------------------\nfloat tail(vec3 p)\n{\n    p.yz = rot(p.yz, PIH * 0.5);\n    p = rotationCoord(p, -PIH*0.4);\n\tfloat hMax\t\t= 40.0;\n\tfloat hScalePos\t= clamp(p.y / hMax, 0.0, 1.0);\n\tfloat h\t\t\t= abs(p.y-hMax*0.5)- hMax*0.5;\n\t\n\tp.x\t\t\t\t+= sin(hScalePos * PI * 1.75) * hScalePos * hMax * 0.25;\n    p.x\t\t\t\t+= sin(hScalePos * PI * 4.0) * hMax * 0.05;\n    p.z\t\t\t\t+= sin(hScalePos * PI * 1.5) * hMax * 0.25;\n    p.z\t\t\t\t+= sin(hScalePos * PI * 3.0) * hMax * 0.1;\n\t\n\t// Y - axis rotate-instantiation\n\tp\t\t\t\t= InstantiateRotY(p, 1.0/16.0);\n\t\t\n\tfloat wl\t\t= mix(1.2, 0.2, hScalePos);\n\treturn max(max(p.x-wl, p.z-wl), h);\n}\n\nfloat dSegment(vec3 pa, vec3 ba, float r)\n{\n    return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0))-r;\n}\n\nfloat dBox( vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//--------------------------------------------------\u00d0\u2019\u00d0\u00b5\u00d1\u20ac\u00d1\u201a\u00d1\u0192\u00d1\u02c6\u00d0\u00ba\u00d0\u00b0\nfloat ribbon(in vec3 p )\n{\n    p.xy = rot(p.xy, PIH);\n \tp.yz=rotsim(p.yz,2.5);\n \treturn sdTriPrism( p, vec2(1.5, 3.5) );\n}\n\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------\nvec2 minDistMat(vec2 curDist, vec2 dist)\n{\n   \tif (dist.x < curDist.x) \n   \t{\n    \treturn dist;\n   \t}\n   \treturn curDist;\n}\n\n//--------------------------------------------------\nfloat mouse(in vec3 pos )\n{\n  \tfloat d = 1.;\n   \t// Head\n   \td = dSphere(pos * vec3(0.8, 1.3, 1.0), 10.);\n    d = smin(d, dSphere(pos * vec3(0.7, 0.5, 0.8) + vec3(0., 0.58, 0.0), 6.), 2.0);\n    \n   \tpos.y +=11.;\n    // Body\n   \td = smin(d, dSphere(pos * vec3(0.6, 0.5, 0.8), 6.), 1.0); \n    d = smin(d, dSphere(pos * vec3(0.7, 1.5, 0.7) + vec3(0., 6.58, 0.0), 8.), 10.0);\n    \n    pos.y +=5.;\n    // Snout\n   \td = smin(d, dSphere(pos * vec3(1.03, 1.08, -0.64) + vec3(0., -15.58, 4.5), 3.8), 3.);\n    \n    // Ears\n   \tvec3 p1 = pos;\n   \tp1.x = abs(p1.x);       \n   \td = smin(d, dSphere(p1 * vec3(0.66, 0.5, 1.8) + vec3(-6, -15., 0), 5.), 1.5);\n    d = max(d, -dSphere(p1 *vec3(1,0.7,2)+ vec3(-9, -22, -5.2), 5.2)); \n    \n   \t// Legs\n   \td = smin(d, dSphere(p1 * vec3(1, 1, 0.4) + vec3(-5., 7.25, -1.0), 4.), 1.3);    \n    \n   \t// Arms\n   \td = smin(d, dSphere(p1 * vec3(1.95, 2.3, -0.8 ) + vec3(-20, -10.8, 5.5), 7.), 1.0); \n    \n    // Tail\n    d = smin(d, tail(pos + vec3(2.0,0.0, 6.0)),1.5);\n\n  \treturn d;\n  \n}\n\n//--------------------------------------------------\nvec2 map(in vec3 p)\n{\n   \tvec3 pos = p;\n   \tpos += vec3(0., 5., 35.);\n   \tpos = rotationCoord(pos, time);     \n   \tvec2 d = vec2(1.0, bgMatType);\n   \t\n   \tvec3 p1 = pos;\n   \tp1.x = abs(p1.x);\n    p1 += vec3(-3.12, -1.62, -9.54);   \n    \n    // Eyes\n   \tvec2 eyes = vec2(dSphere(p1, 1.), EyesNoseAndMouthType);\n   \td =  minDistMat(d,   eyes); \n    \n\t// Moustache\n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 2.2, -3.), vec3(7, 0, -1), 0.1),  EyesNoseAndMouthType)); \n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 1.8, -3.), vec3(6.5, 1, -1), 0.1),  EyesNoseAndMouthType)); \n    d =  minDistMat(d,  vec2(dSegment( p1 + vec3(2.0, 2.7, -3.), vec3(6.5, -1, -1), 0.1),  EyesNoseAndMouthType));\n    \n    // Nose\n   \td =  minDistMat(d,   vec2(dSphere(pos + vec3(0., 0.6, -12.5), 0.5) ,  EyesNoseAndMouthType));    \n\n  \tfloat toy = mouse(pos);\n   \td =  minDistMat(d,   vec2(toy , BodyMatType));   \n    \n    // Box\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize), BoxMatType));\n    \n    // Ribbon\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize * vec3(1.05, 1.05, 0.3)), RibbonMatType));\n    d = minDistMat(d, vec2(dBox(pos + boxPos, boxSize * vec3(0.2, 1.05, 1.05)), RibbonMatType));\n    d = minDistMat(d, vec2(ribbon(pos + boxPos - vec3(0, boxSize.y + 0.5, 0)), RibbonMatType));\n    \n    // Plane\n    d = minDistMat(d, vec2(sdPlane(pos + vec3(0,23.6,0)), PlaneMatType));\n    \n\treturn d; \n}\n\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( 0.1, 0., 0. );\n   vec3 nor = vec3(\n       map(p+e.xyy).x - map(p-e.xyy).x,\n       map(p+e.yxy).x - map(p-e.yxy).x,\n       map(p+e.yyx).x - map(p-e.yyx).x);\n   return normalize(nor);  \n\n}\n\n//------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {        \n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<EPSILON || t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0 );\n}\n\n//------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n#ifdef CHEAP_AO\n    return mix(0.5, 1.0, clamp((nor.y + 1.0) * 0.5, 0.0, 1.0)); \n#else\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 0.5*occ, 0.0, 1.0 );   \n#endif\n}\n\n\n//------------------------------------------\nvec3 illum(in vec3 pos, in vec3 ro, in vec3 rd ,in vec3 nor, in vec3 lig, in vec3 col, in float t, in float mat)\n{\n    // lighitng \n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );    \n    \n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n#ifndef SELF_SHADOW\n    if(mat == PlaneMatType) \n#endif\n    \tdif *= softshadow( pos, lig, 5.5, 75.0 );\n    \n    vec3 brdf = vec3(0.0);\n    brdf += 1.0*dif*vec3(1,1,1);\n    brdf += 0.15*spe*vec3(1,1,1)*dif;\n    brdf += 0.30*amb*skyColor*occ;\n    brdf += 0.10*dom*skyColor*occ;\n    brdf += 1.0*bac*vec3(0.25,0.25,0.25)*occ;\n    brdf += 1.0*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n\tcol = col*brdf;\n    \n    return col;\n}\n//----------------------------------------------------------------------\nvec3 getColor(inout vec3 ro, vec3 rd, vec2 t)\n{\n  \tvec3 color = skyColor; \n \n   \tfloat mat =  t.y;\n   \tif (mat > 0.0) \n   \t{\n        vec3 hitPos = ro + rd * t.x;\n  \t\tvec3 normal = normalize(getNormal(hitPos)); \n        \n   \t\tif (mat == BodyMatType) \n   \t\t{\n\t    \tcolor = bodyColor;\n   \t\t}\n    \telse if (mat == PlaneMatType) \n   \t\t{\n\t    \tcolor = planeColor;\n   \t\t}\n   \t\telse if (mat == EyesNoseAndMouthType) \n   \t\t{\n     \t\tcolor = eyesColor; \n   \t\t}\n        else if (mat > PlaneMatType && mat < RibbonMatType) \n        {\n            color = boxColor;\n        }\n        else \n        {\n            color = ribbonColor;\n        }\n\t    \n    \tcolor = illum(hitPos, ro, rd, normal, lightDir, color.rgb, t.x, mat);\n    }\n   \n  \treturn color;\n}\n\n//-------------------------------------------------\nvec2 render(in vec3 posOnRay, in vec3 rayDir)\n{ \n    vec2 t = vec2(0.0, bgMatType);\n    float maxDist = 100.;\n    for(int i=0; i<MAX_ITER; ++i)\n    {\n        vec2 d = map(posOnRay + t.x*rayDir); \n        if (abs(d.x) < EPSILON || t.x > maxDist) \n            break;\n        t.x += d.x;//max(d.x, MIN_STEP);\n        t.y = d.y;\n    }\n    return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n       \n    vec3 camP = vec3(0., 4., 30.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(2. * camDir + pos.x * u + pos.y * v);  \n   \t \n    vec2 t =  render(camP, rayDir);  \n    vec3 color = getColor(camP, rayDir, t); \n    \n    // gamma\n\tcolor = pow( clamp( color, 0.0, 1.0 ), vec3(0.45) );\n    \n    // vignetting\n    pos*=0.35;\n    float distSqr = dot(pos, pos);\n\tfloat vignette = 1.0 - distSqr;\n    color *=  vignette;\n    \n    fragColor = vec4(color, 1.0);\n\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n \n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "b598f28", "parent": null, "id": 47204}